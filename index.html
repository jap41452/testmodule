<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Frame Analysis (2D) — Professional</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<style>
  :root { --pad:12px; --panel-w:600px; --primary:#2563eb; --text:#1f2937; --bg:#f4f6f8; }
  body { background:var(--bg); font-family:system-ui,-apple-system,sans-serif; margin:16px; color:var(--text); overflow:hidden; }
  
  /* Layout */
  .layout { display:grid; grid-template-columns: 1fr var(--panel-w); gap:16px; height:94vh; }
  .col { background:#fff; border:1px solid #d1d5db; border-radius:8px; display:flex; flex-direction:column; overflow:hidden; box-shadow:0 2px 4px rgba(0,0,0,0.05); }
  
  /* Toolbar */
  .toolbar { padding:10px; background:#f8fafc; border-bottom:1px solid #e2e8f0; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .sep { width:1px; height:24px; background:#cbd5e1; margin:0 4px; }
  
  /* Controls */
  button { height:32px; padding:0 14px; border:1px solid #94a3b8; border-radius:5px; background:#fff; font-size:13px; font-weight:600; color:#334155; cursor:pointer; transition:all 0.1s; }
  button:hover { background:#f1f5f9; border-color:#64748b; }
  button.active { background:#e2e8f0; border-color:#475569; color:#0f172a; box-shadow:inset 0 1px 2px rgba(0,0,0,0.1); }
  button.primary { background:var(--primary); color:#fff; border-color:var(--primary); }
  button.primary:hover { background:#1d4ed8; }
  button.success { border-color:#059669; color:#059669; }
  button.success:hover { background:#ecfdf5; }
  
  input[type=number] { height:30px; width:60px; padding:0 6px; border:1px solid #cbd5e1; border-radius:4px; font-size:13px; }
  select { height:32px; border:1px solid #cbd5e1; border-radius:4px; font-size:13px; }

  /* Canvas */
  .canvas-wrap { flex:1; position:relative; overflow:hidden; background:#fff; cursor:crosshair; }
  canvas { position:absolute; inset:0; }

  /* Right Panel */
  .panel-content { padding:12px; overflow-y:auto; display:flex; flex-direction:column; gap:16px; }
  .section { border:1px solid #e5e7eb; border-radius:6px; overflow:hidden; }
  .sec-head { background:#f1f5f9; padding:8px 12px; font-weight:700; font-size:12px; color:#475569; border-bottom:1px solid #e5e7eb; display:flex; justify-content:space-between; }
  .sec-body { max-height:200px; overflow-y:auto; background:#fff; }
  
  .list-item { display:grid; grid-template-columns: 40px 1fr auto; padding:6px 12px; border-bottom:1px solid #f8fafc; font-size:12px; align-items:center; }
  .list-item:hover { background:#f8fafc; cursor:pointer; }
  .del-btn { color:#ef4444; font-weight:bold; cursor:pointer; padding:2px 6px; border-radius:4px; }
  .del-btn:hover { background:#fee2e2; }

  /* Stress Panel */
  #stressWrap { height:220px; border-top:1px solid #e5e7eb; background:#fafafa; padding:10px; display:flex; flex-direction:column; }
  #stressCanvas { flex:1; width:100%; border:1px solid #e2e8f0; background:#fff; }

  /* Utilities */
  .hint { font-size:11px; color:#64748b; margin-left:8px; font-weight:400; }
  .swal2-popup { font-size:13px !important; width:380px !important; }
  .prop-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; text-align:left; font-size:13px; }
  .prop-grid label { font-weight:600; color:#4b5563; }
</style>
</head>
<body>

<div class="layout">
  <div class="col">
    <div class="toolbar">
      <button id="btnDraw" class="primary active">Draw Members</button>
      <button id="btnSelect">Select / Edit</button>
      <div class="sep"></div>
      <button id="btnUndo">Undo</button>
      <button id="btnClear">Clear</button>
      <div class="sep"></div>
      
      <button id="btnExportJSON">Export JSON</button>
      <button id="btnImportJSON">Import JSON</button>
      <div class="sep"></div>
      <button id="btnExportCSV" class="success">Export CSV (Save)</button>
      <button id="btnImportCSV" class="success">Import CSV (Load)</button>
      
      <input type="file" id="fileIn" style="display:none;" />
    </div>

    <div class="canvas-wrap" id="canvasContainer">
      <canvas id="baseLayer"></canvas>
      <canvas id="activeLayer"></canvas>
      <div style="position:absolute; bottom:10px; left:10px; background:rgba(255,255,255,0.9); padding:6px; border-radius:4px; font-size:11px; border:1px solid #ccc; pointer-events:none;">
        Left Click: Action &nbsp;|&nbsp; Right Click: Pan &nbsp;|&nbsp; Wheel: Zoom
      </div>
    </div>

    <div class="toolbar" style="border-top:1px solid #e2e8f0; border-bottom:none;">
      <span><strong>Analysis:</strong></span>
      <input id="divCount" type="number" value="10" title="Internal segments" style="width:50px">
      <button id="btnSolve" class="primary">Solve Static</button>
      <button id="btnModes">Solve Modes</button>
      
      <div class="sep"></div>
      
      <span><strong>View:</strong></span>
      <button id="viewDef">Deflection</button>
      <button id="viewDiags">Diagrams</button>
      <label style="font-size:12px; margin-left:6px;">Scale:</label>
      <input id="defScale" type="number" value="1" step="0.1">
      <select id="modeSelect" style="width:80px; display:none;"><option value="0">Static</option></select>
      <button id="btnAnim">▶</button>
    </div>
  </div>

  <div class="col">
    <div class="panel-content">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2 style="margin:0;">Model Data</h2>
        <div style="font-size:12px;">
          <button id="btnUS" class="active" style="padding:2px 8px; height:24px;">US</button>
          <button id="btnSI" style="padding:2px 8px; height:24px;">SI</button>
        </div>
      </div>

      <div class="section">
        <div class="sec-head">Nodes <span class="hint">(Double-click canvas to edit)</span></div>
        <div id="nodeList" class="sec-body"></div>
      </div>

      <div class="section">
        <div class="sec-head">Members <span class="hint">(Double-click canvas to edit)</span></div>
        <div id="memberList" class="sec-body"></div>
      </div>

      <div class="section" style="flex:1;">
        <div class="sec-head">Results</div>
        <div id="resultList" class="sec-body" style="font-family:monospace;">
          <div style="padding:10px; color:#999; text-align:center;">Run analysis to view results</div>
        </div>
      </div>
    </div>

    <div id="stressWrap" style="display:none;">
      <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
        <select id="plotType" style="height:24px; font-size:11px;">
          <option value="M">Moment (M)</option>
          <option value="V">Shear (V)</option>
          <option value="N">Axial (N)</option>
          <option value="sigma">Stress (σ)</option>
        </select>
        <button id="closeStress" style="height:24px; padding:0 8px;">x</button>
      </div>
      <canvas id="stressCanvas"></canvas>
    </div>
  </div>
</div>

<script>
(() => {
  // --- CORE STATE ---
  const state = {
    nodes: [],      // {id, x, y, bc, Fx, Fy, Mz, Kx, Ky, Kt}
    members: [],    // {id, n1, n2, E, A, I, label}
    results: null,  // { U, reactions, stress: {memId: {x[], N[], V[], M[]}} }
    modes: null,    // { freqs:[], shapes:[] }
    units: 'US',
    nextN: 1,
    nextM: 1
  };

  // --- VIEW STATE ---
  const view = {
    ctx: null, ovr: null,
    width: 0, height: 0,
    scale: 1.0, dx: 0, dy: 0,
    mode: 'draw', // draw, select
    show: 'geom', // geom, def
    activeModeIdx: -1, // -1 = static, 0..n = modes
    anim: { active:false, t:0 }
  };

  // --- INTERACTION STATE ---
  const input = {
    dragNode: null,
    hoverNode: null,
    hoverMember: null,
    selNode: null,
    selMember: null,
    panStart: null,
    isPanning: false
  };

  // --- INITIALIZATION ---
  function init() {
    const c1 = document.getElementById('baseLayer');
    const c2 = document.getElementById('activeLayer');
    view.ctx = c1.getContext('2d');
    view.ovr = c2.getContext('2d');
    
    // Bind global resize
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    // Bind Interaction
    c2.addEventListener('mousedown', onDown);
    c2.addEventListener('mousemove', onMove);
    c2.addEventListener('mouseup', onUp);
    c2.addEventListener('wheel', onWheel);
    c2.addEventListener('dblclick', onDbl);
    c2.addEventListener('contextmenu', e => e.preventDefault());

    // Loop
    requestAnimationFrame(loop);
  }

  function fitCanvas() {
    const cont = document.getElementById('canvasContainer');
    view.width = cont.clientWidth;
    view.height = cont.clientHeight;
    [view.ctx.canvas, view.ovr.canvas].forEach(c => {
      c.width = view.width; c.height = view.height;
    });
    // Auto-center if empty or first run
    if(state.nodes.length === 0) {
      view.dx = view.width/2; 
      view.dy = view.height/2;
    }
  }

  // --- MATH HELPERS ---
  const dist = (x1,y1,x2,y2) => Math.hypot(x2-x1, y2-y1);
  const w2s = (x,y) => ({ x: view.dx + x*view.scale, y: view.dy - y*view.scale }); // Y-up world
  const s2w = (x,y) => ({ x: (x - view.dx)/view.scale, y: -(y - view.dy)/view.scale });

  // --- MODEL LOGIC ---
  function addNode(x, y) {
    const id = state.nextN++;
    state.nodes.push({ id, x, y, bc:'free', Fx:0, Fy:0, Mz:0 });
    renderUI();
    return id;
  }

  function addMember(n1, n2) {
    if(n1 === n2) return;
    if(state.members.some(m => (m.n1===n1 && m.n2===n2) || (m.n1===n2 && m.n2===n1))) return;
    const id = state.nextM++;
    state.members.push({
      id, n1, n2, E:29000, A:10, I:200, label:`M${id}`
    });
    renderUI();
  }

  function deleteNode(id) {
    state.nodes = state.nodes.filter(n => n.id !== id);
    state.members = state.members.filter(m => m.n1 !== id && m.n2 !== id);
    clearRes();
    renderUI();
  }

  function deleteMember(id) {
    state.members = state.members.filter(m => m.id !== id);
    clearRes();
    renderUI();
  }

  function clearRes() {
    state.results = null;
    state.modes = null;
    view.activeModeIdx = -1;
    document.getElementById('modeSelect').style.display = 'none';
    renderUI();
  }

  // --- DRAW LOOP ---
  function loop() {
    drawBase();
    drawOverlay();
    if(view.anim.active) {
      view.anim.t += 0.1;
      drawBase(); // Redraw base if animating deflection
    }
    requestAnimationFrame(loop);
  }

  function drawBase() {
    const cx = view.ctx;
    cx.clearRect(0, 0, view.width, view.height);
    
    // Grid
    cx.strokeStyle = '#f1f5f9'; cx.lineWidth = 1;
    cx.beginPath();
    const sz = 10000, st = 120 * view.scale;
    // (Simplified grid for performance)
    
    // Members
    state.members.forEach(m => {
      const n1 = getNode(m.n1); const n2 = getNode(m.n2);
      if(!n1 || !n2) return;
      const p1 = w2s(n1.x, n1.y); const p2 = w2s(n2.x, n2.y);
      cx.beginPath(); cx.moveTo(p1.x, p1.y); cx.lineTo(p2.x, p2.y);
      cx.strokeStyle = '#475569'; cx.lineWidth = 3; cx.stroke();
      
      // Label
      cx.fillStyle = '#000'; cx.font = '12px sans-serif';
      cx.fillText(m.label, (p1.x+p2.x)/2, (p1.y+p2.y)/2 - 5);
    });

    // Nodes
    state.nodes.forEach(n => {
      const p = w2s(n.x, n.y);
      // Support
      if(n.bc !== 'free') {
        cx.fillStyle = '#000'; cx.fillRect(p.x-6, p.y+4, 12, 4);
      }
      // Node Body (Blue)
      cx.fillStyle = '#2563eb';
      cx.beginPath(); cx.arc(p.x, p.y, 5, 0, Math.PI*2); cx.fill();
      // Load
      if(Math.abs(n.Fy) > 0) {
        cx.strokeStyle = '#ec4899'; cx.beginPath(); 
        cx.moveTo(p.x, p.y); cx.lineTo(p.x, p.y - 30 * Math.sign(n.Fy)); cx.stroke();
      }
    });

    // Results (Deformed Shape)
    if((view.show === 'def' || view.anim.active) && (state.results || state.modes)) {
      drawDeformed(cx);
    }
  }

  function drawDeformed(cx) {
    let U = null;
    if(view.activeModeIdx >= 0 && state.modes) U = state.modes.shapes[view.activeModeIdx];
    else if(state.results) U = state.results.U;
    
    if(!U) return;

    let scale = parseFloat(document.getElementById('defScale').value) || 1;
    if(view.anim.active) scale *= Math.sin(view.anim.t);

    cx.strokeStyle = '#ef4444'; cx.lineWidth = 2;
    const dofMap = getDofMap();

    state.members.forEach(m => {
      const n1 = getNode(m.n1); const n2 = getNode(m.n2);
      const i = dofMap[n1.id], j = dofMap[n2.id];
      const u1=U[i], v1=U[i+1], th1=U[i+2];
      const u2=U[j], v2=U[j+1], th2=U[j+2];
      
      const dx = n2.x - n1.x, dy = n2.y - n1.y;
      const L = Math.hypot(dx, dy);
      const c = dx/L, s = dy/L;

      // Transform to local
      const ul1 = u1*c + v1*s, vl1 = -u1*s + v1*c;
      const ul2 = u2*c + v2*s, vl2 = -u2*s + v2*c;

      cx.beginPath();
      for(let k=0; k<=20; k++){
        const t = k/20;
        const x = t*L;
        // Hermite Cubic for v
        const h1 = 1 - 3*t*t + 2*t*t*t;
        const h2 = x * (1 - 2*t + t*t);
        const h3 = 3*t*t - 2*t*t*t;
        const h4 = x * (t*t - t);
        const v_loc = h1*vl1 + h2*th1 + h3*vl2 + h4*th2;
        const u_loc = ul1*(1-t) + ul2*t;

        const u_glob = u_loc*c - v_loc*s;
        const v_glob = u_loc*s + v_loc*c;
        const p = w2s(n1.x + x*c + u_glob*scale, n1.y + x*s + v_glob*scale);
        if(k===0) cx.moveTo(p.x, p.y); else cx.lineTo(p.x, p.y);
      }
      cx.stroke();
    });
  }

  function drawOverlay() {
    const cx = view.ovr;
    cx.clearRect(0, 0, view.width, view.height);

    // Rubberband
    if(input.dragNode && view.mode === 'draw') {
      const p1 = w2s(input.dragNode.x, input.dragNode.y);
      const p2 = input.currMouse || p1;
      cx.strokeStyle = '#3b82f6'; cx.lineWidth = 1; cx.setLineDash([5,5]);
      cx.beginPath(); cx.moveTo(p1.x, p1.y); cx.lineTo(p2.x, p2.y); cx.stroke();
      cx.setLineDash([]);
    }

    // Highlight
    const hNode = input.hoverNode ? getNode(input.hoverNode) : null;
    if(hNode) {
      const p = w2s(hNode.x, hNode.y);
      cx.strokeStyle = '#fbbf24'; cx.lineWidth = 2;
      cx.beginPath(); cx.arc(p.x, p.y, 8, 0, 2*Math.PI); cx.stroke();
    }
  }

  // --- EVENT HANDLERS ---
  function onDown(e) {
    const rect = e.target.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    const w = s2w(sx, sy);
    
    if(e.button === 2 || e.shiftKey) { // Pan
      input.isPanning = true; input.panStart = {sx, sy, dx:view.dx, dy:view.dy};
      return;
    }

    const nId = getNearNode(w.x, w.y);
    
    if(view.mode === 'draw') {
      if(nId) {
        input.dragNode = getNode(nId);
      } else {
        const newId = addNode(w.x, w.y);
        input.dragNode = getNode(newId);
      }
    } else {
      // Select
      if(nId) {
        input.selNode = nId; input.selMember = null;
        input.dragNode = getNode(nId); // Move
      } else {
        const mId = getNearMember(w.x, w.y);
        if(mId) { input.selMember = mId; input.selNode = null; plotStress(mId); }
      }
      renderUI();
    }
  }

  function onMove(e) {
    const rect = e.target.getBoundingClientRect();
    const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
    input.currMouse = {x:sx, y:sy};
    
    if(input.isPanning) {
      view.dx = input.panStart.dx + (sx - input.panStart.sx);
      view.dy = input.panStart.dy + (sy - input.panStart.sy);
      return;
    }

    const w = s2w(sx, sy);
    input.hoverNode = getNearNode(w.x, w.y);

    if(view.mode === 'select' && input.dragNode) {
      input.dragNode.x = w.x; input.dragNode.y = w.y;
      clearRes();
      renderUI(); // Update list coordinates live
    }
  }

  function onUp(e) {
    if(input.isPanning) { input.isPanning = false; return; }
    
    if(view.mode === 'draw' && input.dragNode) {
      const w = s2w(input.currMouse.x, input.currMouse.y);
      const hitId = getNearNode(w.x, w.y);
      if(hitId && hitId !== input.dragNode.id) {
        addMember(input.dragNode.id, hitId);
      } else if(!hitId) {
        const newId = addNode(w.x, w.y);
        addMember(input.dragNode.id, newId);
      }
      input.dragNode = null;
    }
    
    if(view.mode === 'select') input.dragNode = null;
  }

  function onWheel(e) {
    e.preventDefault();
    const f = e.deltaY > 0 ? 0.9 : 1.1;
    view.scale *= f;
  }

  function onDbl(e) {
    // Edit properties
    if(input.hoverNode) editNodeProps(input.hoverNode);
    else {
      const w = s2w(input.currMouse.x, input.currMouse.y);
      const mId = getNearMember(w.x, w.y);
      if(mId) editMemberProps(mId);
    }
  }

  // --- HELPERS ---
  function getNode(id) { return state.nodes.find(n => n.id === id); }
  function getMember(id) { return state.members.find(m => m.id === id); }
  function getNearNode(x, y) {
    const tol = 10 / view.scale;
    const n = state.nodes.find(n => dist(n.x, n.y, x, y) < tol);
    return n ? n.id : null;
  }
  function getNearMember(x, y) {
    const tol = 5 / view.scale;
    return state.members.find(m => {
      const n1 = getNode(m.n1), n2 = getNode(m.n2);
      // dist to segment logic
      const l2 = dist(n1.x, n1.y, n2.x, n2.y)**2;
      if(l2 === 0) return false;
      let t = ((x-n1.x)*(n2.x-n1.x) + (y-n1.y)*(n2.y-n1.y)) / l2;
      t = Math.max(0, Math.min(1, t));
      const px = n1.x + t*(n2.x-n1.x);
      const py = n1.y + t*(n2.y-n1.y);
      return dist(x,y,px,py) < tol;
    })?.id;
  }

  // --- SOLVER (Matrix Math) ---
  function solveStatic() {
    if(state.nodes.length < 2) return;
    try {
      const dofMap = getDofMap();
      const nDof = Object.keys(dofMap).length * 3;
      const K = numeric.rep([nDof, nDof], 0);
      const F = numeric.rep([nDof], 0);

      // Assemble K
      state.members.forEach(m => {
        const n1 = getNode(m.n1), n2 = getNode(m.n2);
        const L = dist(n1.x, n1.y, n2.x, n2.y);
        const ang = Math.atan2(n2.y-n1.y, n2.x-n1.x);
        const c = Math.cos(ang), s = Math.sin(ang);
        
        const kLoc = localK(m.E, m.A, m.I, L);
        const T = getT(c, s);
        const kGlob = numeric.dot(numeric.dot(numeric.transpose(T), kLoc), T);
        
        const idx = [dofMap[n1.id], dofMap[n1.id]+1, dofMap[n1.id]+2, dofMap[n2.id], dofMap[n2.id]+1, dofMap[n2.id]+2];
        
        for(let i=0; i<6; i++){
          for(let j=0; j<6; j++){
            K[idx[i]][idx[j]] += kGlob[i][j];
          }
        }
      });

      // Loads & BCs
      const constrained = [];
      state.nodes.forEach(n => {
        const i = dofMap[n.id];
        F[i] += n.Fx; F[i+1] += n.Fy; F[i+2] += n.Mz;
        
        // BCs
        if(n.bc === 'fixed') { constrained.push(i, i+1, i+2); }
        if(n.bc === 'simple') { constrained.push(i, i+1); }
        if(n.bc === 'rollerX') { constrained.push(i); } // fix x
        if(n.bc === 'rollerY') { constrained.push(i+1); } // fix y
      });

      const free = [];
      for(let i=0; i<nDof; i++) if(!constrained.includes(i)) free.push(i);
      
      if(free.length === 0) throw new Error("Stable? No (Fully Constrained)");

      // Solve Kff * Uf = Ff
      const Kff = getSubMatrix(K, free, free);
      const Ff = getSubVector(F, free);
      const Uf = numeric.solve(Kff, Ff);
      
      const U = numeric.rep([nDof], 0);
      free.forEach((fi, idx) => U[fi] = Uf[idx]);

      // Calculate Member Forces (for Stress Panel)
      const stress = {};
      state.members.forEach(m => {
        stress[m.id] = calcMemberRes(m, U, dofMap);
      });

      state.results = { U, reactions: {}, stress };
      
      Swal.fire({ icon:'success', title:'Solved', timer:1000, showConfirmButton:false });
      view.show = 'def';
      renderUI();

    } catch(e) {
      Swal.fire('Error', e.message || "Unstable structure", 'error');
    }
  }

  // --- HELPERS FOR SOLVER ---
  function getDofMap(){
    const map = {};
    state.nodes.forEach((n, i) => map[n.id] = i*3);
    return map;
  }
  function localK(E,A,I,L){
    return [
      [E*A/L, 0, 0, -E*A/L, 0, 0],
      [0, 12*E*I/L**3, 6*E*I/L**2, 0, -12*E*I/L**3, 6*E*I/L**2],
      [0, 6*E*I/L**2, 4*E*I/L, 0, -6*E*I/L**2, 2*E*I/L],
      [-E*A/L, 0, 0, E*A/L, 0, 0],
      [0, -12*E*I/L**3, -6*E*I/L**2, 0, 12*E*I/L**3, -6*E*I/L**2],
      [0, 6*E*I/L**2, 2*E*I/L, 0, -6*E*I/L**2, 4*E*I/L]
    ];
  }
  function getT(c,s){
    return [
      [c,s,0,0,0,0], [-s,c,0,0,0,0], [0,0,1,0,0,0],
      [0,0,0,c,s,0], [0,0,0,-s,c,0], [0,0,0,0,0,1]
    ];
  }
  function getSubMatrix(M, rIdx, cIdx){
    return rIdx.map(r => cIdx.map(c => M[r][c]));
  }
  function getSubVector(V, idx){
    return idx.map(i => V[i]);
  }

  function calcMemberRes(m, U, dofMap){
    // Return arrays x[], N[], V[], M[], sigma[]
    // Simplified linear interpolation for end forces
    const i = dofMap[m.n1], j = dofMap[m.n2];
    const u_g = [U[i], U[i+1], U[i+2], U[j], U[j+1], U[j+2]];
    const n1=getNode(m.n1), n2=getNode(m.n2);
    const dx=n2.x-n1.x, dy=n2.y-n1.y, L=Math.hypot(dx,dy);
    const ang=Math.atan2(dy,dx), c=Math.cos(ang), s=Math.sin(ang);
    const T = getT(c,s);
    const u_l = numeric.dot(T, u_g);
    const k_l = localK(m.E, m.A, m.I, L);
    const f_l = numeric.dot(k_l, u_l); // [N1, V1, M1, N2, V2, M2]
    
    const steps = 10;
    const res = { x:[], N:[], V:[], M:[], sigma:[] };
    for(let k=0; k<=steps; k++){
      res.x.push(k/steps * L);
      // N is constant (approx)
      res.N.push(-f_l[0]); 
      // V is constant
      res.V.push(f_l[1]);
      // M linear
      const Mval = f_l[2] - f_l[1]*(k/steps*L); 
      res.M.push(Mval);
      // Sigma = N/A + M*c/I
      res.sigma.push((-f_l[0]/m.A) + (Math.abs(Mval)*5/m.I)); // hardcoded c=5 for now
    }
    return res;
  }

  // --- UI RENDERING ---
  function renderUI() {
    // Nodes List
    const nl = document.getElementById('nodeList');
    nl.innerHTML = state.nodes.map(n => `
      <div class="list-item" onclick="window.editNode(${n.id})">
        <b>N${n.id}</b> (${n.x.toFixed(1)}, ${n.y.toFixed(1)}) <span class="hint">${n.bc}</span>
        <span class="del-btn" onclick="window.delNode(${n.id}, event)">×</span>
      </div>
    `).join('');

    // Members List
    const ml = document.getElementById('memberList');
    ml.innerHTML = state.members.map(m => `
      <div class="list-item" onclick="window.editMember(${m.id})">
        <b>${m.label}</b> (N${m.n1} → N${m.n2})
        <span class="del-btn" onclick="window.delMem(${m.id}, event)">×</span>
      </div>
    `).join('');

    // Results List
    const rl = document.getElementById('resultList');
    if(state.results) {
      rl.innerHTML = state.nodes.map(n => {
        const i = state.results.dofMap[n.id];
        return `<div class="list-item">
          <b>N${n.id}</b> 
          ux:${state.results.U[i].toFixed(4)} 
          uy:${state.results.U[i+1].toFixed(4)}
        </div>`;
      }).join('');
    } else {
      rl.innerHTML = '<div style="padding:10px; color:#999;">No results</div>';
    }
  }

  // --- EXPORT / IMPORT LOGIC (STATEFUL CSV) ---

  function exportCSV() {
    if(state.nodes.length === 0) return;
    const now = new Date();
    
    // Header
    let csv = `Frame Analysis Report\nDate,${now.toLocaleDateString()}\nTime,${now.toLocaleTimeString()}\n\n`;
    
    // SECTION 1: MODEL DEFINITION (Critical for Re-run)
    csv += "[NODES]\nID,X,Y,BC,Fx,Fy,Mz\n";
    state.nodes.forEach(n => {
      csv += `${n.id},${n.x},${n.y},${n.bc},${n.Fx},${n.Fy},${n.Mz}\n`;
    });
    
    csv += "\n[MEMBERS]\nID,N1,N2,E,A,I,Label\n";
    state.members.forEach(m => {
      csv += `${m.id},${m.n1},${m.n2},${m.E},${m.A},${m.I},${m.label}\n`;
    });

    // SECTION 2: RESULTS (Report)
    if(state.results){
      csv += "\n[RESULTS]\nNode,Ux,Uy,Rotation\n";
      state.nodes.forEach(n => {
        const i = state.results.dofMap[n.id];
        csv += `${n.id},${state.results.U[i].toFixed(5)},${state.results.U[i+1].toFixed(5)},${state.results.U[i+2].toFixed(5)}\n`;
      });
    }

    const blob = new Blob([csv], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='frame_model.csv'; a.click();
  }

  function importCSV(text) {
    try {
      const lines = text.split('\n').map(l => l.trim());
      let section = '';
      
      const newNodes = [];
      const newMembers = [];

      lines.forEach(l => {
        if(!l) return;
        if(l.startsWith('[NODES]')) { section = 'nodes'; return; }
        if(l.startsWith('[MEMBERS]')) { section = 'members'; return; }
        if(l.startsWith('[')) { section = ''; return; } // Skip results or metadata
        
        const p = l.split(',');
        if(p.length < 2 || isNaN(parseFloat(p[0]))) return; // Skip headers

        if(section === 'nodes'){
          newNodes.push({
            id: parseInt(p[0]), x: parseFloat(p[1]), y: parseFloat(p[2]),
            bc: p[3], Fx: parseFloat(p[4]), Fy: parseFloat(p[5]), Mz: parseFloat(p[6])
          });
        }
        if(section === 'members'){
          newMembers.push({
            id: parseInt(p[0]), n1: parseInt(p[1]), n2: parseInt(p[2]),
            E: parseFloat(p[3]), A: parseFloat(p[4]), I: parseFloat(p[5]), label: p[6]
          });
        }
      });

      if(newNodes.length > 0) {
        state.nodes = newNodes;
        state.members = newMembers;
        state.nextN = Math.max(...newNodes.map(n=>n.id)) + 1;
        state.nextM = Math.max(...newMembers.map(m=>m.id)) + 1;
        clearRes();
        renderUI();
        fitCanvas(); // Recenter view
        Swal.fire('Imported', 'Model rebuilt from CSV.', 'success');
      }
    } catch(e) {
      Swal.fire('Error', 'Invalid CSV format', 'error');
    }
  }

  // --- PLOT STRESS ---
  function plotStress(mid){
    if(!state.results) return;
    const res = state.results.stress[mid];
    if(!res) return;
    const canvas = stressCanvas;
    const c = spx;
    c.clearRect(0,0,canvas.width, canvas.height);
    
    // Background
    c.fillStyle = '#f8fafc'; c.fillRect(0,0,canvas.width,canvas.height);
    
    // Draw Graph
    c.strokeStyle = '#2563eb'; c.lineWidth = 2;
    c.beginPath();
    
    const data = res.M; // Default to Moment
    const max = Math.max(...data.map(Math.abs)) || 1;
    const h = canvas.height, w = canvas.width;
    
    for(let i=0; i<data.length; i++){
      const x = (i/(data.length-1)) * w;
      const y = h/2 - (data[i]/max) * (h/2 - 20);
      if(i===0) c.moveTo(x,y); else c.lineTo(x,y);
    }
    c.stroke();
    
    // Zero line
    c.strokeStyle = '#ccc'; c.lineWidth=1;
    c.beginPath(); c.moveTo(0, h/2); c.lineTo(w, h/2); c.stroke();
    
    // Labels
    c.fillStyle = '#000';
    c.fillText(`Member ${mid} - Moment Diagram`, 10, 20);
    c.fillText(`Max: ${max.toFixed(2)}`, 10, h-10);
    
    document.getElementById('stressWrap').style.display = 'flex';
  }

  // --- BUTTON BINDINGS ---
  document.getElementById('btnDraw').onclick = () => { view.mode='draw'; updateBtns(); };
  document.getElementById('btnSelect').onclick = () => { view.mode='select'; updateBtns(); };
  
  function updateBtns(){
    document.getElementById('btnDraw').className = view.mode==='draw'?'primary active':'ghost';
    document.getElementById('btnSelect').className = view.mode==='select'?'primary active':'ghost';
  }

  document.getElementById('btnClear').onclick = () => {
    state.nodes = []; state.members = [];
    clearRes(); renderUI();
  };

  document.getElementById('btnSolve').onclick = solveStatic;

  // IO Bindings
  document.getElementById('btnExportJSON').onclick = () => {
    const blob = new Blob([JSON.stringify(state)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='frame_data.json'; a.click();
  };
  
  const fIn = document.getElementById('fileInput');
  document.getElementById('btnImportJSON').onclick = () => { fIn.accept='.json'; fIn.click(); };
  document.getElementById('btnImportCSV').onclick = () => { fIn.accept='.csv'; fIn.click(); };
  
  fIn.onchange = (e) => {
    const f = e.target.files[0];
    const r = new FileReader();
    r.onload = (evt) => {
      if(f.name.endsWith('.csv')) importCSV(evt.target.result);
      else {
        const d = JSON.parse(evt.target.result);
        state.nodes=d.nodes; state.members=d.members;
        clearRes(); renderUI();
      }
    };
    r.readAsText(f);
  };

  document.getElementById('btnExportCSV').onclick = exportCSV;

  // Window Exposure for inline clicks
  window.editNode = (id) => {
    const n = getNode(id);
    Swal.fire({
      title: `Edit Node ${id}`,
      html: `<div class="prop-grid">
        <label>X</label><input id="ex" type="number" value="${n.x}">
        <label>Y</label><input id="ey" type="number" value="${n.y}">
        <label>BC</label><select id="ebc">
          <option value="free" ${n.bc==='free'?'selected':''}>Free</option>
          <option value="fixed" ${n.bc==='fixed'?'selected':''}>Fixed</option>
          <option value="simple" ${n.bc==='simple'?'selected':''}>Pinned</option>
        </select>
        <label>Load Y</label><input id="efy" type="number" value="${n.Fy}">
      </div>`,
      preConfirm: () => {
        n.x=parseFloat(document.getElementById('ex').value);
        n.y=parseFloat(document.getElementById('ey').value);
        n.bc=document.getElementById('ebc').value;
        n.Fy=parseFloat(document.getElementById('efy').value);
        renderUI();
      }
    });
  };
  
  window.editMember = (id) => {
    const m = getMember(id);
    Swal.fire({
      title: `Edit Member ${id}`,
      html: `<div class="prop-grid">
        <label>E (Modulus)</label><input id="me" type="number" value="${m.E}">
        <label>I (Inertia)</label><input id="mi" type="number" value="${m.I}">
        <label>A (Area)</label><input id="ma" type="number" value="${m.A}">
      </div>`,
      preConfirm: () => {
        m.E=parseFloat(document.getElementById('me').value);
        m.I=parseFloat(document.getElementById('mi').value);
        m.A=parseFloat(document.getElementById('ma').value);
      }
    });
  };

  window.delNode = (id, e) => { e.stopPropagation(); deleteNode(id); };
  window.delMem = (id, e) => { e.stopPropagation(); deleteMember(id); };
  document.getElementById('closeStress').onclick = () => document.getElementById('stressWrap').style.display='none';

  // Run
  init();

})();
</script>
</body>
</html>

