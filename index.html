<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Base Shake ‚Äî UI + View</title>
  <style>
    :root{
      --panel-w:320px; --panel-h:590px;
      --ink:#111; --muted:#666; --accent:#0b73c8; --border:#d9d9d9; --panel:#f7f7f7;
      --radius:14px; --gap:12px; --pad:14px; --input-h:38px; --seg-h:48px;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    body{margin:0;background:#f3f4f6;color:var(--ink)}

    /* === Layout fix === */
    .wrap{
      display:flex;
      align-items:flex-start;
      justify-content:flex-start;
      gap:18px;
      flex-wrap:nowrap;
      overflow-x:auto;
      padding:16px;
    }
    .panel{
      width:var(--panel-w);
      min-width:var(--panel-w);
      height:var(--panel-h);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:var(--pad);
      box-shadow:0 6px 24px rgba(0,0,0,.06);
      display:flex;
      flex-direction:column;
      flex-shrink:0;
    }
    .wrap > div:not(.panel){
      flex:1 1 560px;
      min-width:560px;
    }

    h2{margin:0 0 18px;font-size:18px;}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:var(--gap);} 
    .row{display:contents;} 
    label{font-size:12px;color:var(--muted);display:block;margin-bottom:10px}
    .input, .seg{border:1px solid var(--border);border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;padding:0 10px}
    .input{height:var(--input-h)}
    .input input, .input select{width:100%;height:100%;border:0;outline:0;background:transparent;font-size:14px;color:var(--ink)}
    .input.readonly{background:#f0f2f5}
    .input.readonly input{color:#666;pointer-events:none}
    .seg{height:var(--seg-h);padding:2px;gap:2px}
    .seg button{flex:1 1 0;border:0;height:100%;border-radius:8px;background:transparent;font-size:14px;cursor:pointer;line-height:1.2;}
    .seg button.active{background:var(--accent);color:#fff}
    .seg button:not(.active):hover{background:#eef6ff}
    .colspan-2{grid-column:1 / span 2}
    .btn{border:1px solid var(--border);background:#fff;border-radius:10px;height:40px;cursor:pointer;width:100%;font-size:14px}
    .btn.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
    .btn.primary:hover{filter:brightness(1.05)}
    .btn.sm{height:32px;padding:0 10px;border-radius:8px}
    .btnbar{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .dropdown{border:1px solid var(--border);border-radius:10px;background:#fff;padding:10px;margin-top:10px}

    #view{width:500px;height:400px;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06)}
    .toolbar{display:flex;align-items:center;gap:6px;flex-start;margin-bottom:6px}
    .toolbar button{border:1px solid var(--border);background:#fff;border-radius:8px;padding:4px 8px;cursor:pointer}
    .toolbar label{font:12px system-ui;color:#444}

    .exportbar{display:flex;gap:8px;justify-content:flex-end;margin:10px 0 0 0}
    .readout{font:12px system-ui;color:#333;margin:4px 0 0 0}

    .toast{position:fixed;left:16px;bottom:16px;max-width:60ch;background:#111;color:#fff;padding:10px 12px;border-radius:10px;box-shadow:0 6px 24px rgba(0,0,0,.2);opacity:0;transform:translateY(8px);transition:opacity .2s ease, transform .2s ease;pointer-events:none;font:13px system-ui}
    .toast.show{opacity:0.95;transform:translateY(0)}
  
    #exportBtns{
      display:flex;
      gap:8px;
      margin-top:8px;
      margin-bottom:16px;
    }
    #exportBtns .btn{ width:120px; }

    #view, #accelPlot, #springPlot{
      max-width:100%;
      height:auto;
    }

    @media (max-width:980px){
      .wrap{ flex-wrap:wrap; }
      .wrap > div:not(.panel){
        min-width:100%;
        flex-basis:100%;
      }
    }
  </style>
</head>




<body>
  <div class="wrap">
    <div class="panel" role="region" aria-label="Base Shake control panel">
      <h2>Base Shake</h2>
      <div class="grid">
        <div class="row">
          <div>
            <label for="units">Units</label>
            <div id="units" class="seg">
              <button id="u-us" class="active">US<br><small>(in, lb, s)</small></button>
              <button id="u-si">SI<br><small>(m, N, s)</small></button>
            </div>
          </div>
          <div>
            <label for="gval">Gravity, G</label>
            <div class="input readonly"><input id="gval" type="text" value="386.09 in/s¬≤" readonly /></div>
          </div>
        </div>
        <div class="row">
          <div><label for="weight">Weight</label><div class="input"><input id="weight" type="number" value="100" /></div></div>
          <div><label for="mass">Mass</label><div class="input readonly"><input id="mass" type="text" readonly /></div></div>
        </div>
        <div class="row">
          <div><label for="lx">Lx (width)</label><div class="input"><input id="lx" type="number" value="12" /></div></div>
          <div><label for="ly">Ly (length)</label><div class="input"><input id="ly" type="number" value="6" /></div></div>
        </div>
        <div class="row">
          <div><label for="lz">Lz (height)</label><div class="input"><input id="lz" type="number" value="3" /></div></div>
        </div>
        <div class="row">
          <div><label for="k00">Spring k (0,0)</label><div class="input"><input id="k00" type="number" value="100" /></div></div>
          <div><label for="kLx0">Spring k (Lx,0)</label><div class="input"><input id="kLx0" type="number" value="200" /></div></div>
        </div>
        <div class="row">
          <div><label for="k0Ly">Spring k (0,Ly)</label><div class="input"><input id="k0Ly" type="number" value="300" /></div></div>
          <div><label for="kLxLy">Spring k (Lx,Ly)</label><div class="input"><input id="kLxLy" type="number" value="400" /></div></div>
        </div>
        <div class="row">
          <div><label for="damping">Critical damping, %</label><div class="input"><input id="damping" type="number" value="10" /></div></div>
        </div>

        <!-- Shock Load section -->
        <div class="colspan-2">
          <div class="btnbar">
            <button id="shockToggle" class="btn">Shock Load ‚ñæ</button>
            <button id="simulateBtn" class="btn primary">Simulate</button>
          </div>
          <div id="shockPanel" class="dropdown" hidden>
            <div class="grid" style="grid-template-columns:1fr 1fr; gap:12px;">
              <div>
                <label for="shockAmp">Base accel amplitude, G</label>
                <div class="input"><input id="shockAmp" type="number" step="any" value="10"/></div>
              </div>
              <div>
                <label for="shockTime">Time Pulse, s</label>
                <div class="input"><input id="shockTime" type="number" step="any" value="0.1"/></div>
              </div>
              <div class="colspan-2">
                <label for="shockWave">Waveform</label>
                <div class="input">
                  <select id="shockWave">
                    <option value="half-sine">1/2 Sine</option>
                    <option value="triangular">Triangular</option>
                    <option value="sawtooth">Sawtooth</option>
                    <option value="rectangular">Rectangular</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- /Shock Load section -->
      </div>

      <!-- Max acceleration readout (new) -->
      <div id="maxAccelPanel" class="dropdown" style="margin-top:10px; padding:10px;">
        <div style="font-weight:600; margin-bottom:6px;">Max |Acceleration| (G)</div>
        <div id="maxCenter" class="readout">Center: ‚Äî</div>
        <div id="maxC00" class="readout">(0,0): ‚Äî</div>
        <div id="maxCLx0" class="readout">(Lx,0): ‚Äî</div>
        <div id="maxC0Ly" class="readout">(0,Ly): ‚Äî</div>
        <div id="maxCLxLy" class="readout">(Lx,Ly): ‚Äî</div>
      </div>
      <!-- /Max acceleration readout -->
    </div>

    <div>
      <div class="toolbar">
        <label for="respScale">Response scale</label>
        <input id="respScale" type="range" min="0" max="10" step="0.1" value="1" style="width:125px;">
        <label for="simSpeed">Speed</label>
        <input id="simSpeed" type="range" min="0" max="4" step="0.05" value="1" style="width:125px;">
        <button id="resetView">Reset View</button>
      </div>
      
<div id="exportBtns">
  <button id="exportJSON" class="btn sm">Export JSON</button>
  <button id="importJSON" class="btn sm">Import JSON</button>
  <button id="exportCSV" class="btn sm">Export CSV</button>
</div>

      <!-- Main animation -->
      <canvas id="view" width="500" height="400"></canvas>

      <!-- Plots -->
      <div id="plots" style="margin-top:12px; display:grid; grid-template-columns:1fr; gap:12px; width:500px;">
        <canvas id="accelPlot" width="500" height="220" style="background:#fff;border:1px solid #d9d9d9;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06)"></canvas>
        <canvas id="springPlot" width="500" height="220" style="background:#fff;border:1px solid #d9d9d9;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06)"></canvas>
        <div id="readout" class="readout"></div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
  (function(){
    // ===== DOM refs =====
    const lx=document.getElementById('lx'), ly=document.getElementById('ly'), lz=document.getElementById('lz');
    const k00=document.getElementById('k00'), kLx0=document.getElementById('kLx0'), k0Ly=document.getElementById('k0Ly'), kLxLy=document.getElementById('kLxLy');
    const canvas=document.getElementById('view'); const ctx=canvas.getContext('2d');
    const resetBtn=document.getElementById('resetView');
    const simSpeed=document.getElementById('simSpeed');
    const respScaleEl=document.getElementById('respScale');

    // Plot contexts
    const accelPlot = document.getElementById('accelPlot');
    const springPlot = document.getElementById('springPlot');
    const accelPlotCtx = accelPlot.getContext('2d');
    const springPlotCtx = springPlot.getContext('2d');

const exportJSONBtn = document.getElementById('exportJSON');
const importJSONBtn = document.getElementById('importJSON');
const exportCSVBtn  = document.getElementById('exportCSV');
const readoutEl = document.getElementById('readout');



    // New: max-accel readout refs
    const maxCenterEl = document.getElementById('maxCenter');
    const maxC00El    = document.getElementById('maxC00');
    const maxCLx0El   = document.getElementById('maxCLx0');
    const maxC0LyEl   = document.getElementById('maxC0Ly');
    const maxCLxLyEl  = document.getElementById('maxCLxLy');

    const usBtn=document.getElementById('u-us'); const siBtn=document.getElementById('u-si');
    const gEl=document.getElementById('gval'); const weightEl=document.getElementById('weight'); const massEl=document.getElementById('mass');

    // Shock controls
    const shockToggle=document.getElementById('shockToggle');
    const shockPanel=document.getElementById('shockPanel');
    const shockAmp=document.getElementById('shockAmp');
    const shockTime=document.getElementById('shockTime');
    const shockWave=document.getElementById('shockWave');
    const simulateBtn=document.getElementById('simulateBtn');

    // Toast helper
    const toastEl=document.getElementById('toast');
    let toastTimer=null;
    function showToast(msg){
      toastEl.textContent=msg; toastEl.classList.add('show');
      clearTimeout(toastTimer); toastTimer=setTimeout(()=>toastEl.classList.remove('show'), 2000);
    }

    // ===== Units & mass =====
    let unitMode='US';
    const g=()=> unitMode==='US' ? 386.09 : 9.80665;
    function computeMass(){ const W=parseFloat(weightEl.value); massEl.value = Number.isFinite(W) ? Number((W/g()).toPrecision(6)).toString() : ''; }
    function setUnits(mode){ unitMode=mode; if(mode==='US'){ usBtn.classList.add('active'); siBtn.classList.remove('active'); gEl.value='386.09 in/s¬≤'; } else { siBtn.classList.add('active'); usBtn.classList.remove('active'); gEl.value='9.80665 m/s¬≤'; } computeMass(); draw(); }
    usBtn.addEventListener('click',()=>setUnits('US'));
    siBtn.addEventListener('click',()=>setUnits('SI'));
    weightEl.addEventListener('input',computeMass);

    shockToggle.addEventListener('click',()=>{
      const open = !shockPanel.hasAttribute('hidden');
      if(open){ shockPanel.setAttribute('hidden',''); shockToggle.textContent='Shock Load ‚ñæ'; }
      else { shockPanel.removeAttribute('hidden'); shockToggle.textContent='Shock Load ‚ñ¥'; }
    });

    // ===== Camera / transforms =====
    let yaw=0.8, pitch=-1.0; let baseScale=30, zoom=1.5, scale=30; let panX=-100, panY=125;
    function vals(){
      return { Lx:parseFloat(lx.value)||12, Ly:parseFloat(ly.value)||6, Lz:parseFloat(lz.value)||3,
        K:[parseFloat(k00.value)||100, parseFloat(kLx0.value)||200, parseFloat(k0Ly.value)||300, parseFloat(kLxLy.value)||400] };
    }
    function fitScale(){
      const {Lx,Ly,Lz}=vals();
      const maxDim=Math.max(Lx,Ly,Lz,1);
      baseScale=Math.min(canvas.width,canvas.height)*0.375/maxDim;
      scale=baseScale*zoom;
    }
    function project([x,y,z]){
      const cz=Math.cos(yaw), sz=Math.sin(yaw); let nx=x*cz-y*sz, ny=x*sz+y*cz, nz=z;
      const cx=Math.cos(pitch), sx=Math.sin(pitch); let ny2=ny*cx-nz*sx;
      const px=canvas.width*0.5 + panX + scale*nx;
      const py=canvas.height*0.5 + panY - scale*ny2;
      return [px,py];
    }
    function kStroke(K,val){ const pos=K.filter(v=>v>0); if(!pos.length) return 2; const kmin=Math.min(...pos), kmax=Math.max(...pos); if(kmax===kmin) return 4; const t=(val-kmin)/(kmax-kmin); return 1+2*t; }

    // ===== Graphics helpers =====
    function drawSpringSymbol(x,y,z0,z1,stroke,color,Lz){
      ctx.strokeStyle=color; ctx.lineWidth=stroke; ctx.lineCap='round';
      const pA=project([x,y,z0]), pB=project([x,y,z1]); ctx.beginPath(); ctx.moveTo(pA[0],pA[1]); ctx.lineTo(pB[0],pB[1]); ctx.stroke();
      const ticks=3, startT=0.25, endT=0.65, len=0.20*Lz;
      for(let i=0;i<ticks;i++){
        const t=startT+(endT-startT)*i/(ticks-1), z=z0+(z1-z0)*t;
        const p1=project([x-0.5*len,y,z]), p2=project([x+0.5*len,y,z]);
        ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke();
      }
      ctx.fillStyle=color; const pb=project([x,y,z0]); ctx.beginPath(); ctx.arc(pb[0],pb[1],Math.max(3,stroke*0.6),0,Math.PI*2); ctx.fill();
    }

    function drawAxes(){
      const origin=[60,60], L=45;
      function rot([x,y,z]){ const cz=Math.cos(yaw), sz=Math.sin(yaw); let nx=x*cz-y*sz, ny=x*sz+y*cz, nz=z; const cx=Math.cos(pitch), sx=Math.sin(pitch); let ny2=ny*cx-nz*sx; return [nx,-ny2]; }
      const axes={X:rot([1,0,0]), Y:rot([0,1,0]), Z:rot([0,0,1])};
      ctx.lineWidth=2; ctx.lineCap='round'; const colors={X:'#ef4444',Y:'#16a34a',Z:'#0b73c8'};
      for(const k of ['X','Y','Z']){
        const v=axes[k]; ctx.strokeStyle=colors[k]; ctx.beginPath(); ctx.moveTo(origin[0],origin[1]); ctx.lineTo(origin[0]+v[0]*L,origin[1]+v[1]*L); ctx.stroke();
        ctx.fillStyle=colors[k]; ctx.font='12px system-ui'; ctx.fillText(k,origin[0]+v[0]*L+4,origin[1]+v[1]*L+4);
      }
    }

    function drawBaseBox(Lx,Ly,Lz){
      // Relative-motion view: base fixed at z=0
      const z0=0, z1=-0.25*Lz;
      const V=[[0,0,z0],[Lx,0,z0],[Lx,Ly,z0],[0,Ly,z0],[0,0,z1],[Lx,0,z1],[Lx,Ly,z1],[0,Ly,z1]];
      const faces=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]];
      ctx.fillStyle='rgba(0,0,0,0.75)';
      faces.forEach(f=>{ ctx.beginPath(); const p0=project(V[f[0]]); ctx.moveTo(p0[0],p0[1]); for(let i=1;i<f.length;i++){ const p=project(V[f[i]]); ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill(); });
      const E=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.lineJoin='round';
      E.forEach(([a,b])=>{ const p1=project(V[a]), p2=project(V[b]); ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); });
    }

    // ===== Waveform + frequencies =====
    function computeFrequencies(){
      const W=parseFloat(weightEl.value);
      const m = (Number.isFinite(W)? W/g() : 0);
      const {Lx,Ly,Lz,K}=vals();
      const sumK = K.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
      const fz = sumK>0 && m>0 ? (Math.sqrt(sumK/m)/(2*Math.PI)) : 0;
      const yh = Ly/2, xh = Lx/2;
      const Kth_x = (K[0]*Math.pow(-yh,2)) + (K[1]*Math.pow(-yh,2)) + (K[2]*Math.pow(yh,2)) + (K[3]*Math.pow(yh,2));
      const Kth_y = (K[0]*Math.pow(-xh,2)) + (K[1]*Math.pow(xh,2)) + (K[2]*Math.pow(-xh,2)) + (K[3]*Math.pow(xh,2));
      const Ix = (m/12) * (Ly*Ly + Lz*Lz);
      const Iy = (m/12) * (Lx*Lx + Lz*Lz);
      const f_roll_x = (Kth_x>0 && Ix>0) ? (Math.sqrt(Kth_x/Ix)/(2*Math.PI)) : 0;
      const f_pitch_y= (Kth_y>0 && Iy>0) ? (Math.sqrt(Kth_y/Iy)/(2*Math.PI)) : 0;
      return {fz, f_roll_x, f_pitch_y};
    }

function sampleWaveform(A, T, kind){
  const N = 20;                    // was 10
  const t = [];
  const y = [];
  for (let i = 0; i <= N; i++){
    const ti = T * (i / N);
    t.push(ti);
    let v = 0;
    if (T > 0){
      switch (kind){
        case 'half-sine':
          v = A * Math.sin(Math.PI * ti / T);
          break;
        case 'triangular': {
          const half = T / 2;
          v = ti <= half ? (A * (ti / half)) : (A * (1 - (ti - half) / half));
          break;
        }
        case 'sawtooth':
          v = A * (ti / T);
          break;
        case 'rectangular':
          // draw as a true step: high at t=0, drop right at t=T
          v = (ti >= 0 && ti < T) ? A : 0;
          break;
        default:
          v = 0;
      }
    }
    y.push(v);
  }
  return { t, y };
}

    function drawWaveformPanel(){
      const pad=12, w=200, h=150; const x0=canvas.width - w - pad, y0=pad;
      ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.strokeStyle='#bbb'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.rect(x0,y0,w,h); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.fillText("Shock Pulse: A(G) vs t(s)", x0+10, y0+18);

      const A = parseFloat(shockAmp.value)||0; const T = parseFloat(shockTime.value)||0; const kind = shockWave.value;
      const {t,y} = sampleWaveform(A,T,kind);

      const gx=x0+36, gy=y0+28, gw=w-46, gh=h-92;
      ctx.strokeStyle='#ddd'; ctx.strokeRect(gx,gy,gw,gh);

      const tmin=0, tmax = T>0?T:1; const ymin=0, ymax=Math.max(1, ...y);

      ctx.fillStyle='#444'; ctx.textAlign='right'; ctx.textBaseline='alphabetic';
      ctx.fillText(tmax.toPrecision(3), gx+gw-2, gy+gh+14);
      ctx.textAlign='left'; ctx.fillText("t (s)", gx+gw-74, gy+gh+14);

      ctx.save(); ctx.translate(gx-22, gy+58); ctx.rotate(-Math.PI/2); ctx.textAlign='left'; ctx.textBaseline='alphabetic'; ctx.fillText("A (G)", 0,0); ctx.restore();
      ctx.textAlign='right'; ctx.textBaseline='top'; ctx.fillText(ymax.toPrecision(3), gx-6, gy-2);

      ctx.beginPath();
      for(let i=0;i<t.length;i++){
        const px = gx + (t[i]-tmin)/(tmax-tmin)*gw;
        const py = gy + gh - (y[i]-ymin)/(ymax-ymin||1)*gh;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.strokeStyle='#0b73c8'; ctx.lineWidth=2; ctx.stroke();

      ctx.strokeStyle='#ccc'; ctx.lineWidth=1; 
      for(let i=0;i<=5;i++){ const px=gx + i/5*gw; ctx.beginPath(); ctx.moveTo(px,gy+gh); ctx.lineTo(px,gy+gh+4); ctx.stroke(); }
      for(let i=0;i<=4;i++){ const py=gy + gh - i/4*gh; ctx.beginPath(); ctx.moveTo(gx-4,py); ctx.lineTo(gx,py); ctx.stroke(); }

      const {fz,f_roll_x,f_pitch_y}=computeFrequencies();
      const fmt=f=> (f>0? Number(f.toPrecision(4)).toString() : '‚Äî');
      const infoTop = y0 + h - 42; ctx.fillStyle='#111';
      ctx.fillText(`fz (vertical): ${fmt(fz)} Hz`, gx+100, infoTop);
      ctx.fillText(`fxx roll: ${fmt(f_roll_x)} Hz`, gx+100, infoTop + 14);
      ctx.fillText(`fyy pitch: ${fmt(f_pitch_y)} Hz`, gx+100, infoTop + 28);
    }

    // ======= Dynamics/helpers =======
    function cornersAboutCOM(Lx, Ly){ const hx=Lx/2, hy=Ly/2; return [[-hx,-hy],[hx,-hy],[-hx,hy],[hx,hy]]; }

    // RKF45 (robust)
    function rkf45Integrate(f, t0, y0, tEnd, dtInit = 0.0001, rtol = .5e-5, atol = 1e-8) {
      const a2=1/5,a3=3/10,a4=3/5,a5=1,a6=7/8;
      const b21=1/5; const b31=3/40,b32=9/40; const b41=3/10,b42=-9/10,b43=6/5;
      const b51=-11/54,b52=5/2,b53=-70/27,b54=35/27;
      const b61=1631/55296,b62=175/512,b63=575/13824,b64=44275/110592,b65=253/4096;
      const c1=37/378,c3=250/621,c4=125/594,c6=512/1771;
      const c1s=2825/27648,c3s=18575/48384,c4s=13525/55296,c5s=277/14336,c6s=1/4;

      const n = y0.length;
      let t = t0, y = Float64Array.from(y0);
      let h = Math.max(1e-6, Math.min(dtInit, Math.max(1e-6, tEnd - t0)));
      const hMin = 1e-8;
      const outT = [t], outY = [Array.from(y)];
      let rejectStreak = 0, steps = 0;
      const MAX_STEPS = 400000, MAX_REJECT_STREAK = 500;

      function add(a,b){ const r=new Float64Array(a.length); for(let i=0;i<a.length;i++) r[i]=a[i]+b[i]; return r; }
      function scaleVec(a,s){ const r=new Float64Array(a.length); for(let i=0;i<a.length;i++) r[i]=a[i]*s; return r; }
      function scaledErr(y5,y4,yCur){
        let s=0;
        for(let i=0;i<n;i++){
          const denom = atol + rtol * Math.max(Math.abs(yCur[i]), Math.abs(y5[i]));
          const d = (y5[i] - y4[i]) / (denom || 1e-16);
          if (!Number.isFinite(d)) return Number.POSITIVE_INFINITY;
          s += d*d;
        }
        return Math.sqrt(s / n);
      }

      while (t < tEnd) {
        if (++steps > MAX_STEPS) break;
        if (t + h > tEnd) h = tEnd - t;

        const k1=f(t,y);
        const k2=f(t+a2*h, add(y, scaleVec(k1,h*b21)));
        const k3=f(t+a3*h, add(y, add(scaleVec(k1,h*b31), scaleVec(k2,h*b32))));
        const k4=f(t+a4*h, add(y, add(add(scaleVec(k1,h*b41), scaleVec(k2,h*b42)), scaleVec(k3,h*b43))));
        const k5=f(t+a5*h, add(y, add(add(add(scaleVec(k1,h*b51), scaleVec(k2,h*b52)), scaleVec(k3,h*b53)), scaleVec(k4,h*b54))));
        const k6=f(t+a6*h, add(y, add(add(add(add(scaleVec(k1,h*b61), scaleVec(k2,h*b62)), scaleVec(k3,h*b63)), scaleVec(k4,h*b64)), scaleVec(k5,h*b65))));

        const y5=add(y, add(add(add(scaleVec(k1,h*c1), scaleVec(k3,h*c3)), scaleVec(k4,h*c4)), scaleVec(k6,h*c6)));
        const y4=add(y, add(add(add(add(scaleVec(k1,h*c1s), scaleVec(k3,h*c3s)), scaleVec(k4,h*c4s)), scaleVec(k5,h*c5s)), scaleVec(k6,h*c6s)));

        let err = scaledErr(y5,y4,y);
        if (!Number.isFinite(err)) err = Number.POSITIVE_INFINITY;

        if (err <= 1){
          t += h; y = y5; outT.push(t); outY.push(Array.from(y)); rejectStreak = 0;
          let s = 0.9 * Math.pow(1/Math.max(err,1e-12), 0.2);
          s = Math.min(5, Math.max(0.2, s)); h = Math.max(hMin, h*s);
        } else {
          rejectStreak++;
          let s = 0.9 * Math.pow(1/Math.max(err,1e-12), 0.2);
          s = Math.min(1, Math.max(0.1, s)); h = Math.max(hMin, h*s);
          if (h <= hMin + 1e-16 && rejectStreak >= MAX_REJECT_STREAK){
            t += h; y = y5; outT.push(t); outY.push(Array.from(y)); rejectStreak = 0;
          }
        }
      }
      return { t: outT, y: outY };
    }

    // Base acceleration (in G)
    function aBaseG_of_t(t){
      const A = Math.max(-1e3, Math.min(1e3, +shockAmp.value || 0));   // cap to ¬±1000 G
      const T = Math.max(1e-6, +shockTime.value || 0);                  // min pulse width
      const kind = shockWave.value;
      if (t<0||t>T) return 0;
      switch(kind){
        case 'half-sine': return A*Math.sin(Math.PI*t/T);
        case 'triangular': {const h=T/2; return t<=h? A*(t/h): A*(1-(t-h)/h);}
        case 'sawtooth':  return A*(t/T);
        case 'rectangular': return A;
        default: return 0;
      }
    }

    // Dynamics with base spring-to-ground (kGround=0.1*avgK)
    function makeDynamics(){
      const W=parseFloat(weightEl.value)||0; const mTop=W/g();
      const {Lx,Ly,Lz,K}=vals(); const [k00v,kLx0v,k0Lyv,kLxLyv]=K; const mBase=100*mTop;
      const Ix=(mTop/12)*(Ly*Ly+Lz*Lz); const Iy=(mTop/12)*(Lx*Lx+Lz*Lz);

      const zeta=((parseFloat(document.getElementById('damping').value)||0)/100);
      const m_eq=mTop/4; 
      const c00=2*zeta*Math.sqrt(Math.max(k00v,0)*m_eq);
      const cLx0=2*zeta*Math.sqrt(Math.max(kLx0v,0)*m_eq);
      const c0Ly=2*zeta*Math.sqrt(Math.max(k0Lyv,0)*m_eq);
      const cLxLy=2*zeta*Math.sqrt(Math.max(kLxLyv,0)*m_eq);
      const Cspr=[c00,cLx0,c0Ly,cLxLy];
      const kList=[k00v,kLx0v,k0Lyv,kLxLyv];
      const corners=cornersAboutCOM(Lx,Ly);

      const kAvg=(k00v+kLx0v+k0Lyv+kLxLyv)/4;
      const kGround=0.1*kAvg;
      const cGround=2*zeta*Math.sqrt(Math.max(kGround,0)*mBase);

      // y = [ z, thx, thy, vz, wx, wy, zb, vb ]
      return function f(t,y){
        const z=y[0], thx=y[1], thy=y[2], vz=y[3], wx=y[4], wy=y[5], zb=y[6], vb=y[7];

        const dispTop=new Array(4), velTop=new Array(4);
        for(let i=0;i<4;i++){
          const xi=corners[i][0], yi=corners[i][1];
          dispTop[i]= z + (-thx*yi) + (thy*xi);
          velTop[i] = vz + (-wx *yi) + (wy *xi);
        }

        // base input acceleration (model units)
        const ab=aBaseG_of_t(t)*g();

        // forces ON TOP (oppose relative motion)
        const Fi=new Array(4);
        for(let i=0;i<4;i++){
          const rel=dispTop[i]-zb;
          const relv=velTop[i]-vb;
          Fi[i]= -(kList[i]*rel + Cspr[i]*relv);
        }

        let Fz=0, TauX=0, TauY=0;
        for(let i=0;i<4;i++){
          const xi=corners[i][0], yi=corners[i][1], F=Fi[i];
          Fz+=F; TauX+=(-yi)*F; TauY+=(xi)*F;
        }

        const az  = (mTop > 0) ? (Fz / mTop) : 0;
        const awx = (Ix   > 0) ? (TauX / Ix) : 0;
        const awy = (Iy   > 0) ? (TauY / Iy) : 0;

        // Base‚Üîground
        const Fg  = -kGround * zb - cGround * vb;
        const dzb = vb;
        const dvb = (mBase > 0) ? (ab + (-Fz + Fg) / mBase) : ab;

        return new Float64Array([ vz, wx, wy,  az, awx, awy,  dzb, dvb ]);
      };
    }

    function lowestNaturalPeriod(){
      const {fz,f_roll_x,f_pitch_y}=computeFrequencies();
      const arr=[fz,f_roll_x,f_pitch_y].filter(v=>v>0);
      const fmin= (arr.length? Math.min(...arr): 0.1);
      return 1/Math.max(1e-6,fmin);
    }

    function interpSeries(ts,ys,t){
      const n=ts.length; if(t<=ts[0]) return ys[0]; if(t>=ts[n-1]) return ys[n-1];
      let lo=0,hi=n-1; while(hi-lo>1){ const mid=(lo+hi)>>1; if(ts[mid]<=t) lo=mid; else hi=mid; }
      const t0=ts[lo], t1=ts[hi], a=(t-t0)/(t1-t0||1); const y0=ys[lo], y1=ys[hi]; const y=new Array(y0.length);
      for(let i=0;i<y.length;i++) y[i]= y0[i] + a*(y1[i]-y0[i]);
      return y;
    }

    // ===== Draw helpers =====
    function drawTopRigid(zRel,thx,thy,Lx,Ly,Lz,scaleGain){
      const z = zRel * scaleGain;
      const thxV = thx * scaleGain;
      const thyV = thy * scaleGain;

      const Vlocal=[[0,0,0],[Lx,0,0],[Lx,Ly,0],[0,Ly,0],[0,0,Lz],[Lx,0,Lz],[Lx,Ly,Lz],[0,Ly,Lz]];
      const cx=Lx/2, cy=Ly/2; const cY=Math.cos(thyV), sY=Math.sin(thyV); const cX=Math.cos(thxV), sX=Math.sin(thxV);
      function rotV([x,y,z0]){ let X=x-cx, Y=y-cy, Z=z0; let X1= X*cY + Z*sY; let Y1= Y; let Z1=-X*sY + Z*cY; let X2= X1; let Y2= Y1*cX - Z1*sX; let Z2= Y1*sX + Z1*cX; return [X2+cx, Y2+cy, Z2+z]; }
      const V=Vlocal.map(rotV);
      const faces=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]];
      ctx.fillStyle='rgba(200,200,200,0.5)';
      faces.forEach(f=>{ ctx.beginPath(); const p0=project(V[f[0]]); ctx.moveTo(p0[0],p0[1]); for(let i=1;i<f.length;i++){ const p=project(V[f[i]]); ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill(); });
      const E=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.lineJoin='round';
      E.forEach(([a,b])=>{ const p1=project(V[a]), p2=project(V[b]); ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); });
      drawTopRigid.lowerCorners=[V[0],V[1],V[2],V[3]]; drawTopRigid.upperCorners=[V[4],V[5],V[6],V[7]];
    }

    function drawWithState(y){
      fitScale(); ctx.clearRect(0,0,canvas.width,canvas.height);
      const {Lx,Ly,Lz,K}=vals();
      const z=y[0], thx=y[1], thy=y[2], zb=y[6];
      const zRel = z - zb; // relative translation
      const gain = parseFloat(respScaleEl.value)||0;

      drawBaseBox(Lx,Ly,Lz);
      const strokeFor=v=>kStroke(K,v); 
      const corners2=[[0,0],[Lx,0],[Lx,Ly],[0,Ly]];
      const cols=['#1d4ed8','#ef4444','#16a34a','#f59e0b']; 
      const kvals=[K[0],K[1],K[2],K[3]];

      drawTopRigid(zRel, thx, thy, Lx, Ly, Lz, gain);

      // springs from base(z=0) to top(z at relative pose)
      for(let i=0;i<4;i++){
        const [x,yc]=corners2[i];
        let topZ;
        if(drawTopRigid.lowerCorners && drawTopRigid.upperCorners){
          const low=drawTopRigid.lowerCorners[i], up=drawTopRigid.upperCorners[i];
          topZ= low[2] + 0.25*(up[2]-low[2]);
        } else {
          topZ = zRel*gain + 0.25*Lz;
        }
        drawSpringSymbol(x,yc,0,topZ,strokeFor(kvals[i]),cols[i],Lz);
      }

      drawAxes(); 
      if(overlayVisible) drawWaveformPanel();

// HUD (text only, no dark bar)
ctx.fillStyle='#111';
ctx.font='12px system-ui';
ctx.fillText(`t: ${tSimNow.toFixed(3)} s`, 66, canvas.height-13);

    }

    function draw(){
      fitScale(); ctx.clearRect(0,0,canvas.width,canvas.height);
      const {Lx,Ly,Lz,K}=vals();

      // base at z=0
      drawBaseBox(Lx,Ly,Lz);

      // top at zero relative pose
      const V=[[0,0,0],[Lx,0,0],[Lx,Ly,0],[0,Ly,0],[0,0,Lz],[Lx,0,Lz],[Lx,Ly,Lz],[0,Ly,Lz]];
      const faces=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]];
      ctx.fillStyle='rgba(200,200,200,0.5)';
      faces.forEach(f=>{ ctx.beginPath(); const p0=project(V[f[0]]); ctx.moveTo(p0[0],p0[1]); for(let i=1;i<f.length;i++){ const p=project(V[f[i]]); ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill(); });
      const E=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.lineJoin='round';
      E.forEach(([a,b])=>{ const p1=project(V[a]), p2=project(V[b]); ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); });

      // springs (from base z=0 to top z=0.25*Lz)
      const zEnd=0.25*Lz; const strokeFor=v=>kStroke(K,v);
      [{x:0,y:0,k:K[0],c:'#1d4ed8'},{x:Lx,y:0,k:K[1],c:'#ef4444'},{x:0,y:Ly,k:K[2],c:'#16a34a'},{x:Lx,y:Ly,k:K[3],c:'#f59e0b'}]
        .forEach(s=>drawSpringSymbol(s.x,s.y,0,zEnd,strokeFor(s.k),s.c,Lz));

      drawAxes(); 
      if(overlayVisible) drawWaveformPanel();
    }

    // ===== Plotting (interactive cursor) =====
    let lastTimes = null, lastAzG = null, lastFseries = null;
    let cursorTime = null; // user-selected time for both plots

    function renderAccelPlot(t, aG, tCursor=null){
      const ctx = accelPlotCtx;
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.clearRect(0,0,W,H);

      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(0,0,W,H);
      ctx.strokeStyle = '#bbb'; ctx.strokeRect(0,0,W,H);

      ctx.fillStyle='#111'; ctx.font='12px system-ui';
      ctx.fillText("Top center acceleration (G) vs time (s)", 10, 16);

      const padL=70, padR=12, padT=24, padB=28;
      const gx=padL, gy=padT, gw=W-padL-padR, gh=H-padT-padB;

      const tmin = t[0], tmax = t[t.length-1];
      const yMin = Math.min(0, ...aG), yMax = Math.max(0, ...aG);
      const yPad = (yMax - yMin) * 0.1 + 1e-9;
      const ymin = yMin - yPad, ymax = yMax + yPad;

      // axes
      ctx.strokeStyle='#ddd'; ctx.lineWidth=1; ctx.strokeRect(gx,gy,gw,gh);

      // ticks
      ctx.fillStyle='#444'; ctx.textAlign='center'; ctx.textBaseline='top';
      for(let i=0;i<=5;i++){
        const tt = tmin + (i/5)*(tmax - tmin);
        const px = gx + (tt - tmin)/(tmax - tmin || 1)*gw;
        ctx.fillText(tt.toPrecision(3), px, gy+gh+6);
      }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      for(let i=0;i<=4;i++){
        const yy = ymin + (i/4)*(ymax - ymin);
        const py = gy + gh - (yy - ymin)/(ymax - ymin || 1)*gh;
        ctx.fillText(yy.toPrecision(3), gx-6, py);
      }

      // line
      ctx.beginPath();
      for(let i=0;i<t.length;i++){
        const px = gx + (t[i]-tmin)/(tmax-tmin || 1)*gw;
        const py = gy + gh - (aG[i]-ymin)/(ymax-ymin || 1)*gh;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.strokeStyle='#0b73c8'; ctx.lineWidth=2; ctx.stroke();

      // cursor (only if user selected/hovered)
      if (tCursor!=null){
        const clamped = Math.max(tmin, Math.min(tmax, tCursor));
        const cx = gx + (clamped - tmin)/(tmax - tmin || 1)*gw;
        ctx.save();
        ctx.setLineDash([6,4]);
        ctx.strokeStyle='#111';
        ctx.beginPath(); ctx.moveTo(cx, gy); ctx.lineTo(cx, gy+gh); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle='#111'; ctx.font='11px system-ui'; ctx.textAlign='left'; ctx.textBaseline='bottom';
        ctx.fillText(`t=${clamped.toFixed(3)} s`, Math.min(cx+6, gx+gw-60), gy+gh-4);
        ctx.restore();
      }

      // labels
      ctx.fillStyle='#444';
      ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.fillText('t (s)', gx+gw-40, gy+gh+20);
      ctx.save(); ctx.translate(gx-40, gy+80); ctx.rotate(-Math.PI/2);
      ctx.fillText('Accel (G)', 0, 0);
      ctx.restore();
    }

    function renderSpringPlot(t, Fseries, tCursor=null){
      const ctx = springPlotCtx;
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.clearRect(0,0,W,H);

      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(0,0,W,H);
      ctx.strokeStyle = '#bbb'; ctx.strokeRect(0,0,W,H);

      const unit = (unitMode==='US'?'lb':'N');
      ctx.fillStyle='#111'; ctx.font='12px system-ui';
      ctx.fillText(`Corner spring reactions (${unit}) vs time (s)`, 10, 16);

      const padL=70, padR=12, padT=24, padB=28;
      const gx=padL, gy=padT, gw=W-padL-padR, gh=H-padT-padB;

      const tmin=t[0], tmax=t[t.length-1];

      let yMin=0, yMax=0;
      for(const arr of Fseries){
        yMin = Math.min(yMin, ...arr);
        yMax = Math.max(yMax, ...arr);
      }
      const yPad=(yMax-yMin)*0.1 + 1e-9;
      const ymin=yMin - yPad, ymax=yMax + yPad;

      // axes
      ctx.strokeStyle='#ddd'; ctx.lineWidth=1; ctx.strokeRect(gx,gy,gw,gh);

      // ticks
      ctx.fillStyle='#444'; ctx.textAlign='center'; ctx.textBaseline='top';
      for(let i=0;i<=5;i++){
        const tt = tmin + (i/5)*(tmax - tmin);
        const px = gx + (tt - tmin)/(tmax - tmin || 1)*gw;
        ctx.fillText(tt.toPrecision(3), px, gy+gh+6);
      }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      for(let i=0;i<=4;i++){
        const yy = ymin + (i/4)*(ymax - ymin);
        const py = gy + gh - (yy - ymin)/(ymax - ymin || 1)*gh;
        ctx.fillText(yy.toPrecision(4), gx-6, py);
      }

      // lines
      const colors=['#1d4ed8','#ef4444','#16a34a','#f59e0b'];
      for(let s=0;s<4;s++){
        ctx.beginPath();
        for(let i=0;i<t.length;i++){
          const px = gx + (t[i]-tmin)/(tmax-tmin || 1)*gw;
          const py = gy + gh - (Fseries[s][i]-ymin)/(ymax-ymin || 1)*gh;
          if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.strokeStyle=colors[s];
        ctx.lineWidth=2;
        ctx.stroke();
      }

      // legend
      const labels=['(0,0)','(Lx,0)','(0,Ly)','(Lx,Ly)'];
      ctx.font='12px system-ui'; ctx.textAlign='left'; ctx.textBaseline='middle';
      let lx=gx+6, ly=gy+12;
      const colors2=['#1d4ed8','#ef4444','#16a34a','#f59e0b'];
      for(let i=0;i<4;i++){
        ctx.fillStyle=colors2[i];
        ctx.fillRect(lx, ly-5, 18, 10);
        ctx.fillStyle='#333';
        ctx.fillText(labels[i], lx+24, ly);
        lx += 90;
      }

      // cursor
      if (tCursor!=null){
        const clamped = Math.max(tmin, Math.min(tmax, tCursor));
        const cx = gx + (clamped - tmin)/(tmax - tmin || 1)*gw;
        ctx.save();
        ctx.setLineDash([6,4]);
        ctx.strokeStyle='#111';
        ctx.beginPath(); ctx.moveTo(cx, gy); ctx.lineTo(cx, gy+gh); ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle='#111'; ctx.font='11px system-ui'; ctx.textAlign='left'; ctx.textBaseline='bottom';
        ctx.fillText(`t=${clamped.toFixed(3)} s`, Math.min(cx+6, gx+gw-60), gy+gh-4);
        ctx.restore();
      }

      // labels
      ctx.fillStyle='#444';
      ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.fillText('t (s)', gx+gw-40, gy+gh+20);
      ctx.save(); ctx.translate(gx-40, gy+80); ctx.rotate(-Math.PI/2);
      ctx.fillText(`Force (${unit})`, 0, 0);
      ctx.restore();
    }

    // ===== Simulation state & control =====
    let tSimNow=0; 
    let overlayVisible=false; 
    let simData=null, simStartWall=0, playing=false, currentY=null;

// === Max acceleration state (in G) ===
let maxCenterG = 0;
let maxCornerG = [0,0,0,0];

function resetMaxAccelPanel(){
  maxCenterG = 0;
  maxCornerG = [0,0,0,0];
  maxCenterEl.textContent = 'Center: ‚Äî';
  maxC00El.textContent    = '(0,0): ‚Äî';
  maxCLx0El.textContent   = '(Lx,0): ‚Äî';
  maxC0LyEl.textContent   = '(0,Ly): ‚Äî';
  maxCLxLyEl.textContent  = '(Lx,Ly): ‚Äî';
}


    // Return center accel, corner accels, and spring forces at a sample
    function responseAtSample(y) {
      const {Lx, Ly, K} = vals();
      const [k00v,kLx0v,k0Lyv,kLxLyv] = K;

      const W = +weightEl.value || 0;
      const mTop = W / g();

      const z=y[0], thx=y[1], thy=y[2], vz=y[3], wx=y[4], wy=y[5], zb=y[6], vb=y[7];

      const corners = (function(Lx, Ly){ const hx=Lx/2, hy=Ly/2; return [[-hx,-hy],[hx,-hy],[-hx,hy],[hx,hy]]; })(Lx, Ly);

      const zeta = ((+document.getElementById('damping').value || 0) / 100);
      const m_eq = mTop/4;
      const Cspr = [
        2*zeta*Math.sqrt(Math.max(k00v,0)*m_eq),
        2*zeta*Math.sqrt(Math.max(kLx0v,0)*m_eq),
        2*zeta*Math.sqrt(Math.max(k0Lyv,0)*m_eq),
        2*zeta*Math.sqrt(Math.max(kLxLyv,0)*m_eq),
      ];
      const kList = [k00v,kLx0v,k0Lyv,kLxLyv];

      const dispTop=new Array(4), velTop=new Array(4);
      for(let i=0;i<4;i++){
        const xi=corners[i][0], yi=corners[i][1];
        dispTop[i]= z + (-thx*yi) + (thy*xi);
        velTop[i] = vz + (-wx *yi) + (wy *xi);
      }

      const Fi = new Array(4);
      for (let i=0;i<4;i++){
        const rel = dispTop[i] - zb;
        const relv= velTop[i] - vb;
        Fi[i] = -(kList[i]*rel + Cspr[i]*relv); // force on TOP
      }

      // net force/torques on top
      const Fz = Fi.reduce((s,v)=>s+v,0);
      const TauX = (-corners[0][1])*Fi[0] + (-corners[1][1])*Fi[1] + (-corners[2][1])*Fi[2] + (-corners[3][1])*Fi[3]; // sum(-yi*Fi)
      const TauY = ( corners[0][0])*Fi[0] + ( corners[1][0])*Fi[1] + ( corners[2][0])*Fi[2] + ( corners[3][0])*Fi[3]; // sum( xi*Fi)

      const Ix = (mTop/12) * (Ly*Ly + (+lz.value||3) * (+lz.value||3));
      const Iy = (mTop/12) * (Lx*Lx + (+lz.value||3) * (+lz.value||3));

      const az  = (mTop>0)? (Fz/mTop) : 0;
      const awx = (Ix  >0)? (TauX/Ix) : 0;
      const awy = (Iy  >0)? (TauY/Iy) : 0;

      // vertical acceleration at corners (small angle)
      const aCorners = new Array(4);
      for (let i=0;i<4;i++){
        const xi=corners[i][0], yi=corners[i][1];
        aCorners[i] = az + (-awx * yi) + (awy * xi);
      }

      return { az, aCorners, Fi };
    }

const simulate = ()=>{
  if (playing) { showToast('Simulation already running'); return; }

  const A = +shockAmp.value || 0;
  const T = +shockTime.value || 0;
  const W = +weightEl.value || 0;
  const {K} = vals();
  const sumK = K.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);

  overlayVisible = true;
  if (A === 0 || T <= 0){ draw(); showToast('Enter non-zero Amplitude and positive Time Pulse.'); return; }
  if (W <= 0){ draw(); showToast('Weight must be > 0.'); return; }
  if (sumK <= 0){ draw(); showToast('All spring k must sum to > 0.'); return; }

  // üîÑ Reset maxima + UI panel for a fresh run
  resetMaxAccelPanel();

  console.info('[Input] peak a_base:', { A_G: A, a_units: A*g(), units: (unitMode==='US'?'in/s^2':'m/s^2') });

  draw(); showToast('Simulating‚Ä¶');

  try {
    const f = makeDynamics();
    const Tperiod = lowestNaturalPeriod();
    const tEnd = Math.min(10*Math.max(0.05, Tperiod), 20.0);
    const y0 = new Float64Array(8);

    simData = rkf45Integrate(f, 0, y0, tEnd, 0.0001, .5e-5, 1e-8);

    if (!simData || !simData.t || simData.t.length < 2 || !Number.isFinite(simData.t[simData.t.length-1])) {
      showToast('Simulation produced no steps');
      return;
    }
    console.log('RKF done:', { steps: simData.t.length, tEnd });

    // Build series for plots
    const times = simData.t;
    const azG = new Array(times.length);
    const F0 = new Array(times.length), F1 = new Array(times.length),
          F2 = new Array(times.length), F3 = new Array(times.length);

    for (let i=0;i<times.length;i++){
      const { az, aCorners, Fi } = responseAtSample(simData.y[i]);

      // center accel in G
      const centerG = az / g();
      azG[i] = centerG;

      // spring forces (for plot)
      F0[i] = Fi[0];
      F1[i] = Fi[1];
      F2[i] = Fi[2];
      F3[i] = Fi[3];

      // üîÑ update max |accel| center + corners (in G)
      if (Math.abs(centerG) > maxCenterG) maxCenterG = Math.abs(centerG);
      for (let j=0;j<4;j++){
        const cornerG = aCorners[j] / g();
        if (Math.abs(cornerG) > maxCornerG[j]) maxCornerG[j] = Math.abs(cornerG);
      }
    }

    lastTimes = times; lastAzG = azG; lastFseries = [F0,F1,F2,F3];
    cursorTime = null; // no cursor until user interacts

    renderAccelPlot(times, azG, cursorTime);
    renderSpringPlot(times, [F0,F1,F2,F3], cursorTime);

    // üñ•Ô∏è Write maxima into the setup panel's readout
    maxCenterEl.textContent = `Center: ${maxCenterG.toFixed(3)} G`;
    maxC00El.textContent    = `(0,0): ${maxCornerG[0].toFixed(3)} G`;
    maxCLx0El.textContent   = `(Lx,0): ${maxCornerG[1].toFixed(3)} G`;
    maxC0LyEl.textContent   = `(0,Ly): ${maxCornerG[2].toFixed(3)} G`;
    maxCLxLyEl.textContent  = `(Lx,Ly): ${maxCornerG[3].toFixed(3)} G`;

    // Start animation
    tSimNow = 0; simStartWall = performance.now(); playing = true;
    requestAnimationFrame(stepAnimation);
  } catch (err) {
    console.error(err);
    showToast('Simulation error ‚Äî see console');
  }
};


  

simulateBtn.addEventListener('click',simulate);




    function stepAnimation(now){
      if(!playing||!simData) return; 
      const speed=parseFloat(simSpeed.value)||0; 
      const tEnd=simData.t[simData.t.length-1]; 
      const tSim=((now-simStartWall)/1000)*speed; 
      tSimNow=Math.min(tSim,tEnd); 
      currentY=interpSeries(simData.t, simData.y, tSimNow); 
      drawWithState(currentY);

      if(tSim<tEnd) requestAnimationFrame(stepAnimation); 
      else { playing=false; showToast('Simulation complete'); }
    }

    // ===== Interactive cursor handlers =====
    function plotGeom(ctx, padL, padR, padT, padB){
      const W=ctx.canvas.width, H=ctx.canvas.height;
      return { gx:padL, gy:padT, gw:W-padL-padR, gh:H-padT-padB, W, H };
    }
    function tFromX(x, tmin, tmax, geom){
      const {gx, gw} = geom;
      const r = Math.max(0, Math.min(1, (x - gx) / (gw || 1)));
      return tmin + r * (tmax - tmin);
    }
    function interp1(times, arr, t){
      const n=times.length; if(t<=times[0]) return arr[0]; if(t>=times[n-1]) return arr[n-1];
      let lo=0,hi=n-1; while(hi-lo>1){ const mid=(lo+hi)>>1; if(times[mid]<=t) lo=mid; else hi=mid; }
      const a=(t-times[lo])/(times[hi]-times[lo] || 1);
      return arr[lo] + a*(arr[hi]-arr[lo]);
    }
    function updateReadout(tSel){
      if (!lastTimes) { readoutEl.textContent=''; return; }
      const aG = interp1(lastTimes, lastAzG, tSel);
      const F = lastFseries.map(series => interp1(lastTimes, series, tSel));
      const unit = (unitMode==='US'?'lb':'N');
      readoutEl.textContent = `t = ${tSel.toFixed(4)} s ‚Äî accel: ${aG.toFixed(4)} G, springs: [${F.map(v=>v.toFixed(2)).join(', ')}] ${unit}`;
    }

    function attachCursor(canvasEl, type){ // type: 'accel' or 'spring'
      let dragging=false;
      const onMove = (e)=>{
        if(!lastTimes) return;
        const rect = canvasEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const tmin = lastTimes[0], tmax=lastTimes[lastTimes.length-1];
        const geom = (type==='accel') ? plotGeom(accelPlotCtx,40,12,24,28) : plotGeom(springPlotCtx,46,12,24,28);
        cursorTime = tFromX(x, tmin, tmax, geom);
        // Redraw both plots with cursor
        renderAccelPlot(lastTimes, lastAzG, cursorTime);
        renderSpringPlot(lastTimes, lastFseries, cursorTime);
        updateReadout(cursorTime);
      };
      canvasEl.addEventListener('mousemove',(e)=>{ if (!lastTimes) return; if (dragging) onMove(e); });
      canvasEl.addEventListener('mousedown',(e)=>{ dragging=true; onMove(e); });
      window.addEventListener('mouseup',()=>{ dragging=false; });
      canvasEl.addEventListener('mouseleave',()=>{ if(!dragging){ cursorTime=null; renderAccelPlot(lastTimes||[], lastAzG||[], null); renderSpringPlot(lastTimes||[], lastFseries||[[],[],[],[]], null); readoutEl.textContent=''; }});
      // Also allow simple hover selection (no drag)
      canvasEl.addEventListener('mousemove',(e)=>{ if(!dragging) onMove(e); });
    }
    attachCursor(accelPlot, 'accel');
    attachCursor(springPlot, 'spring');

    // ===== Exports =====
    function exportJSON(){
      if (!lastTimes){ showToast('Run a simulation first'); return; }
      const data = lastTimes.map((t,i)=>({
        t,
        accel_G: lastAzG[i],
        spring_00: lastFseries[0][i],
        spring_Lx0: lastFseries[1][i],
        spring_0Ly: lastFseries[2][i],
        spring_LxLy: lastFseries[3][i],
        units_force: (unitMode==='US'?'lb':'N')
      }));
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'base_shake_response.json';
      a.click();
      URL.revokeObjectURL(a.href);
    }
  
function exportJSON(){
  if (!lastTimes){ showToast('Run a simulation first'); return; }
  
  const now = new Date();
  const timestamp = now.getFullYear() + 
    String(now.getMonth()+1).padStart(2,'0') + 
    String(now.getDate()).padStart(2,'0') + '_' +
    String(now.getHours()).padStart(2,'0') + 
    String(now.getMinutes()).padStart(2,'0') + 
    String(now.getSeconds()).padStart(2,'0');
  
  // Configuration data for re-running
  const config = {
    units: unitMode,
    weight: weightEl.value,
    lx: lx.value,
    ly: ly.value,
    lz: lz.value,
    k00: k00.value,
    kLx0: kLx0.value,
    k0Ly: k0Ly.value,
    kLxLy: kLxLy.value,
    damping: document.getElementById('damping').value,
    shockAmp: shockAmp.value,
    shockTime: shockTime.value,
    shockWave: shockWave.value,
    respScale: respScaleEl.value,
    simSpeed: simSpeed.value
  };
  
  // Results data
  const results = lastTimes.map((t,i)=>({
    t,
    accel_G: lastAzG[i],
    spring_00: lastFseries[0][i],
    spring_Lx0: lastFseries[1][i],
    spring_0Ly: lastFseries[2][i],
    spring_LxLy: lastFseries[3][i],
    units_force: (unitMode==='US'?'lb':'N')
  }));
  
  const exportData = {
    timestamp: now.toISOString(),
    config: config,
    results: results
  };
  
  const blob = new Blob([JSON.stringify(exportData,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'base_shake_response_' + timestamp + '.json';
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('Data exported with configuration');
}

function importJSON(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = function(e){
    const file = e.target.files[0];
    if(!file) return;
    
    const reader = new FileReader();
    reader.onload = function(evt){
      try{
        const data = JSON.parse(evt.target.result);
        
        // Check if this is the new format with config object
        const config = data.config || data;
        
        // Populate all input fields
        if(config.units !== undefined) setUnits(config.units);
        if(config.weight !== undefined) weightEl.value = config.weight;
        if(config.lx !== undefined) lx.value = config.lx;
        if(config.ly !== undefined) ly.value = config.ly;
        if(config.lz !== undefined) lz.value = config.lz;
        if(config.k00 !== undefined) k00.value = config.k00;
        if(config.kLx0 !== undefined) kLx0.value = config.kLx0;
        if(config.k0Ly !== undefined) k0Ly.value = config.k0Ly;
        if(config.kLxLy !== undefined) kLxLy.value = config.kLxLy;
        if(config.damping !== undefined) document.getElementById('damping').value = config.damping;
        if(config.shockAmp !== undefined) shockAmp.value = config.shockAmp;
        if(config.shockTime !== undefined) shockTime.value = config.shockTime;
        if(config.shockWave !== undefined) shockWave.value = config.shockWave;
        if(config.respScale !== undefined) respScaleEl.value = config.respScale;
        if(config.simSpeed !== undefined) simSpeed.value = config.simSpeed;
        
        // Update computed fields and redraw
        computeMass();
        draw();
        
        showToast('Configuration imported successfully');
      } catch(err){
        console.error(err);
        showToast('Error importing JSON: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}


exportJSONBtn.addEventListener('click', exportJSON);
importJSONBtn.addEventListener('click', importJSON);
exportCSVBtn.addEventListener('click', exportCSV);


    // ===== Interactions (3D view) =====
    [lx,ly,lz,k00,kLx0,k0Ly,kLxLy].forEach(el=> el.addEventListener('input',draw));
    let dragging=false,lastX=0,lastY=0, dragMode='rotate';
    canvas.addEventListener('contextmenu',e=>e.preventDefault());
    canvas.addEventListener('mousedown',e=>{
      dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.style.cursor='grabbing';
      dragMode=((e.button===0 && e.shiftKey) || e.button===2)?'pan':'rotate';
    });
    window.addEventListener('mouseup',()=>{ dragging=false; canvas.style.cursor='default'; });
    window.addEventListener('mousemove',e=>{
      if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
      if(dragMode==='pan'){ panX+=dx; panY+=dy; }
      else { yaw+=dx*0.01; pitch+=dy*0.01; pitch=Math.max(-1.2,Math.min(1.2,pitch)); }
      (playing? drawWithState(currentY||new Array(8).fill(0)): draw());
    });
    canvas.addEventListener('wheel',e=>{ e.preventDefault(); const factor=Math.exp(-e.deltaY*0.0015); zoom=Math.min(5,Math.max(0.3,zoom*factor)); (playing? drawWithState(currentY||new Array(8).fill(0)): draw()); }, {passive:false});
    resetBtn.addEventListener('click',()=>{ yaw=0.8; pitch=-1.0; zoom=1.5; panX=-100; panY=125; (playing? drawWithState(currentY||new Array(8).fill(0)): draw()); });
    respScaleEl.addEventListener('input',()=> (playing? drawWithState(currentY||new Array(8).fill(0)): draw()));

    function selfTest(){
      console.assert(typeof rkf45Integrate==='function','rkf45Integrate exists');
      console.assert(document.getElementById('simulateBtn'), 'simulateBtn present');
    }
    setUnits('US'); computeMass(); draw(); selfTest();
  })();
  </script>
</body>
</html>


























