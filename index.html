<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">

<title>Vertical Plate â€” steady state + multi sources</title>
<!-- ADD THIS LINE FOR ZIP FUNCTIONALITY -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>


  <style>
    .app *{ box-sizing:border-box; }
    .app{ font-family:system-ui,Arial,sans-serif; color:#111; margin:12px; }
    .panel{ border:1px solid #ddd; border-radius:8px; background:#fff; padding:10px; }

    /* Harden topline so it survives host CSS */
    .topline{
      font-size:14px;
      margin-bottom:8px;
      display:block;
      padding:6px 8px;
      border:1px solid #e5e7eb;
      border-radius:8px;
      background:#fff;
      color:#111;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .grid{ display:flex; gap:16px; flex-wrap:wrap; align-items:flex-start; }
    .grid>.col{ min-width:280px; max-width:720px; flex:1 1 720px; }
    .row{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; margin:8px 0; }

    /* keep labels visible on any host */
    .app label{
      display:inline-block !important;
      width:120px; text-align:right; margin-right:8px;
      font-size:13px; white-space:nowrap;
    }
    .app input[type=number], .app select, .app button{
      height:28px; padding:0 8px; line-height:1;
    }
    .app input[type=number]{ width:100px; }
    #nx{ width:100px; }

    canvas{ border:1px solid #333; background:#fff; cursor:crosshair; }
    #canvasWrap{ position:relative; display:inline-block }
    .legend{ position:absolute; right:6px; top:6px; padding:6px; background:rgba(255,255,255,.92); border:1px solid #ddd; border-radius:6px }
    .legend .bar{ width:12px; height:120px; background:linear-gradient(#f00,#ff0,#0f0,#0bf,#00f); }
    .legend .ticks{ height:120px; display:flex; flex-direction:column; justify-content:space-between; margin-left:6px; font-size:12px }

    #sourcesList{ border:1px dashed #c8d; padding:8px; border-radius:8px; background:#faf8ff }
    .srcRow{ display:flex; align-items:center; gap:10px; margin:6px 0; }
    .pill{ font-size:12px; padding:2px 6px; background:#eef; border:1px solid #cde; border-radius:10px; }
    .hint{ font-size:12px; color:#555; }
  </style>




</head>

<body>
  <div class="app">
    <!-- FIX: do not use id="top" (collides with window.top in iframes) -->
    <div id="topline" class="topline">â€”</div>

    <div class="grid panel">
      <div class="col">
        <div class="row">
          <label for="widthM">Width (m)</label><input id="widthM" type="number" value="0.20" step="0.01">
          <label for="heightM">Height (m)</label><input id="heightM" type="number" value="0.12" step="0.01">
        </div>
        <div class="row">
          <label for="thicknessM">Thickness (m)</label><input id="thicknessM" type="number" value="0.005" step="0.001">
          <label for="material">Material</label>
          <select id="material">
            <option value="Al">Aluminum (6061)</option>
            <option value="Cu">Copper</option>
            <option value="Steel">Steel</option>
            <option value="FR4">FR4</option>
          </select>
        </div>
        <div class="row">
          <label for="ambientT">Ambient (Â°C)</label><input id="ambientT" type="number" value="20" step="1">
          <label for="nx"># cells along width</label><input id="nx" type="number" value="96" min="20" max="400">
        </div>


    <div class="row">
  <button id="setup">Setup Grid</button>
  <button id="solve">Solve</button>
  <button id="reset">Reset to Ambient</button>
  <label class="hint"><input id="showGrid" type="checkbox" checked> Show grid</label>
  
  <!-- ADD THESE FOUR BUTTONS HERE -->
  <button id="exportJsonBtn" style="background: #fff3cd; border: 1px solid #ffc107; color: #856404; margin-left: 8px;">ðŸ’¾ JSON</button>
  <button id="importJsonBtn" style="background: #d1ecf1; border: 1px solid #bee5eb; color: #0c5460;">ðŸ“‚ Import</button>
  <button id="exportCsvBtn" style="background: #d4edda; border: 1px solid #c3e6cb; color: #155724;">ðŸ“Š CSV</button>
  <button id="exportZipBtn" style="background: #cfe2ff; border: 1px solid #b6d4fe; color: #084298;">ðŸ“¦ ZIP</button>
  <!-- END OF NEW BUTTONS -->
</div>    



</div>
      </div>




      <div class="col">
        <div class="row"><strong>Drag rectangles on the canvas to add heat sources</strong></div>
        <div class="row">
          <label for="defaultW">Default power (W)</label><input id="defaultW" type="number" value="10" step="0.1">
          <button id="clearAll">Clear all sources</button>
        </div>
        <div id="sourcesList" class="panel">
          <div class="hint">No sources yet. Drag a rectangle on the canvas. Each row is editable and has a Remove button.</div>
        </div>
      </div>
    </div>

    <div id="canvasWrap" class="panel">
      <canvas id="cv" width="720" height="432"></canvas>
      <div class="legend" id="legend" style="display:none">
        <div style="display:flex">
          <div class="bar"></div>
          <div class="ticks">
            <div id="tMaxLbl">â€”</div><div></div><div id="tMinLbl">â€”</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* materials */
  const mats = {
    Al:{k:167, rho:2700, cp:896},
    Cu:{k:401, rho:8960, cp:385},
    Steel:{k:50, rho:7850, cp:470},
    FR4:{k:0.3, rho:1900, cp:1200}
  };

  /* state */
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  /* FIX: explicit reference to topline element */
  const toplineEl = document.getElementById('topline');

  let grid=null;
  let sources=[];              // {rect:{x0,y0,x1,y1}, W:number, cells:int[]}
  let drawing=false, p0=null;

  /* convective h: Churchillâ€“Chu, vertical plate, one-sided */
  function hChurchillChu(dT,L){
    const k=0.026, nu=1.5e-5, alpha=2.2e-5, Pr=0.71, beta=1/300, g=9.81;
    const DT=Math.max(1e-6,dT), Le=Math.max(1e-6,L);
    const Ra=g*beta*DT*Math.pow(Le,3)/(nu*alpha);
    const Nu=0.68 + (0.670*Math.pow(Ra,0.25))/Math.pow(1+Math.pow(0.492/Pr,9/16),4/9);
    return Nu*k/Le;
  }

  /* grid */
  function setupGrid(){
    const Wm=+widthM.value, Hm=+heightM.value;
    const aspect=Math.max(0.1,Hm/Wm), baseW=720;
    cv.width=baseW; cv.height=Math.max(240,Math.round(baseW*aspect));

    const nxCells=(+nx.value|0);
    const ny=Math.max(1,Math.round(nxCells*Hm/Wm));
    const dx=Wm/nxCells, dy=Hm/ny, N=nxCells*ny;

    const T0=+ambientT.value;
    const m=mats[material.value];

    grid={
      nx:nxCells, ny, dx, dy,
      widthM:Wm, heightM:Hm,
      k:m.k, rho:m.rho, cp:m.cp,
      t:+thicknessM.value,
      Ta:T0, h:5.0,
      T:new Float32Array(N).fill(T0)
    };

    // keep sources but their cell lists depend on grid; rebuild at solve time
    document.getElementById('legend').style.display='block';
    draw(); topline('grid');
  }
  setupGrid();
  setup.onclick=setupGrid;

  /* sources helpers */
  function rectToCells(rect){
    const {nx,ny}=grid, cw=cv.width, ch=cv.height;
    let x0=Math.floor(Math.min(rect.x0,rect.x1)/cw*nx);
    let x1=Math.floor(Math.max(rect.x0,rect.x1)/cw*nx);
    let y0=Math.floor(Math.min(rect.y0,rect.y1)/ch*ny);
    let y1=Math.floor(Math.max(rect.y0,rect.y1)/ch*ny);
    x0=Math.max(0,Math.min(nx-1,x0)); x1=Math.max(0,Math.min(nx-1,x1));
    y0=Math.max(0,Math.min(ny-1,y0)); y1=Math.max(0,Math.min(ny-1,y1));
    const out=[]; for(let j=y0;j<=y1;j++) for(let i=x0;i<=x1;i++) out.push(j*nx+i);
    return out;
  }
  function addSource(rect){
    const W=+defaultW.value;
    sources.push({rect, W, cells:[]});  // cells projected at solve time
    updateSourcesUI(); draw();
  }
  function updateSourcesUI(){
    const box=document.getElementById('sourcesList'); box.innerHTML='';
    if(sources.length===0){
      const d=document.createElement('div'); d.className='hint';
      d.textContent='No sources yet. Drag a rectangle on the canvas. Each row is editable and has a Remove button.';
      box.appendChild(d); return;
    }
    sources.forEach((s,idx)=>{
      const row=document.createElement('div'); row.className='srcRow';
      const tag=document.createElement('span'); tag.className='pill'; tag.textContent='S'+(idx+1);
      const wl=document.createElement('label'); wl.textContent='W:'; wl.style.width='20px'; wl.style.textAlign='right';
      const w=document.createElement('input'); w.type='number'; w.step='0.1'; w.value=s.W; w.style.width='90px';
      w.onchange=()=>{ s.W=+w.value||0; };
      const rm=document.createElement('button'); rm.textContent='Remove';
      rm.onclick=()=>{ sources.splice(idx,1); updateSourcesUI(); draw(); topline(); };
      row.appendChild(tag); row.appendChild(wl); row.appendChild(w); row.appendChild(rm);
      box.appendChild(row);
    });
  }
  document.getElementById('clearAll').onclick=()=>{ sources=[]; updateSourcesUI(); draw(); topline(); };

  /* add rectangles by mouse */
  cv.addEventListener('mousedown', e=>{
    if(!grid) return; drawing=true;
    const r=cv.getBoundingClientRect();
    p0={x:e.clientX-r.left, y:e.clientY-r.top};
  });
  cv.addEventListener('mousemove', e=>{
    if(!drawing) return;
    const r=cv.getBoundingClientRect();
    const rect={x0:p0.x,y0:p0.y,x1:e.clientX-r.left,y1:e.clientY-r.top};
    draw(rect);
  });
  cv.addEventListener('mouseup', e=>{
    if(!drawing) return; drawing=false;
    const r=cv.getBoundingClientRect();
    const rect={x0:p0.x,y0:p0.y,x1:e.clientX-r.left,y1:e.clientY-r.top};
    if(Math.abs(rect.x1-rect.x0)>4 && Math.abs(rect.y1-rect.y0)>4) addSource(rect);
    topline();
  });

  /* KISS steady-state solver: FVM + SOR, Picard on h */
  function solve(){
    if(!grid) setupGrid();

    // 1) project rectangles to current grid cells
    for(const s of sources) s.cells = rectToCells(s.rect);

    const {nx,ny,dx,dy,k,t} = grid;
    const N = nx*ny;
    const A = dx*dy;                 // cell area

    // 2) build per-cell Watts
    const Q = new Float32Array(N);
    for(const s of sources){
      const cells=s.cells, per=(cells.length? s.W/cells.length : 0);
      for(const c of cells) Q[c]+=per;
    }

    // 3) outer Picard on h (one-sided Churchillâ€“Chu)
    const maxOuter=40, tolH=0.01;
    for(let outer=0; outer<maxOuter; outer++){
      // coefficients (per-area balance)
      const aw = k*t/(dx*dx), ae=aw;
      const as = k*t/(dy*dy), an=as;
      const aP = aw+ae+as+an + grid.h;          // NOTE: + h (one-sided)
      const rhsTa = grid.h * grid.Ta;

      // SOR
      const omega=1.85, tol=1e-5, maxIt=6000;
      for(let it=0; it<maxIt; it++){
        let maxDelta=0;
        for(let j=0;j<ny;j++){
          for(let i=0;i<nx;i++){
            const idx=j*nx+i, T=grid.T;
            const Te=(i<nx-1)?T[idx+1]:T[idx];
            const Tw=(i>0)?T[idx-1]:T[idx];
            const Tn=(j<ny-1)?T[idx+nx]:T[idx];
            const Ts=(j>0)?T[idx-nx]:T[idx];

            const b = rhsTa + Q[idx]/A;        // W/A term
            const Tnew = (aw*Tw + ae*Te + as*Ts + an*Tn + b)/aP;
            const upd = T[idx] + omega*(Tnew - T[idx]);
            const d = Math.abs(upd - T[idx]);
            if(d>maxDelta) maxDelta=d;
            T[idx]=upd;
          }
        }
        if(maxDelta<tol) break;
      }

      // refresh h from average Î”T
      const Tavg = avg(grid.T);
      const hNew = hChurchillChu(Math.max(0,Tavg-grid.Ta), grid.heightM);
      const rel = Math.abs(hNew-grid.h)/Math.max(1e-6,grid.h);
      grid.h = 0.5*grid.h + 0.5*hNew;
      if(rel<tolH) break;
    }

    draw(); topline('solved');
  }
  document.getElementById('solve').onclick=solve;

  /* misc UI */
  document.getElementById('reset').onclick=()=>{
    if(!grid) return;
    grid.T.fill(grid.Ta);
    draw();
    topline('reset');
  };

  function avg(a){ let s=0; for(let i=0;i<a.length;i++) s+=a[i]; return s/a.length; }
  function energyResidual(){
    if(!grid) return 0;
    const {dx,dy,h,Ta,T}=grid;
    let Qin=0; for(const s of sources) Qin+=s.W;
    let Qout=0, A=dx*dy;
    for(let i=0;i<T.length;i++) Qout += h*A*Math.max(0,T[i]-Ta);
    const den=Math.max(1e-6,Math.abs(Qin)+Math.abs(Qout));
    return Math.abs(Qin-Qout)/den;
  }

  function topline(){
    if(!grid){
      if(toplineEl) toplineEl.textContent='â€”';
      return;
    }
    const A=(grid.widthM*grid.heightM).toFixed(3);
    const res=(energyResidual()*100).toFixed(2);
    const Tavg=avg(grid.T).toFixed(1);
    let Tmax=-Infinity; for(const v of grid.T) if(v>Tmax) Tmax=v;

    if(toplineEl){
      toplineEl.textContent =
        `nÃ—m=${grid.nx}Ã—${grid.ny} â€¢ one-sided â€¢ hâ‰ˆ ${grid.h.toFixed(2)} W/mÂ²K â€¢ `+
        `Aâ‰ˆ ${A} mÂ² â€¢ Î£Wâ‰ˆ ${sources.reduce((s,x)=>s+x.W,0).toFixed(2)} W â€¢ `+
        `residualâ‰ˆ ${res}% â€¢ Tavgâ‰ˆ ${Tavg} Â°C â€¢ Tmaxâ‰ˆ ${Tmax.toFixed(1)} Â°C`;
    }
  }

  /* draw */
  function draw(tempRect=null){
    if(!grid){ ctx.clearRect(0,0,cv.width,cv.height); return; }
    const {nx,ny,T}=grid;
    let tmin=+Infinity,tmax=-Infinity;
    for(const v of T){ if(v<tmin)tmin=v; if(v>tmax)tmax=v; }
    const img=ctx.createImageData(cv.width,cv.height), d=img.data;

    for(let py=0;py<cv.height;py++){
      const gy=(py+0.5)/cv.height*ny-0.5;
      const j0=Math.max(0,Math.min(ny-1,Math.floor(gy)));
      const j1=Math.min(ny-1,j0+1);
      const fy=Math.min(1,Math.max(0,gy-j0));
      for(let px=0;px<cv.width;px++){
        const gx=(px+0.5)/cv.width*nx-0.5;
        const i0=Math.max(0,Math.min(nx-1,Math.floor(gx)));
        const i1=Math.min(nx-1,i0+1);
        const fx=Math.min(1,Math.max(0,gx-i0));
        const t00=T[j0*nx+i0], t10=T[j0*nx+i1], t01=T[j1*nx+i0], t11=T[j1*nx+i1];
        const t0=t00*(1-fx)+t10*fx, t1=t01*(1-fx)+t11*fx;
        const t=t0*(1-fy)+t1*fy;
        const n=(t-tmin)/Math.max(1e-9,tmax-tmin);
        const R=Math.floor(255*Math.min(1,Math.max(0,2*n)));
        const B=Math.floor(255*Math.min(1,Math.max(0,2*(1-n))));
        const G=Math.floor(255*Math.max(0,1-2*Math.abs(n-0.5)));
        const kk=(py*cv.width+px)*4; d[kk]=R; d[kk+1]=G; d[kk+2]=B; d[kk+3]=255;
      }
    }
    ctx.putImageData(img,0,0);

    // overlays
    ctx.save(); ctx.globalAlpha=0.35; ctx.fillStyle="#ff7700";
    sources.forEach(s=>{
      const r=s.rect;
      ctx.fillRect(Math.min(r.x0,r.x1), Math.min(r.y0,r.y1),
                   Math.abs(r.x1-r.x0), Math.abs(r.y1-r.y0));
    });
    if(tempRect){
      ctx.fillStyle="rgba(0,200,0,0.35)";
      ctx.fillRect(Math.min(tempRect.x0,tempRect.x1), Math.min(tempRect.y0,tempRect.y1),
                   Math.abs(tempRect.x1-tempRect.x0), Math.abs(tempRect.y1-tempRect.y0));
    }
    ctx.restore();

    // axes
    if(showGrid.checked) drawGrid();
    tMaxLbl.textContent=tmax.toFixed(1)+'Â°C';
    tMinLbl.textContent=tmin.toFixed(1)+'Â°C';
  }

  function niceStep(x){
    const p=Math.pow(10,Math.floor(Math.log10(x)));
    const n=x/p;
    const s=(n<1.5)?1:(n<3)?2:(n<7)?5:10;
    return s*p;
  }

  function drawGrid(){
    const {widthM,heightM}=grid;
    ctx.save();
    ctx.strokeStyle='#000'; ctx.lineWidth=1;
    ctx.strokeRect(0.5,0.5,cv.width-1,cv.height-1);
    const target=8, sx=niceStep(widthM/target), sy=niceStep(heightM/target);
    ctx.fillStyle='#000'; ctx.font='12px system-ui';

    for(let x=0;x<=widthM+1e-12;x+=sx){
      const px=x/widthM*cv.width;
      ctx.beginPath(); ctx.moveTo(px,cv.height-8); ctx.lineTo(px,cv.height); ctx.stroke();
      ctx.fillText(x.toFixed(3), px-14, cv.height-10);
      ctx.strokeStyle='#eee'; ctx.beginPath(); ctx.moveTo(px,0); ctx.lineTo(px,cv.height); ctx.stroke(); ctx.strokeStyle='#000';
    }

    for(let y=0;y<=heightM+1e-12;y+=sy){
      const py=y/heightM*cv.height;
      ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(8,py); ctx.stroke();
      ctx.fillText(y.toFixed(3), 10, py-2);
      ctx.strokeStyle='#eee'; ctx.beginPath(); ctx.moveTo(0,py); ctx.lineTo(cv.width,py); ctx.stroke(); ctx.strokeStyle='#000';
    }

    ctx.fillText('W = '+widthM.value+' m', cv.width-120, cv.height-24);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('H = '+heightM.value+' m', -cv.height+6, 12);
    ctx.rotate(Math.PI/2);
    ctx.restore();
  }
 
// ==================== EXPORT/IMPORT FUNCTIONS ====================

  // Helper function to get formatted timestamp
  function getTimestamp() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
  }

  // 1. EXPORT JSON BUTTON
  document.getElementById('exportJsonBtn').onclick = () => {
    const data = {
      timestamp: new Date().toISOString(),
      moduleType: 'vertical_plate_heatsink',
      geometry: {
        widthM: +widthM.value,
        heightM: +heightM.value,
        thicknessM: +thicknessM.value,
        material: material.value
      },
      simulation: {
        ambientT: +ambientT.value,
        nx: +nx.value,
        showGrid: showGrid.checked
      },
      sources: sources.map(s => ({
        rect: s.rect,
        W: s.W
      })),
      defaultPower: +defaultW.value
    };
    
    const jsonStr = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `heatsink_config_${getTimestamp()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // 2. IMPORT JSON BUTTON
  document.getElementById('importJsonBtn').onclick = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          
          // Geometry
          if (data.geometry) {
            widthM.value = data.geometry.widthM;
            heightM.value = data.geometry.heightM;
            thicknessM.value = data.geometry.thicknessM;
            material.value = data.geometry.material;
          }
          
          // Simulation
          if (data.simulation) {
            ambientT.value = data.simulation.ambientT;
            nx.value = data.simulation.nx;
            showGrid.checked = data.simulation.showGrid !== undefined ? data.simulation.showGrid : true;
          }
          
          // Default Power
          if (data.defaultPower !== undefined) {
            defaultW.value = data.defaultPower;
          }
          
          // Sources
          if (data.sources) {
            sources = data.sources.map(s => ({
              rect: s.rect,
              W: s.W,
              cells: [] // Will be recalculated on solve
            }));
            updateSourcesUI();
          }
          
          // Rebuild grid
          setupGrid();
          
          alert('Configuration loaded successfully!');
        } catch (err) {
          alert('Error loading JSON file: ' + err.message);
        }
      };
      reader.readAsText(file);
    };
    input.click();
  };

  // 3. EXPORT CSV BUTTON
  document.getElementById('exportCsvBtn').onclick = () => {
    if (!grid || !grid.T) {
      alert('No simulation data to export. Setup grid and solve first.');
      return;
    }
    
    const { nx, ny, dx, dy, widthM, heightM, T } = grid;
    
    // Create CSV header
    let csv = 'X (m),Y (m),Temperature (Â°C)\n';
    
    // Add data rows
    for (let j = 0; j < ny; j++) {
      for (let i = 0; i < nx; i++) {
        const idx = j * nx + i;
        const x = (i + 0.5) * dx;
        const y = (j + 0.5) * dy;
        const temp = T[idx];
        csv += `${x.toFixed(6)},${y.toFixed(6)},${temp.toFixed(4)}\n`;
      }
    }
    
    // Download CSV
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `heatsink_temperature_${getTimestamp()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // 4. EXPORT ZIP BUTTON (CSV + Images)
  document.getElementById('exportZipBtn').onclick = async () => {
    if (!grid || !grid.T) {
      alert('No simulation data to export. Setup grid and solve first.');
      return;
    }
    
    if (typeof JSZip === 'undefined') {
      alert('JSZip library not loaded. Please refresh the page.');
      return;
    }
    
    const zip = new JSZip();
    const timestamp = getTimestamp();
    
    // 1. Add CSV file
    const { nx, ny, dx, dy, widthM, heightM, T } = grid;
    let csv = 'X (m),Y (m),Temperature (Â°C)\n';
    for (let j = 0; j < ny; j++) {
      for (let i = 0; i < nx; i++) {
        const idx = j * nx + i;
        const x = (i + 0.5) * dx;
        const y = (j + 0.5) * dy;
        const temp = T[idx];
        csv += `${x.toFixed(6)},${y.toFixed(6)},${temp.toFixed(4)}\n`;
      }
    }
    zip.file(`temperature_data_${timestamp}.csv`, csv);
    
    // 2. Add heat map image (current canvas)
    const heatmapDataUrl = cv.toDataURL('image/png');
    const heatmapBase64 = heatmapDataUrl.split(',')[1];
    zip.file(`heatmap_${timestamp}.png`, heatmapBase64, { base64: true });
    
    // 3. Add heat map without grid overlay
    const gridWasChecked = showGrid.checked;
    showGrid.checked = false;
    draw();
    const cleanHeatmapDataUrl = cv.toDataURL('image/png');
    const cleanHeatmapBase64 = cleanHeatmapDataUrl.split(',')[1];
    zip.file(`heatmap_clean_${timestamp}.png`, cleanHeatmapBase64, { base64: true });
    
    // Restore grid state
    showGrid.checked = gridWasChecked;
    draw();
    
    // 4. Add configuration JSON
    const config = {
      timestamp: new Date().toISOString(),
      moduleType: 'vertical_plate_heatsink',
      geometry: {
        widthM: +widthM.value,
        heightM: +heightM.value,
        thicknessM: +thicknessM.value,
        material: material.value
      },
      simulation: {
        ambientT: +ambientT.value,
        nx: +nx.value,
        showGrid: showGrid.checked
      },
      results: {
        h_convective: grid.h.toFixed(2) + ' W/mÂ²K',
        area_m2: (widthM * heightM).toFixed(6),
        total_power_W: sources.reduce((s, x) => s + x.W, 0).toFixed(2),
        avg_temp_C: avg(grid.T).toFixed(2),
        max_temp_C: Math.max(...grid.T).toFixed(2),
        energy_residual_percent: (energyResidual() * 100).toFixed(2)
      },
      sources: sources.map(s => ({
        rect: s.rect,
        W: s.W
      }))
    };
    zip.file(`config_${timestamp}.json`, JSON.stringify(config, null, 2));
    
    // 5. Add README
    const readme = `Heat Sink Simulation Export
Generated: ${new Date().toLocaleString()}

Contents:
- temperature_data_${timestamp}.csv: Temperature field data (X, Y, Temperature)
- heatmap_${timestamp}.png: Heat map visualization with grid
- heatmap_clean_${timestamp}.png: Heat map visualization without grid overlay
- config_${timestamp}.json: Complete simulation configuration and results

Simulation Parameters:
- Plate dimensions: ${widthM.value} m Ã— ${heightM.value} m Ã— ${thicknessM.value} m
- Material: ${material.value}
- Grid resolution: ${nx} Ã— ${ny} cells
- Ambient temperature: ${ambientT.value} Â°C
- Number of heat sources: ${sources.length}
- Total power: ${sources.reduce((s, x) => s + x.W, 0).toFixed(2)} W

Results:
- Convective coefficient h: ${grid.h.toFixed(2)} W/mÂ²K
- Average temperature: ${avg(grid.T).toFixed(2)} Â°C
- Maximum temperature: ${Math.max(...grid.T).toFixed(2)} Â°C
- Energy balance residual: ${(energyResidual() * 100).toFixed(2)}%
`;
    zip.file('README.txt', readme);
    
    // Generate and download ZIP
    try {
      const content = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(content);
      const a = document.createElement('a');
      a.href = url;
      a.download = `heatsink_export_${timestamp}.zip`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (err) {
      alert('Error creating ZIP file: ' + err.message);
    }
  };


 </script>
</body>
</html>

















