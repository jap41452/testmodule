<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Base Shake — Random PSD</title>
  <style>
    :root{
      --panel-w:320px; --panel-h:620px;
      --ink:#111; --muted:#666; --accent:#0b73c8; --border:#d9d9d9; --panel:#f7f7f7;
      --radius:14px; --gap:12px; --pad:14px; --input-h:38px; --seg-h:48px;
    }
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    body{margin:0;background:#f3f4f6;color:var(--ink)}
    .wrap{display:flex;align-items:flex-start;gap:18px;flex-wrap:nowrap;overflow-x:auto;padding:16px}
    .panel{width:var(--panel-w);min-width:var(--panel-w);height:var(--panel-h);background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);padding:var(--pad);box-shadow:0 6px 24px rgba(0,0,0,.06);display:flex;flex-direction:column;flex-shrink:0}
    .wrap > div:not(.panel){flex:1 1 560px;min-width:560px}
    h2{margin:0 0 18px;font-size:18px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:var(--gap)}
    .row{display:contents}
    label{font-size:12px;color:var(--muted);display:block;margin-bottom:10px}
    .input,.seg{border:1px solid var(--border);border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;padding:0 10px}
    .input{height:var(--input-h)}
    .input input,.input select,.input textarea{width:100%;height:100%;border:0;outline:0;background:transparent;font-size:14px;color:var(--ink)}
    .input.readonly{background:#f0f2f5}
    .input.readonly input{color:#666;pointer-events:none}
    .colspan-2{grid-column:1 / span 2}
    .btn{border:1px solid var(--border);background:#fff;border-radius:10px;height:40px;cursor:pointer;width:100%;font-size:14px}
    .btn.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
    .btn.primary:hover{filter:brightness(1.05)}
    .btn.sm{height:32px;padding:0 10px;border-radius:8px}
    .btnbar{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .dropdown{border:1px solid var(--border);border-radius:10px;background:#fff;padding:10px;margin-top:10px}
    #view{width:500px;height:400px;background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06)}
    .toolbar{display:flex;align-items:center;gap:6px;margin-bottom:6px}
    .toolbar button{border:1px solid var(--border);background:#fff;border-radius:8px;padding:4px 8px;cursor:pointer}
    .toolbar label{font:12px system-ui;color:#444}
    .readout{font:12px system-ui;color:#333;margin:4px 0 0 0}
    .toast{position:fixed;left:16px;bottom:16px;max-width:60ch;background:#111;color:#fff;padding:10px 12px;border-radius:10px;box-shadow:0 6px 24px rgba(0,0,0,.2);opacity:0;transform:translateY(8px);transition:opacity .2s ease, transform .2s ease;pointer-events:none;font:13px system-ui}
    .toast.show{opacity:0.95;transform:translateY(0)}
    #exportBtns{display:flex;gap:8px;margin:8px 0 16px}
    #exportBtns .btn{width:120px}
    #view,#accelPlot,#springPlot,#psdPlot{max-width:100%;height:auto}
    @media (max-width:980px){.wrap{flex-wrap:wrap}.wrap > div:not(.panel){min-width:100%;flex-basis:100%}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel" role="region" aria-label="Random PSD control panel">
      <h2>Random PSD</h2>
      <div class="grid">
        <div class="row">
          <div><label for="weight">Weight</label><div class="input"><input id="weight" type="number" value="100" /></div></div>
          <div><label for="mass">Mass</label><div class="input readonly"><input id="mass" type="text" readonly /></div></div>
        </div>
        <div class="row">
          <div><label for="lx">Lx (width)</label><div class="input"><input id="lx" type="number" value="12" /></div></div>
          <div><label for="ly">Ly (length)</label><div class="input"><input id="ly" type="number" value="6" /></div></div>
        </div>
        <div class="row">
          <div><label for="lz">Lz (height)</label><div class="input"><input id="lz" type="number" value="3" /></div></div>
        </div>
        <div class="row">
          <div><label for="k00">Spring k (0,0)</label><div class="input"><input id="k00" type="number" value="100" /></div></div>
          <div><label for="kLx0">Spring k (Lx,0)</label><div class="input"><input id="kLx0" type="number" value="200" /></div></div>
        </div>
        <div class="row">
          <div><label for="k0Ly">Spring k (0,Ly)</label><div class="input"><input id="k0Ly" type="number" value="300" /></div></div>
          <div><label for="kLxLy">Spring k (Lx,Ly)</label><div class="input"><input id="kLxLy" type="number" value="400" /></div></div>
        </div>
        <div class="row">
          <div><label for="damping">Critical damping, %</label><div class="input"><input id="damping" type="number" value="10" /></div></div>
          <div><label for="gval">Gravity, G</label><div class="input readonly"><input id="gval" type="text" value="386.09 in/s²" readonly /></div></div>
        </div>

        <div class="colspan-2">
          <div class="dropdown" id="psdPanel">
            <div class="grid" style="grid-template-columns:1fr 1fr; gap:12px;">
              <div class="colspan-2">
                <label for="psdSpec">PSD points (one-sided, G²/Hz) — “f, S” per line</label>
                <div class="input" style="height:auto;padding:0;">
<textarea id="psdSpec" style="width:100%;height:110px;border:0;outline:0;resize:vertical;padding:8px;font:12px/1.3 system-ui;">5, 1e-4
20, 1e-3
80, 6e-4
200, 1e-4</textarea>
                </div>
              </div>
              <div>
                <label for="psdFs">Sample rate, Hz</label>
                <div class="input"><input id="psdFs" type="number" step="any" value="1000"></div>
              </div>
              <div>
                <label for="psdDur">Duration, s</label>
                <div class="input"><input id="psdDur" type="number" step="any" value="20"></div>
              </div>
              <div>
                <label for="psdSeed">Random seed</label>
                <div class="input"><input id="psdSeed" type="number" step="1" value="42"></div>
              </div>
              <div>
                <label for="psdTaper">Taper (Tukey), %</label>
                <div class="input"><input id="psdTaper" type="number" step="1" value="2"></div>
              </div>
              <div class="colspan-2 btnbar">
                <button id="psdMake" class="btn">Generate Time History</button>
                <button id="simulateBtn" class="btn primary">Simulate</button>
              </div>
              <div class="colspan-2">
                <div id="psdInfo" class="readout">—</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="maxAccelPanel" class="dropdown" style="margin-top:10px; padding:10px;">
        <div style="font-weight:600; margin-bottom:6px;">Max |Acceleration| (G)</div>
        <div id="maxCenter" class="readout">Center: —</div>
        <div id="maxC00" class="readout">(0,0): —</div>
        <div id="maxCLx0" class="readout">(Lx,0): —</div>
        <div id="maxC0Ly" class="readout">(0,Ly): —</div>
        <div id="maxCLxLy" class="readout">(Lx,Ly): —</div>
      </div>
    </div>

    <div>
      <div class="toolbar">
        <label for="respScale">Response scale</label>
        <input id="respScale" type="range" min="0" max="10" step="0.1" value="1" style="width:125px;">
        <label for="simSpeed">Speed</label>
        <input id="simSpeed" type="range" min="0" max="4" step="0.05" value="1" style="width:125px;">
        <button id="resetView">Reset View</button>
      </div>


<div id="exportBtns">
  <button id="exportJSON" class="btn sm">Export JSON</button>
  <button id="importJSON" class="btn sm">Import JSON</button>
  <button id="exportCSV" class="btn sm">Export CSV</button>
</div>


      <canvas id="view" width="500" height="400"></canvas>

      <div id="plots" style="margin-top:12px; display:grid; grid-template-columns:1fr; gap:12px; width:500px;">
        <canvas id="accelPlot"  width="500" height="220" style="background:#fff;border:1px solid #d9d9d9;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06)"></canvas>
        <canvas id="springPlot" width="500" height="220" style="background:#fff;border:1px solid #d9d9d9;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06)"></canvas>
        <canvas id="psdPlot"    width="500" height="220" style="background:#fff;border:1px solid #d9d9d9;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.06)"></canvas>
        <div id="readout" class="readout"></div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
  (function(){
    const lx=document.getElementById('lx'), ly=document.getElementById('ly'), lz=document.getElementById('lz');
    const k00=document.getElementById('k00'), kLx0=document.getElementById('kLx0'), k0Ly=document.getElementById('k0Ly'), kLxLy=document.getElementById('kLxLy');
    const canvas=document.getElementById('view'); const ctx=canvas.getContext('2d');
    const resetBtn=document.getElementById('resetView');
    const simSpeed=document.getElementById('simSpeed');
    const respScaleEl=document.getElementById('respScale');

    const weightEl=document.getElementById('weight'); const massEl=document.getElementById('mass'); const gEl=document.getElementById('gval');

const exportJSONBtn = document.getElementById('exportJSON');
const importJSONBtn = document.getElementById('importJSON');
const exportCSVBtn  = document.getElementById('exportCSV');
const simulateBtn   = document.getElementById('simulateBtn');
const psdMake       = document.getElementById('psdMake');
    const accelPlot = document.getElementById('accelPlot');
    const springPlot = document.getElementById('springPlot');
    const psdPlot   = document.getElementById('psdPlot');
    const accelPlotCtx = accelPlot.getContext('2d');
    const springPlotCtx = springPlot.getContext('2d');
    const psdPlotCtx = psdPlot.getContext('2d');
    const readoutEl = document.getElementById('readout');

    const maxCenterEl = document.getElementById('maxCenter');
    const maxC00El    = document.getElementById('maxC00');
    const maxCLx0El   = document.getElementById('maxCLx0');
    const maxC0LyEl   = document.getElementById('maxC0Ly');
    const maxCLxLyEl  = document.getElementById('maxCLxLy');

    const psdPanel = document.getElementById('psdPanel');
    const psdSpec  = document.getElementById('psdSpec');
    const psdFs    = document.getElementById('psdFs');
    const psdDur   = document.getElementById('psdDur');
    const psdSeed  = document.getElementById('psdSeed');
    const psdTaper = document.getElementById('psdTaper');
    const psdInfo  = document.getElementById('psdInfo');

    const toastEl=document.getElementById('toast');
    let toastTimer=null;
    function showToast(msg){
      toastEl.textContent=msg; toastEl.classList.add('show');
      clearTimeout(toastTimer); toastTimer=setTimeout(()=>toastEl.classList.remove('show'), 2000);
    }

    let unitMode='US';
    const g=function(){ return 386.09; };
    function computeMass(){ const W=parseFloat(weightEl.value); massEl.value = Number.isFinite(W) ? Number((W/g()).toPrecision(6)).toString() : ''; }
    weightEl.addEventListener('input', computeMass);

    function vals(){
      return {
        Lx:parseFloat(lx.value)||12,
        Ly:parseFloat(ly.value)||6,
        Lz:parseFloat(lz.value)||3,
        K:[parseFloat(k00.value)||100, parseFloat(kLx0.value)||200, parseFloat(k0Ly.value)||300, parseFloat(kLxLy.value)||400]
      };
    }

    let yaw=0.8, pitch=-1.0; let baseScale=30, zoom=1.5, scale=30; let panX=-100, panY=125;
    function fitScale(){
      const v=vals();
      const maxDim=Math.max(v.Lx,v.Ly,v.Lz,1);
      baseScale=Math.min(canvas.width,canvas.height)*0.375/maxDim;
      scale=baseScale*zoom;
    }
    function project(arr){
      const x=arr[0], y=arr[1], z=arr[2];
      const cz=Math.cos(yaw), sz=Math.sin(yaw); let nx=x*cz-y*sz, ny=x*sz+y*cz, nz=z;
      const cx=Math.cos(pitch), sx=Math.sin(pitch); let ny2=ny*cx-nz*sx;
      const px=canvas.width*0.5 + panX + scale*nx;
      const py=canvas.height*0.5 + panY - scale*ny2;
      return [px,py];
    }
    function kStroke(K,val){ const pos=K.filter(function(v){return v>0;}); if(!pos.length) return 2; const kmin=Math.min.apply(null,pos), kmax=Math.max.apply(null,pos); if(kmax===kmin) return 4; const t=(val-kmin)/(kmax-kmin); return 1+2*t; }

    function drawSpringSymbol(x,y,z0,z1,stroke,color,Lz){
      ctx.strokeStyle=color; ctx.lineWidth=stroke; ctx.lineCap='round';
      const pA=project([x,y,z0]), pB=project([x,y,z1]); ctx.beginPath(); ctx.moveTo(pA[0],pA[1]); ctx.lineTo(pB[0],pB[1]); ctx.stroke();
      const ticks=3, startT=0.25, endT=0.65, len=0.20*Lz;
      for(let i=0;i<ticks;i++){
        const t=startT+(endT-startT)*i/(ticks-1), z=z0+(z1-z0)*t;
        const p1=project([x-0.5*len,y,z]), p2=project([x+0.5*len,y,z]);
        ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke();
      }
      ctx.fillStyle=color; const pb=project([x,y,z0]); ctx.beginPath(); ctx.arc(pb[0],pb[1],Math.max(3,stroke*0.6),0,Math.PI*2); ctx.fill();
    }

    function drawBaseBox(Lx,Ly,Lz){
      const z0=0, z1=-0.25*Lz;
      const V=[[0,0,z0],[Lx,0,z0],[Lx,Ly,z0],[0,Ly,z0],[0,0,z1],[Lx,0,z1],[Lx,Ly,z1],[0,Ly,z1]];
      const faces=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]];
      ctx.fillStyle='rgba(0,0,0,0.75)';
      faces.forEach(function(f){ ctx.beginPath(); const p0=project(V[f[0]]); ctx.moveTo(p0[0],p0[1]); for(let i=1;i<f.length;i++){ const p=project(V[f[i]]); ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill(); });
      const E=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.lineJoin='round';
      E.forEach(function(e){ const a=e[0], b=e[1]; const p1=project(V[a]), p2=project(V[b]); ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); });
    }

    function drawTopRigid(zRel,thx,thy,Lx,Ly,Lz,scaleGain){
      const z = zRel * scaleGain, thxV = thx * scaleGain, thyV = thy * scaleGain;
      const Vlocal=[[0,0,0],[Lx,0,0],[Lx,Ly,0],[0,Ly,0],[0,0,Lz],[Lx,0,Lz],[Lx,Ly,Lz],[0,Ly,Lz]];
      const cx=Lx/2, cy=Ly/2; const cY=Math.cos(thyV), sY=Math.sin(thyV); const cX=Math.cos(thxV), sX=Math.sin(thxV);
      function rotV(v){ const x=v[0], y=v[1], z0=v[2]; let X=x-cx, Y=y-cy, Z=z0; let X1= X*cY + Z*sY; let Y1= Y; let Z1=-X*sY + Z*cY; let X2= X1; let Y2= Y1*cX - Z1*sX; let Z2= Y1*sX + Z1*cX; return [X2+cx, Y2+cy, Z2+z]; }
      const V=Vlocal.map(rotV);
      const faces=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]];
      ctx.fillStyle='rgba(200,200,200,0.5)';
      faces.forEach(function(f){ ctx.beginPath(); const p0=project(V[f[0]]); ctx.moveTo(p0[0],p0[1]); for(let i=1;i<f.length;i++){ const p=project(V[f[i]]); ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill(); });
      const E=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.lineJoin='round';
      E.forEach(function(e){ const a=e[0], b=e[1]; const p1=project(V[a]), p2=project(V[b]); ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); });
      drawTopRigid.lowerCorners=[V[0],V[1],V[2],V[3]]; drawTopRigid.upperCorners=[V[4],V[5],V[6],V[7]];
    }

    function drawWaveformPreview(){
      const pad=12, w=210, h=150; const x0=canvas.width - w - pad, y0=pad;
      ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.strokeStyle='#bbb'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.rect(x0,y0,w,h); ctx.fill(); ctx.stroke();

      ctx.fillStyle='#111'; ctx.font='12px system-ui'; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.fillText("Random PSD: a(G) vs t(s)", x0+10, y0+18);

      const gx=x0+36, gy=y0+28, gw=w-46, gh=h-92;
      ctx.strokeStyle='#ddd'; ctx.strokeRect(gx,gy,gw,gh);

      let tarr = randPSD_t, yarr = randPSD_y;
      if (!tarr || !yarr || tarr.length<2){
        ctx.fillStyle='#666'; ctx.fillText("Generate time history to preview", gx, gy+gh/2);
        return;
      }
      const tmax = Math.max(1, Math.min(tarr[tarr.length-1], 2));
      let idxEnd = 1; while(idxEnd < tarr.length && tarr[idxEnd] < tmax) idxEnd++;
      const t = Array.prototype.slice.call(tarr,0,idxEnd);
      const y = Array.prototype.slice.call(yarr,0,idxEnd);

      const tmin= t[0], tmx = t[t.length-1];
      let ymin=0, ymax=0;
      for (let i=0;i<y.length;i++){ ymin=Math.min(ymin,y[i]); ymax=Math.max(ymax,y[i]); }
      if (ymax - ymin < 1e-9){ ymax = ymin + 1; }

      ctx.fillStyle='#444'; ctx.textAlign='right'; ctx.textBaseline='alphabetic';
      ctx.fillText(tmx.toPrecision(3), gx+gw-2, gy+gh+14);
      ctx.textAlign='left'; ctx.fillText("t (s)", gx+gw-74, gy+gh+14);
      ctx.save(); ctx.translate(gx-22, gy+58); ctx.rotate(-Math.PI/2); ctx.textAlign='left'; ctx.textBaseline='alphabetic'; ctx.fillText("a (G)", 0,0); ctx.restore();
      ctx.textAlign='right'; ctx.textBaseline='top'; ctx.fillText(ymax.toPrecision(3), gx-6, gy-2);

      ctx.beginPath();
      for(let i=0;i<t.length;i++){
        const px = gx + (t[i]-tmin)/(tmx-tmin || 1)*gw;
        const py = gy + gh - (y[i]-ymin)/(ymax-ymin || 1)*gh;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.strokeStyle='#0b73c8'; ctx.lineWidth=2; ctx.stroke();
    }

    function parsePSDTextarea(){
      const pts=[];
      (psdSpec.value||'').split('\n').forEach(function(line){
        const m=line.trim().match(/^([^,#]+)\s*[, ]\s*([^,#]+)$/);
        if(m){
          const f=+m[1], S=+m[2];
          if(isFinite(f)&&f>0&&isFinite(S)&&S>0) pts.push({f:f,S:S});
        }
      });
      pts.sort(function(a,b){return a.f-b.f;});
      return pts;
    }

    function renderPSDPlot(pts){
      const ctx = psdPlotCtx, W=ctx.canvas.width, H=ctx.canvas.height;
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillRect(0,0,W,H);
      ctx.strokeStyle='#bbb'; ctx.strokeRect(0,0,W,H);
      ctx.fillStyle='#111'; ctx.font='12px system-ui';
      ctx.fillText("Input PSD (G²/Hz) vs frequency (Hz) — log–log", 10, 16);

      const padL=70, padR=12, padT=24, padB=28;
      const gx=padL, gy=padT, gw=W-padL-padR, gh=H-padT-padB;
      ctx.strokeStyle='#ddd'; ctx.strokeRect(gx,gy,gw,gh);

      if(!pts || pts.length<2){
        ctx.fillStyle='#666'; ctx.fillText("Enter ≥2 points to plot", gx+8, gy+gh/2);
        return;
      }

      const fmin = Math.min.apply(null, pts.map(function(p){return p.f;}));
      const fmax = Math.max.apply(null, pts.map(function(p){return p.f;}));
      const smin = Math.min.apply(null, pts.map(function(p){return p.S;}));
      const smax = Math.max.apply(null, pts.map(function(p){return p.S;}));
      const lfmin=Math.log10(fmin), lfmax=Math.log10(fmax);
      const lsmin=Math.log10(smin), lsmax=Math.log10(smax);

      function xOf(f){ return gx + ( (Math.log10(f)-lfmin)/(lfmax-lfmin||1) )*gw; }
      function yOf(S){ return gy + gh - ( (Math.log10(S)-lsmin)/(lsmax-lsmin||1) )*gh; }

      ctx.fillStyle='#444'; ctx.textAlign='center'; ctx.textBaseline='top';
      for(let d=Math.pow(10,Math.floor(lfmin)); d<=Math.pow(10,Math.ceil(lfmax))+1e-9; d*=10){
        const xx=xOf(d); ctx.fillText(d.toPrecision(1), xx, gy+gh+6);
        for(let m=2;m<10;m++){
          const ff=d*m; if(ff>=fmin && ff<=fmax){
            const xm=xOf(ff); ctx.strokeStyle='#eee'; ctx.beginPath(); ctx.moveTo(xm,gy); ctx.lineTo(xm,gy+gh); ctx.stroke();
          }
        }
      }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      for(let d=Math.pow(10,Math.floor(lsmin)); d<=Math.pow(10,Math.ceil(lsmax))+1e-30; d*=10){
        const yy=yOf(d); ctx.fillText(d.toExponential(0), gx-6, yy);
      }

      ctx.beginPath();
      for(let i=0;i<pts.length;i++){
        const px=xOf(pts[i].f), py=yOf(pts[i].S);
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.strokeStyle='#0b73c8'; ctx.lineWidth=2; ctx.stroke();

      ctx.fillStyle='#444'; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.fillText('Frequency (Hz, log)', gx+gw-120, gy+gh+20);
      ctx.save(); ctx.translate(gx-44, gy+80); ctx.rotate(-Math.PI/2);
      ctx.fillText('PSD (G²/Hz, log)', 0, 0); ctx.restore();
    }
    psdSpec.addEventListener('input', function(){renderPSDPlot(parsePSDTextarea());});

    function generateTimeHistoryFromPSD(psdPoints, fs, duration, seed, opts) {
      seed = (typeof seed==='number') ? seed : 12345;
      opts = opts || {};
      if (!Array.isArray(psdPoints) || psdPoints.length < 2) {
        throw new Error("psdPoints must be an array of {f,S} with length >= 2");
      }
      const taperFrac = Math.max(0, Math.min(0.2, (opts.taper != null ? opts.taper : 0.02)));
      const keepMean = !!opts.keepMean;
      function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
      const rand = mulberry32((seed|0) || 1);

      const pts = psdPoints
        .map(function(p){ return { f: +p.f, S: Math.max(+p.S, 1e-30) }; })
        .filter(function(p){ return Number.isFinite(p.f) && Number.isFinite(p.S) && p.f > 0; })
        .sort(function(a,b){ return a.f - b.f; });

      const fminSpec = pts[0].f;
      const fmaxSpec = pts[pts.length-1].f;

      const log10 = function(x){ return Math.log(x) / Math.LN10; };
      const segs = [];
      for (let i=0;i<pts.length-1;i++){
        const f1 = pts[i].f, f2 = pts[i+1].f;
        const s1 = pts[i].S, s2 = pts[i+1].S;
        const Lf1 = log10(f1), Lf2 = log10(f2);
        const Ls1 = log10(Math.max(s1,1e-30)), Ls2 = log10(Math.max(s2,1e-30));
        const m = (Ls2 - Ls1) / (Lf2 - Lf1);
        const b = Ls1 - m * Lf1;
        segs.push({ f1:f1, f2:f2, m:m, b:b });
      }
      function Sof(f){
        if (f <= fminSpec || f >= fmaxSpec) return 0;
        for (let i=0;i<segs.length;i++){
          const s=segs[i];
          if (f >= s.f1 && f <= s.f2){
            const Ls = s.m * log10(f) + s.b;
            return Math.max(1e-30, Math.pow(10, Ls));
          }
        }
        return 0;
      }

      const N = Math.max(2, Math.floor(fs * duration));
      const dt = 1 / fs;
      const t = new Float64Array(N);
      for (let n=0;n<N;n++) t[n] = n*dt;

      const df = fs / N;
      const fNy = fs/2;
      const fstart = Math.max(df, fminSpec);
      const fend   = Math.min(fNy - df*1e-9, fmaxSpec);
      if (fstart >= fend) {
        return { t: t, y: new Float64Array(N), phases: new Float64Array(0), info: { fmin:0, fmax:0, df:df, N:N } };
      }
      const K = Math.max(1, Math.floor((fend - fstart)/df) + 1);
      const freq = new Float64Array(K);
      for (let k=0;k<K;k++) freq[k] = fstart + k*df;

      const A = new Float64Array(K);
      for (let k=0;k<K;k++) A[k] = Math.sqrt(2 * Sof(freq[k]) * df);

      const phases = new Float64Array(K);
      for (let k=0;k<K;k++) phases[k] = 2*Math.PI*rand();

      const y = new Float64Array(N);
      for (let k=0;k<K;k++){
        const w = 2*Math.PI*freq[k];
        const Ak = A[k];
        const ph = phases[k];
        for (let n=0;n<N;n++){
          y[n] += Ak * Math.cos(w*t[n] + ph);
        }
      }

      if (!keepMean){
        let mean = 0;
        for (let n=0;n<N;n++) mean += y[n];
        mean /= N;
        for (let n=0;n<N;n++) y[n] -= mean;
      }

      if (taperFrac > 0){
        const alpha = Math.max(0, Math.min(1, taperFrac*2));
        for (let n=0;n<N;n++){
          const r = n/(N-1);
          let w;
          if (r < alpha/2){
            w = 0.5 * (1 + Math.cos(Math.PI*(2*r/alpha - 1)));
          } else if (r <= 1 - alpha/2){
            w = 1;
          } else {
            w = 0.5 * (1 + Math.cos(Math.PI*(2*r/alpha - 2/alpha + 1)));
          }
          y[n] *= w;
        }
      }
      return { t: t, y: y, phases: phases, info: { fmin:fstart, fmax:fend, df:df, N:N } };
    }

    let randPSD_lookup = null;
    let randPSD_t = null, randPSD_y = null;

    document.getElementById('psdMake').addEventListener('click', function(){
      try{
        const pts = parsePSDTextarea();
        if (pts.length < 2){ showToast('Add at least two PSD points'); return; }

        const fs   = Math.max(1, parseFloat(psdFs.value) || 1000);
        const dur  = Math.max(0.1, parseFloat(psdDur.value) || 20);
        const seed = Math.floor(parseFloat(psdSeed.value) || 42);
        const taperPct = Math.max(0, Math.min(20, parseFloat(psdTaper.value) || 2));

        const out = generateTimeHistoryFromPSD(pts, fs, dur, seed, { taper: taperPct/100 });
        const t = out.t, y = out.y, info = out.info;

        randPSD_t = t; randPSD_y = y;
        randPSD_lookup = makeTimeHistoryLookup(t, y);

        let rms = 0; for (let i=0;i<y.length;i++) rms += y[i]*y[i]; rms = Math.sqrt(rms / y.length);
        psdInfo.textContent = 'Generated: N='+t.length+', Δt='+(1/fs).toPrecision(3)+' s, f∈['+info.fmin.toPrecision(3)+', '+info.fmax.toPrecision(3)+'] Hz, RMS≈'+rms.toPrecision(3)+' g';
        showToast('Random PSD time history ready');

        renderPSDPlot(pts);
        draw();
      } catch(e){
        console.error(e);
        showToast('PSD generation error — check console');
      }
    });

    function makeTimeHistoryLookup(t, y){
      const N = t.length;
      return function a_of(tq){
        if (tq <= t[0]) return y[0];
        if (tq >= t[N-1]) return y[N-1];
        let lo=0, hi=N-1;
        while(hi - lo > 1){
          const mid = (lo + hi) >> 1;
          if (t[mid] <= tq) lo = mid; else hi = mid;
        }
        const a = (tq - t[lo]) / (t[hi] - t[lo] || 1);
        return y[lo] + a * (y[hi] - y[lo]);
      };
    }

    function cornersAboutCOM(Lx, Ly){ const hx=Lx/2, hy=Ly/2; return [[-hx,-hy],[hx,-hy],[-hx,hy],[hx,hy]]; }

    function makeDynamics(){
      const W=parseFloat(weightEl.value)||0; const mTop=W/g();
      const v=vals(); const Lx=v.Lx, Ly=v.Ly, Lz=v.Lz; const K=v.K;
      const k00v=K[0], kLx0v=K[1], k0Lyv=K[2], kLxLyv=K[3]; const mBase=100*mTop;
      const Ix=(mTop/12)*(Ly*Ly+Lz*Lz); const Iy=(mTop/12)*(Lx*Lx+Lz*Lz);

      const zeta=((parseFloat(document.getElementById('damping').value)||0)/100);
      const m_eq=mTop/4;
      const c00=2*zeta*Math.sqrt(Math.max(k00v,0)*m_eq);
      const cLx0=2*zeta*Math.sqrt(Math.max(kLx0v,0)*m_eq);
      const c0Ly=2*zeta*Math.sqrt(Math.max(k0Lyv,0)*m_eq);
      const cLxLy=2*zeta*Math.sqrt(Math.max(kLxLyv,0)*m_eq);
      const Cspr=[c00,cLx0,c0Ly,cLxLy];
      const kList=[k00v,kLx0v,k0Lyv,kLxLyv];
      const corners=cornersAboutCOM(Lx,Ly);

      const kAvg=(k00v+kLx0v+k0Lyv+kLxLyv)/4;
      const kGround=0.1*kAvg;
      const cGround=2*zeta*Math.sqrt(Math.max(kGround,0)*mBase);

      return function f(t,y){
        const z=y[0], thx=y[1], thy=y[2], vz=y[3], wx=y[4], wy=y[5], zb=y[6], vb=y[7];

        const dispTop=new Array(4), velTop=new Array(4);
        for(let i=0;i<4;i++){
          const xi=corners[i][0], yi=corners[i][1];
          dispTop[i]= z + (-thx*yi) + (thy*xi);
          velTop[i] = vz + (-wx *yi) + (wy *xi);
        }

        const ab = (typeof randPSD_lookup === 'function' ? randPSD_lookup(t) : 0) * g();

        const Fi=new Array(4);
        for(let i=0;i<4;i++){
          const rel=dispTop[i]-zb;
          const relv=velTop[i]-vb;
          Fi[i]= -(kList[i]*rel + Cspr[i]*relv);
        }

        let Fz=0, TauX=0, TauY=0;
        for(let i=0;i<4;i++){
          const xi=corners[i][0], yi=corners[i][1], F=Fi[i];
          Fz+=F; TauX+=(-yi)*F; TauY+=(xi)*F;
        }

        const az  = (mTop > 0) ? (Fz / mTop) : 0;
        const awx = (Ix   > 0) ? (TauX / Ix) : 0;
        const awy = (Iy   > 0) ? (TauY / Iy) : 0;

        const Fg  = -kGround * zb - cGround * vb;
        const dzb = vb;
        const dvb = (mBase > 0) ? (ab + (-Fz + Fg) / mBase) : ab;

        return new Float64Array([ vz, wx, wy,  az, awx, awy,  dzb, dvb ]);
      };
    }

    function rkf45Integrate(f, t0, y0, tEnd, dtInit, rtol, atol) {
      dtInit = (dtInit!=null)?dtInit:0.0001; rtol = (rtol!=null)?rtol:.5e-5; atol=(atol!=null)?atol:1e-8;
      const a2=1/5,a3=3/10,a4=3/5,a5=1,a6=7/8;
      const b21=1/5; const b31=3/40,b32=9/40; const b41=3/10,b42=-9/10,b43=6/5;
      const b51=-11/54,b52=5/2,b53=-70/27,b54=35/27;
      const b61=1631/55296,b62=175/512,b63=575/13824,b64=44275/110592,b65=253/4096;
      const c1=37/378,c3=250/621,c4=125/594,c6=512/1771;
      const c1s=2825/27648,c3s=18575/48384,c4s=13525/55296,c5s=277/14336,c6s=1/4;

      const n = y0.length;
      let t = t0, y = Float64Array.from(y0);
      let h = Math.max(1e-6, Math.min(dtInit, Math.max(1e-6, tEnd - t0)));
      const hMin = 1e-8;
      const outT = [t], outY = [Array.from(y)];
      let rejectStreak = 0, steps = 0;
      const MAX_STEPS = 400000;

      function add(a,b){ const r=new Float64Array(a.length); for(let i=0;i<a.length;i++) r[i]=a[i]+b[i]; return r; }
      function scaleVec(a,s){ const r=new Float64Array(a.length); for(let i=0;i<a.length;i++) r[i]=a[i]*s; return r; }
      function scaledErr(y5,y4,yCur){
        let s=0;
        for(let i=0;i<n;i++){
          const denom = atol + rtol * Math.max(Math.abs(yCur[i]), Math.abs(y5[i]));
          const d = (y5[i] - y4[i]) / (denom || 1e-16);
          if (!Number.isFinite(d)) return Number.POSITIVE_INFINITY;
          s += d*d;
        }
        return Math.sqrt(s / n);
      }

      while (t < tEnd) {
        if (++steps > MAX_STEPS) break;
        if (t + h > tEnd) h = tEnd - t;

        const k1=f(t,y);
        const k2=f(t+a2*h, add(y, scaleVec(k1,h*b21)));
        const k3=f(t+a3*h, add(y, add(scaleVec(k1,h*b31), scaleVec(k2,h*b32))));
        const k4=f(t+a4*h, add(y, add(add(scaleVec(k1,h*b41), scaleVec(k2,h*b42)), scaleVec(k3,h*b43))));
        const k5=f(t+a5*h, add(y, add(add(add(scaleVec(k1,h*b51), scaleVec(k2,h*b52)), scaleVec(k3,h*b53)), scaleVec(k4,h*b54))));
        const k6=f(t+a6*h, add(y, add(add(add(add(scaleVec(k1,h*b61), scaleVec(k2,h%b62)), scaleVec(k3,h*b63)), scaleVec(k4,h*b64)), scaleVec(k5,h*b65))));

        const y5=add(y, add(add(add(scaleVec(k1,h*c1), scaleVec(k3,h*c3)), scaleVec(k4,h*c4)), scaleVec(k6,h*c6)));
        const y4=add(y, add(add(add(add(scaleVec(k1,h*c1s), scaleVec(k3,h*c3s)), scaleVec(k4,h*c4s)), scaleVec(k5,h*c5s)), scaleVec(k6,h*c6s)));

        let err = scaledErr(y5,y4,y);
        if (!Number.isFinite(err)) err = Number.POSITIVE_INFINITY;

        if (err <= 1){
          t += h; y = y5; outT.push(t); outY.push(Array.from(y));
          let s = 0.9 * Math.pow(1/Math.max(err,1e-12), 0.2);
          s = Math.min(5, Math.max(0.2, s)); h = Math.max(hMin, h*s);
        } else {
          let s = 0.9 * Math.pow(1/Math.max(err,1e-12), 0.2);
          s = Math.min(1, Math.max(0.1, s)); h = Math.max(hMin, h*s);
        }
      }
      return { t: outT, y: outY };
    }

    let tSimNow=0, overlayVisible=true, simData=null, simStartWall=0, playing=false, currentY=null;
    let lastTimes=null, lastAzG=null, lastFseries=null, cursorTime=null;
    let maxCenterG=0, maxCornerG=[0,0,0,0];

    function resetMaxAccelPanel(){
      maxCenterG=0; maxCornerG=[0,0,0,0];
      maxCenterEl.textContent='Center: —';
      maxC00El.textContent='(0,0): —';
      maxCLx0El.textContent='(Lx,0): —';
      maxC0LyEl.textContent='(0,Ly): —';
      maxCLxLyEl.textContent='(Lx,Ly): —';
    }

    function responseAtSample(y) {
      const v=vals(); const Lx=v.Lx, Ly=v.Ly, K=v.K;
      const k00v=K[0],kLx0v=K[1],k0Lyv=K[2],kLxLyv=K[3];
      const W = +weightEl.value || 0; const mTop = W / g();
      const z=y[0], thx=y[1], thy=y[2], vz=y[3], wx=y[4], wy=y[5], zb=y[6], vb=y[7];
      const corners = (function(Lx, Ly){ const hx=Lx/2, hy=Ly/2; return [[-hx,-hy],[hx,-hy],[-hx,hy],[hx,hy]]; })(Lx, Ly);

      const zeta = ((+document.getElementById('damping').value || 0) / 100);
      const m_eq = mTop/4;
      const Cspr = [
        2*zeta*Math.sqrt(Math.max(k00v,0)*m_eq),
        2*zeta*Math.sqrt(Math.max(kLx0v,0)*m_eq),
        2*zeta*Math.sqrt(Math.max(k0Lyv,0)*m_eq),
        2*zeta*Math.sqrt(Math.max(kLxLyv,0)*m_eq),
      ];
      const kList = [k00v,kLx0v,k0Lyv,kLxLyv];

      const dispTop=new Array(4), velTop=new Array(4);
      for(let i=0;i<4;i++){
        const xi=corners[i][0], yi=corners[i][1];
        dispTop[i]= z + (-thx*yi) + (thy*xi);
        velTop[i] = vz + (-wx *yi) + (wy *xi);
      }

      const Fi = new Array(4);
      for (let i=0;i<4;i++){
        const rel = dispTop[i] - zb;
        const relv= velTop[i] - vb;
        Fi[i] = -(kList[i]*rel + Cspr[i]*relv);
      }

      const Fz = Fi.reduce(function(s,v){return s+v;},0);
      const TauX = (-corners[0][1])*Fi[0] + (-corners[1][1])*Fi[1] + (-corners[2][1])*Fi[2] + (-corners[3][1])*Fi[3];
      const TauY = ( corners[0][0])*Fi[0] + ( corners[1][0])*Fi[1] + ( corners[2][0])*Fi[2] + ( corners[3][0])*Fi[3];

      const Ix = (mTop/12) * (Ly*Ly + (+lz.value||3) * (+lz.value||3));
      const Iy = (mTop/12) * (Lx*Lx + (+lz.value||3) * (+lz.value||3));

      const az  = (mTop>0)? (Fz/mTop) : 0;
      const awx = (Ix  >0)? (TauX/Ix) : 0;
      const awy = (Iy  >0)? (TauY/Iy) : 0;

      const aCorners = new Array(4);
      for (let i=0;i<4;i++){
        const xi=corners[i][0], yi=corners[i][1];
        aCorners[i] = az + (-awx * yi) + (awy * xi);
      }
      return { az: az, aCorners: aCorners, Fi: Fi };
    }

    function drawAxes(){
      const origin=[60,60], L=45;
      function rot(v){ const x=v[0], y=v[1], z=v[2]; const cz=Math.cos(yaw), sz=Math.sin(yaw); let nx=x*cz-y*sz, ny=x*sz+y*cz, nz=z; const cx=Math.cos(pitch), sx=Math.sin(pitch); let ny2=ny*cx-nz*sx; return [nx,-ny2]; }
      const axes={X:rot([1,0,0]), Y:rot([0,1,0]), Z:rot([0,0,1])};
      ctx.lineWidth=2; ctx.lineCap='round'; const colors={X:'#ef4444',Y:'#16a34a',Z:'#0b73c8'};
      ['X','Y','Z'].forEach(function(k){
        const v=axes[k]; ctx.strokeStyle=colors[k]; ctx.beginPath(); ctx.moveTo(origin[0],origin[1]); ctx.lineTo(origin[0]+v[0]*L,origin[1]+v[1]*L); ctx.stroke();
        ctx.fillStyle=colors[k]; ctx.font='12px system-ui'; ctx.fillText(k,origin[0]+v[0]*L+4,origin[1]+v[1]*L+4);
      });
    }

    function drawWithState(y){
      fitScale(); ctx.clearRect(0,0,canvas.width,canvas.height);
      const v=vals(); const Lx=v.Lx, Ly=v.Ly, Lz=v.Lz, K=v.K;
      const z=y[0], thx=y[1], thy=y[2], zb=y[6];
      const zRel = z - zb;
      const gain = parseFloat(respScaleEl.value)||0;

      drawBaseBox(Lx,Ly,Lz);
      const strokeFor=function(val){return kStroke(K,val);};
      const corners2=[[0,0],[Lx,0],[Lx,Ly],[0,Ly]];
      const cols=['#1d4ed8','#ef4444','#16a34a','#f59e0b'];
      const kvals=[K[0],K[1],K[2],K[3]];

      drawTopRigid(zRel, thx, thy, Lx, Ly, Lz, gain);

      for(let i=0;i<4;i++){
        const pair=corners2[i]; const x=pair[0], yc=pair[1];
        let topZ;
        if(drawTopRigid.lowerCorners && drawTopRigid.upperCorners){
          const low=drawTopRigid.lowerCorners[i], up=drawTopRigid.upperCorners[i];
          topZ= low[2] + 0.25*(up[2]-low[2]);
        } else {
          topZ = zRel*gain + 0.25*Lz;
        }
        drawSpringSymbol(x,yc,0,topZ,strokeFor(kvals[i]),cols[i],Lz);
      }

      drawAxes();
      drawWaveformPreview();
      ctx.fillStyle='#111'; ctx.font='12px system-ui';
      ctx.fillText('t: '+tSimNow.toFixed(3)+' s', 66, canvas.height-13);
    }

    function draw(){
      fitScale(); ctx.clearRect(0,0,canvas.width,canvas.height);
      const v=vals(); const Lx=v.Lx, Ly=v.Ly, Lz=v.Lz, K=v.K;

      drawBaseBox(Lx,Ly,Lz);

      const V=[[0,0,0],[Lx,0,0],[Lx,Ly,0],[0,Ly,0],[0,0,Lz],[Lx,0,Lz],[Lx,Ly,Lz],[0,Ly,Lz]];
      const faces=[[0,1,2,3],[4,5,6,7],[0,1,5,4],[1,2,6,5],[2,3,7,6],[3,0,4,7]];
      ctx.fillStyle='rgba(200,200,200,0.5)';
      faces.forEach(function(f){ ctx.beginPath(); const p0=project(V[f[0]]); ctx.moveTo(p0[0],p0[1]); for(let i=1;i<f.length;i++){ const p=project(V[f[i]]); ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill(); });
      const E=[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      ctx.strokeStyle='#111'; ctx.lineWidth=2; ctx.lineJoin='round';
      E.forEach(function(e){ const a=e[0], b=e[1]; const p1=project(V[a]), p2=project(V[b]); ctx.beginPath(); ctx.moveTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.stroke(); });

      const zEnd=0.25*Lz; const strokeFor=function(val){return kStroke(K,val);};
      [{x:0,y:0,k:K[0],c:'#1d4ed8'},{x:Lx,y:0,k:K[1],c:'#ef4444'},{x:0,y:Ly,k:K[2],c:'#16a34a'},{x:Lx,y:Ly,k:K[3],c:'#f59e0b'}]
        .forEach(function(s){drawSpringSymbol(s.x,s.y,0,zEnd,strokeFor(s.k),s.c,Lz);});

      drawAxes();
      drawWaveformPreview();
    }

    function renderAccelPlot(t, aG, tCursor, overlayTH, grmsText){
      tCursor = (tCursor!=null)?tCursor:null;
      overlayTH = overlayTH || null;
      grmsText = grmsText || null;

      const ctx = accelPlotCtx, W=ctx.canvas.width, H=ctx.canvas.height;
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.fillRect(0,0,W,H);
      ctx.strokeStyle='#bbb'; ctx.strokeRect(0,0,W,H);

      ctx.fillStyle='#111'; ctx.font='12px system-ui';
      let title = "Top center acceleration (G) vs time (s)";
      if (grmsText) title += ' — ' + grmsText;
      ctx.fillText(title, 10, 16);

      const padL=70, padR=12, padT=24, padB=28;
      const gx=padL, gy=padT, gw=W-padL-padR, gh=H-padT-padB;

      const tmin=t[0], tmax=t[t.length-1];

      let yMin = Math.min.apply(null, [0].concat(aG));
      let yMax = Math.max.apply(null, [0].concat(aG));
      if (overlayTH && overlayTH.y && overlayTH.y.length > 0){
        let thMin = Infinity, thMax = -Infinity;
        const oy = overlayTH.y;
        for (let i=0;i<oy.length;i++){
          const v = oy[i];
          if (v < thMin) thMin = v;
          if (v > thMax) thMax = v;
        }
        yMin = Math.min(yMin, thMin);
        yMax = Math.max(yMax, thMax);
      }
      const yPad=(yMax-yMin)*0.1+1e-9;
      const ymin=yMin-yPad, ymax=yMax+yPad;

      ctx.strokeStyle='#ddd'; ctx.lineWidth=1; ctx.strokeRect(gx,gy,gw,gh);

      ctx.fillStyle='#444'; ctx.textAlign='center'; ctx.textBaseline='top';
      for(let i=0;i<=5;i++){
        const tt=tmin+(i/5)*(tmax-tmin);
        const px=gx+(tt-tmin)/(tmax-tmin||1)*gw;
        ctx.fillText(tt.toPrecision(3), px, gy+gh+6);
      }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      for(let i=0;i<=4;i++){
        const yy=ymin+(i/4)*(ymax-ymin);
        const py=gy+gh-(yy-ymin)/(ymax-ymin||1)*gh;
        ctx.fillText(yy.toPrecision(3), gx-6, py);
      }

      ctx.beginPath();
      for(let i=0;i<t.length;i++){
        const px=gx+(t[i]-tmin)/(tmax-tmin||1)*gw;
        const py=gy+gh-(aG[i]-ymin)/(ymax-ymin||1)*gh;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.strokeStyle='#0b73c8'; ctx.lineWidth=2; ctx.stroke();

      if (overlayTH && overlayTH.t && overlayTH.y && overlayTH.t.length>1){
        const T0=Math.max(tmin, overlayTH.t[0]);
        const T1=Math.min(tmax, overlayTH.t[overlayTH.t.length-1]);
        if (T1>T0){
          ctx.beginPath();
          for(let i=0;i<overlayTH.t.length;i++){
            const tt=overlayTH.t[i];
            if (tt<T0||tt>T1) continue;
            const px=gx+(tt-tmin)/(tmax-tmin||1)*gw;
            const py=gy+gh-(overlayTH.y[i]-ymin)/(ymax-ymin||1)*gh;
            if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          ctx.strokeStyle='rgba(0,0,0,0.45)'; ctx.lineWidth=1.25; ctx.stroke();

          ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(gx+8, gy+8, 18, 3);
          ctx.fillStyle='#333'; ctx.fillText('base accel (G)', gx+30, gy+13);
        }
      }

      if (tCursor!=null){
        const clamped=Math.max(tmin,Math.min(tmax,tCursor));
        const cx=gx+(clamped-tmin)/(tmax-tmin||1)*gw;
        ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle='#111';
        ctx.beginPath(); ctx.moveTo(cx,gy); ctx.lineTo(cx,gy+gh); ctx.stroke();
        ctx.setLineDash([]); ctx.fillStyle='#111'; ctx.font='11px system-ui';
        ctx.textAlign='left'; ctx.textBaseline='bottom';
        ctx.fillText('t='+clamped.toFixed(3)+' s', Math.min(cx+6, gx+gw-60), gy+gh-4);
        ctx.restore();
      }

      ctx.fillStyle='#444'; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.fillText('t (s)', gx+gw-40, gy+gh+20);
      ctx.save(); ctx.translate(gx-40, gy+80); ctx.rotate(-Math.PI/2);
      ctx.fillText('Accel (G)', 0, 0); ctx.restore();
    }

    function renderSpringPlot(t, Fseries, tCursor){
      tCursor = (tCursor!=null)?tCursor:null;
      const ctx = springPlotCtx;
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.clearRect(0,0,W,H);

      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillRect(0,0,W,H);
      ctx.strokeStyle = '#bbb'; ctx.strokeRect(0,0,W,H);

      const unit = (unitMode==='US'?'lb':'N');
      ctx.fillStyle='#111'; ctx.font='12px system-ui';
      ctx.fillText('Corner spring reactions ('+unit+') vs time (s)', 10, 16);

      const padL=70, padR=12, padT=24, padB=28;
      const gx=padL, gy=padT, gw=W-padL-padR, gh=H-padT-padB;

      const tmin=t[0], tmax=t[t.length-1];
      let yMin=0, yMax=0;
      for(let s=0;s<4;s++){ const arr=Fseries[s]; yMin=Math.min(yMin, Math.min.apply(null,arr)); yMax=Math.max(yMax, Math.max.apply(null,arr)); }
      const yPad=(yMax-yMin)*0.1 + 1e-9;
      const ymin=yMin - yPad, ymax=yMax + yPad;

      ctx.strokeStyle='#ddd'; ctx.lineWidth=1; ctx.strokeRect(gx,gy,gw,gh);

      ctx.fillStyle='#444'; ctx.textAlign='center'; ctx.textBaseline='top';
      for(let i=0;i<=5;i++){
        const tt = tmin + (i/5)*(tmax - tmin);
        const px = gx + (tt - tmin)/(tmax - tmin || 1)*gw;
        ctx.fillText(tt.toPrecision(3), px, gy+gh+6);
      }
      ctx.textAlign='right'; ctx.textBaseline='middle';
      for(let i=0;i<=4;i++){
        const yy = ymin + (i/4)*(ymax - ymin);
        const py = gy + gh - (yy - ymin)/(ymax - ymin || 1)*gh;
        ctx.fillText(yy.toPrecision(4), gx-6, py);
      }

      const colors=['#1d4ed8','#ef4444','#16a34a','#f59e0b'];
      for(let s=0;s<4;s++){
        ctx.beginPath();
        for(let i=0;i<t.length;i++){
          const px = gx + (t[i]-tmin)/(tmax-tmin || 1)*gw;
          const py = gy + gh - (Fseries[s][i]-ymin)/(ymax-ymin || 1)*gh;
          if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.strokeStyle=colors[s];
        ctx.lineWidth=2;
        ctx.stroke();
      }

      const labels=['(0,0)','(Lx,0)','(0,Ly)','(Lx,Ly)'];
      ctx.font='12px system-ui'; ctx.textAlign='left'; ctx.textBaseline='middle';
      let lx=gx+6, ly=gy+12;
      const colors2=['#1d4ed8','#ef4444','#16a34a','#f59e0b'];
      for(let i=0;i<4;i++){
        ctx.fillStyle=colors2[i];
        ctx.fillRect(lx, ly-5, 18, 10);
        ctx.fillStyle='#333';
        ctx.fillText(labels[i], lx+24, ly);
        lx += 90;
      }

      if (tCursor!=null){
        const clamped = Math.max(tmin, Math.min(tmax, tCursor));
        const cx = gx + (clamped - tmin)/(tmax - tmin || 1)*gw;
        ctx.save();
        ctx.setLineDash([6,4]);
        ctx.strokeStyle='#111';
        ctx.beginPath(); ctx.moveTo(cx, gy); ctx.lineTo(cx, gy+gh); ctx.stroke();
        ctx.setLineDash([]);
      }

      ctx.fillStyle='#444';
      ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.fillText('t (s)', gx+gw-40, gy+gh+20);
      ctx.save(); ctx.translate(gx-40, gy+80); ctx.rotate(-Math.PI/2);
      ctx.fillText('Force ('+unit+')', 0, 0);
      ctx.restore();
    }

    function plotGeom(ctx, padL, padR, padT, padB){
      const W=ctx.canvas.width, H=ctx.canvas.height;
      return { gx:padL, gy:padT, gw:W-padL-padR, gh:H-padT-padB, W:W, H:H };
    }
    function tFromX(x, tmin, tmax, geom){
      const gx=geom.gx, gw=geom.gw;
      const r = Math.max(0, Math.min(1, (x - gx) / (gw || 1)));
      return tmin + r * (tmax - tmin);
    }
    function interp1(times, arr, t){
      const n=times.length; if(t<=times[0]) return arr[0]; if(t>=times[n-1]) return arr[n-1];
      let lo=0,hi=n-1; while(hi-lo>1){ const mid=(lo+hi)>>1; if(times[mid]<=t) lo=mid; else hi=mid; }
      const a=(t-times[lo])/(times[hi]-times[lo] || 1);
      return arr[lo] + a*(arr[hi]-arr[lo]);
    }
    function updateReadout(tSel){
      if (!lastTimes) { readoutEl.textContent=''; return; }
      const aG = interp1(lastTimes, lastAzG, tSel);
      const F = lastFseries.map(function(series){ return interp1(lastTimes, series, tSel); });
      const unit = (unitMode==='US'?'lb':'N');
      readoutEl.textContent = 't = '+tSel.toFixed(4)+' s — accel: '+aG.toFixed(4)+' G, springs: ['+F.map(function(v){return v.toFixed(2);}).join(', ')+'] '+unit;
    }

    function attachCursor(canvasEl, type){
      let dragging=false;
      const onMove = function(e){
        if(!lastTimes) return;
        const rect = canvasEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const tmin = lastTimes[0], tmax=lastTimes[lastTimes.length-1];
        const geom = (type==='accel') ? plotGeom(accelPlotCtx,70,12,24,28) : plotGeom(springPlotCtx,70,12,24,28);
        cursorTime = tFromX(x, tmin, tmax, geom);
        renderAccelPlot(lastTimes, lastAzG, cursorTime, overlayTH, grmsText);
        renderSpringPlot(lastTimes, lastFseries, cursorTime);
        updateReadout(cursorTime);
      };
      canvasEl.addEventListener('mousemove',function(e){ if (!lastTimes) return; if (dragging) onMove(e); });
      canvasEl.addEventListener('mousedown',function(e){ dragging=true; onMove(e); });
      window.addEventListener('mouseup',function(){ dragging=false; });
      canvasEl.addEventListener('mouseleave',function(){ if(!dragging){ cursorTime=null; renderAccelPlot(lastTimes||[], lastAzG||[], null, overlayTH, grmsText); renderSpringPlot(lastTimes||[], lastFseries||[[],[],[],[]], null); readoutEl.textContent=''; }});
      canvasEl.addEventListener('mousemove',function(e){ if(!dragging) onMove(e); });
    }

    function lowestNaturalPeriod(){
      const W=parseFloat(weightEl.value)||0; const m = W/g();
      const K=vals().K; const sumK=K.reduce(function(a,b){return a+(Number.isFinite(b)?b:0);},0);
      const fz = (sumK>0 && m>0) ? (Math.sqrt(sumK/m)/(2*Math.PI)) : 0.1;
      return 1/Math.max(1e-6,fz);
    }

    function simulate(){
      if (playing){ showToast('Simulation already running'); return; }

      const W = +weightEl.value || 0;
      const K = vals().K;
      const sumK = K.reduce(function(a,b){return a+(Number.isFinite(b)?b:0);},0);

      if (!randPSD_lookup){
        showToast('Click “Generate Time History” first.');
        psdPanel.scrollIntoView({behavior:'smooth',block:'center'});
        return;
      }
      if (W <= 0){ draw(); showToast('Weight must be > 0.'); return; }
      if (sumK <= 0){ draw(); showToast('All spring k must sum to > 0.'); return; }

      resetMaxAccelPanel();
      draw(); showToast('Simulating…');

      try{
        const f = makeDynamics();
        const Tperiod = lowestNaturalPeriod();
        const tEnd = Math.min(10*Math.max(0.05, Tperiod), 20.0);
        const y0 = new Float64Array(8);
        simData = rkf45Integrate(f, 0, y0, tEnd, 0.0001, .5e-5, 1e-8);

        if (!simData || !simData.t || simData.t.length < 2 || !Number.isFinite(simData.t[simData.t.length-1])) {
          showToast('Simulation produced no steps');
          return;
        }

        const times = simData.t;
        const azG = new Array(times.length);
        const F0 = new Array(times.length), F1 = new Array(times.length),
              F2 = new Array(times.length), F3 = new Array(times.length);

        for (let i=0;i<times.length;i++){
          const resp = responseAtSample(simData.y[i]);
          const az = resp.az, aCorners = resp.aCorners, Fi = resp.Fi;
          const centerG = az / g();
          azG[i] = centerG;
          F0[i] = Fi[0]; F1[i] = Fi[1]; F2[i] = Fi[2]; F3[i] = Fi[3];

          if (Math.abs(centerG) > maxCenterG) maxCenterG = Math.abs(centerG);
          for (let j=0;j<4;j++){
            const cornerG = aCorners[j] / g();
            if (Math.abs(cornerG) > maxCornerG[j]) maxCornerG[j] = Math.abs(cornerG);
          }
        }

        lastTimes = times; lastAzG = azG; lastFseries = [F0,F1,F2,F3];
        cursorTime = null;

        overlayTH = (randPSD_t && randPSD_y) ? { t: Array.from(randPSD_t), y: Array.from(randPSD_y) } : null;
        const grmsVal = (randPSD_y && randPSD_y.length) ? Math.sqrt(randPSD_y.reduce(function(s,v){return s+v*v;},0)/randPSD_y.length) : null;
        grmsText = (grmsVal!=null) ? ('Grms ≈ '+grmsVal.toPrecision(3)+' g') : null;

        renderAccelPlot(times, azG, cursorTime, overlayTH, grmsText);
        renderSpringPlot(times, [F0,F1,F2,F3], cursorTime);

        maxCenterEl.textContent = 'Center: '+maxCenterG.toFixed(3)+' G';
        maxC00El.textContent    = '(0,0): '+maxCornerG[0].toFixed(3)+' G';
        maxCLx0El.textContent   = '(Lx,0): '+maxCornerG[1].toFixed(3)+' G';
        maxC0LyEl.textContent   = '(0,Ly): '+maxCornerG[2].toFixed(3)+' G';
        maxCLxLyEl.textContent  = '(Lx,Ly): '+maxCornerG[3].toFixed(3)+' G';

        tSimNow = 0; simStartWall = performance.now(); playing = true;
        requestAnimationFrame(stepAnimation);
      } catch (err) {
        console.error(err);
        showToast('Simulation error — see console');
      }
    }

    let overlayTH=null, grmsText=null;

    function stepAnimation(now){
      if(!playing||!simData) return;
      const speed=parseFloat(simSpeed.value)||0;
      const tEnd=simData.t[simData.t.length-1];
      const tSim=((now-simStartWall)/1000)*speed;
      tSimNow=Math.min(tSim,tEnd);
      currentY=interpSeries(simData.t, simData.y, tSimNow);
      drawWithState(currentY);

      if(tSim<tEnd) requestAnimationFrame(stepAnimation);
      else { playing=false; showToast('Simulation complete'); }
    }

    function interpSeries(ts,ys,t){
      const n=ts.length; if(t<=ts[0]) return ys[0]; if(t>=ts[n-1]) return ys[n-1];
      let lo=0,hi=n-1; while(hi-lo>1){ const mid=(lo+hi)>>1; if(ts[mid]<=t) lo=mid; else hi=mid; }
      const t0=ts[lo], t1=ts[hi], a=(t-t0)/(t1-t0||1); const y0=ys[lo], y1=ys[hi]; const y=new Array(y0.length);
      for(let i=0;i<y.length;i++) y[i]= y0[i] + a*(y1[i]-y0[i]);
      return y;
    }

    function sampleBaseAtTimes(times){
      const arr=new Array(times.length);
      for (let i=0;i<times.length;i++) arr[i]= (typeof randPSD_lookup==='function') ? randPSD_lookup(times[i]) : 0;
      return arr;
    }
    function exportJSON(){
      if (!lastTimes){ showToast('Run a simulation first'); return; }
      const baseG = sampleBaseAtTimes(lastTimes);
      const grms  = (randPSD_y && randPSD_y.length) ? Math.sqrt(randPSD_y.reduce(function(s,v){return s+v*v;},0)/randPSD_y.length) : 0;
      const data = lastTimes.map(function(tt,i){return {
        t: tt,
        accel_G: lastAzG[i],
        spring_00: lastFseries[0][i],
        spring_Lx0: lastFseries[1][i],
        spring_0Ly: lastFseries[2][i],
        spring_LxLy: lastFseries[3][i],
        a_base_G: baseG[i],
        grms_psd: grms,
        units_force: (unitMode==='US'?'lb':'N')
      };});
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'base_shake_random_psd.json';
      a.click();
      URL.revokeObjectURL(a.href);
    }

function exportJSON(){
  if (!lastTimes){ showToast('Run a simulation first'); return; }
  
  const now = new Date();
  const timestamp = now.getFullYear() + 
    String(now.getMonth()+1).padStart(2,'0') + 
    String(now.getDate()).padStart(2,'0') + '_' +
    String(now.getHours()).padStart(2,'0') + 
    String(now.getMinutes()).padStart(2,'0') + 
    String(now.getSeconds()).padStart(2,'0');
  
  const baseG = sampleBaseAtTimes(lastTimes);
  const grms  = (randPSD_y && randPSD_y.length) ? Math.sqrt(randPSD_y.reduce(function(s,v){return s+v*v;},0)/randPSD_y.length) : 0;
  
  // Configuration data for re-running
  const config = {
    weight: weightEl.value,
    lx: lx.value,
    ly: ly.value,
    lz: lz.value,
    k00: k00.value,
    kLx0: kLx0.value,
    k0Ly: k0Ly.value,
    kLxLy: kLxLy.value,
    damping: document.getElementById('damping').value,
    psdSpec: psdSpec.value,
    psdFs: psdFs.value,
    psdDur: psdDur.value,
    psdSeed: psdSeed.value,
    psdTaper: psdTaper.value,
    respScale: respScaleEl.value,
    simSpeed: simSpeed.value
  };
  
  // Results data
  const results = lastTimes.map(function(tt,i){return {
    t: tt,
    accel_G: lastAzG[i],
    spring_00: lastFseries[0][i],
    spring_Lx0: lastFseries[1][i],
    spring_0Ly: lastFseries[2][i],
    spring_LxLy: lastFseries[3][i],
    a_base_G: baseG[i],
    grms_psd: grms,
    units_force: (unitMode==='US'?'lb':'N')
  };});
  
  const exportData = {
    timestamp: now.toISOString(),
    config: config,
    results: results
  };
  
  const blob = new Blob([JSON.stringify(exportData,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'base_shake_random_psd_' + timestamp + '.json';
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('Data exported with configuration');
}

function importJSON(){
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = function(e){
    const file = e.target.files[0];
    if(!file) return;
    
    const reader = new FileReader();
    reader.onload = function(evt){
      try{
        const data = JSON.parse(evt.target.result);
        
        // Check if this is the new format with config object
        const config = data.config || data;
        
        // Populate all input fields
        if(config.weight !== undefined) weightEl.value = config.weight;
        if(config.lx !== undefined) lx.value = config.lx;
        if(config.ly !== undefined) ly.value = config.ly;
        if(config.lz !== undefined) lz.value = config.lz;
        if(config.k00 !== undefined) k00.value = config.k00;
        if(config.kLx0 !== undefined) kLx0.value = config.kLx0;
        if(config.k0Ly !== undefined) k0Ly.value = config.k0Ly;
        if(config.kLxLy !== undefined) kLxLy.value = config.kLxLy;
        if(config.damping !== undefined) document.getElementById('damping').value = config.damping;
        if(config.psdSpec !== undefined) psdSpec.value = config.psdSpec;
        if(config.psdFs !== undefined) psdFs.value = config.psdFs;
        if(config.psdDur !== undefined) psdDur.value = config.psdDur;
        if(config.psdSeed !== undefined) psdSeed.value = config.psdSeed;
        if(config.psdTaper !== undefined) psdTaper.value = config.psdTaper;
        if(config.respScale !== undefined) respScaleEl.value = config.respScale;
        if(config.simSpeed !== undefined) simSpeed.value = config.simSpeed;
        
        // Update computed fields and plots
        computeMass();
        renderPSDPlot(parsePSDTextarea());
        draw();
        
        showToast('Configuration imported successfully');
      } catch(err){
        console.error(err);
        showToast('Error importing JSON: ' + err.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}


simulateBtn.addEventListener('click', function(e){ e.preventDefault(); simulate(); });
exportJSONBtn.addEventListener('click', exportJSON);
importJSONBtn.addEventListener('click', importJSON);
exportCSVBtn.addEventListener('click', exportCSV);



    [lx,ly,lz,k00,kLx0,k0Ly,kLxLy].forEach(function(el){ el.addEventListener('input',draw); });
    let dragging=false,lastX=0,lastY=0, dragMode='rotate';
    canvas.addEventListener('contextmenu',function(e){e.preventDefault();});
    canvas.addEventListener('mousedown',function(e){
      dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.style.cursor='grabbing';
      dragMode=((e.button===0 && e.shiftKey) || e.button===2)?'pan':'rotate';
    });
    window.addEventListener('mouseup',function(){ dragging=false; canvas.style.cursor='default'; });
    window.addEventListener('mousemove',function(e){
      if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
      if(dragMode==='pan'){ panX+=dx; panY+=dy; }
      else { yaw+=dx*0.01; pitch+=dy*0.01; pitch=Math.max(-1.2,Math.min(1.2,pitch)); }
      (playing? drawWithState(currentY||new Array(8).fill(0)): draw());
    });
    canvas.addEventListener('wheel',function(e){ e.preventDefault(); const factor=Math.exp(-e.deltaY*0.0015); zoom=Math.min(5,Math.max(0.3,zoom*factor)); (playing? drawWithState(currentY||new Array(8).fill(0)): draw()); }, {passive:false});
    resetBtn.addEventListener('click',function(){ yaw=0.8; pitch=-1.0; zoom=1.5; panX=-100; panY=125; (playing? drawWithState(currentY||new Array(8).fill(0)): draw()); });
    respScaleEl.addEventListener('input',function(){ (playing? drawWithState(currentY||new Array(8).fill(0)): draw()); });

    attachCursor(accelPlot, 'accel');
    attachCursor(springPlot, 'spring');

    function selfTest(){
      console.assert(typeof rkf45Integrate==='function','rkf45Integrate exists');
      console.assert(document.getElementById('simulateBtn'), 'simulateBtn present');
    }
    computeMass(); renderPSDPlot(parsePSDTextarea()); draw(); selfTest();
  })();
  </script>
</body>
</html>

























