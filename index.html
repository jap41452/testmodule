<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Plenum / Fan ‚Äì V2 Simple Flow + Branch Split + Velocity Blocks</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />


<!-- Libraries (Chart.js MUST be before our script) -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- ADD THIS LINE FOR ZIP FUNCTIONALITY -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    :root{
      --bg:#f5f5f7;
      --panel:#ffffff;
      --border:#d0d5dd;
      --ink:#111827;
      --muted:#6b7280;
      --accent:#0b73c8;
      --r:12px;
      --pad:14px;
      --gap:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--ink);
      font-size:14px;
    }
    header{
      padding:10px 16px;
      border-bottom:1px solid var(--border);
      background:#f9fafb;
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:.02em;
    }
    header p{
      margin:4px 0 0;
      color:var(--muted);
      font-size:13px;
    }
    main{
      padding:var(--pad);
      display:flex;
      flex-wrap:wrap;
      gap:var(--gap);
      align-items:flex-start;
    }
    .col{
      display:flex;
      flex-direction:column;
      gap:var(--gap);
    }
    .col-left{
      flex:0 0 200px;
      max-width:200px;
    }
    .col-mid{
      flex:0 0 600px;
      max-width:600px;
      min-width:320px;
    }
    .panel{
      background:var(--panel);
      border-radius:var(--r);
      border:1px solid var(--border);
      padding:var(--pad);
      box-shadow:0 1px 2px rgba(15,23,42,0.04);
    }
    .panel h2{
      margin:0 0 8px;
      font-size:15px;
      font-weight:600;
    }
    .panel small{
      color:var(--muted);
    }
    .grid-2{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:10px 12px;
      margin-top:8px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .field label{
      font-size:12px;
      color:var(--muted);
    }
    .field input{
      padding:4px 6px;
      border-radius:6px;
      border:1px solid var(--border);
      font-size:13px;
    }
    .section-label{
      margin-top:8px;
      font-size:12px;
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:.06em;
      color:var(--muted);
    }
    .btn-row{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    button{
      border-radius:999px;
      border:1px solid transparent;
      padding:6px 12px;
      font-size:13px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:var(--accent);
      color:#fff;
    }
    button.secondary{
      background:#fff;
      color:var(--ink);
      border-color:var(--border);
    }
    button:disabled{
      opacity:.5;
      cursor:default;
    }
    table{
      width:100%;
      border-collapse:collapse;
      margin-top:6px;
      font-size:12px;
    }
    th, td{
      border:1px solid #e5e7eb;
      padding:2px 4px;
      text-align:right;
    }
    th{
      background:#f3f4f6;
      font-weight:500;
    }
    td input{
      width:100%;
      border:none;
      outline:none;
      text-align:right;
      font-size:12px;
      padding:2px 2px;
      background:transparent;
    }
    .results-grid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:6px 12px;
      margin-top:6px;
      font-size:13px;
    }
    .result-label{
      color:var(--muted);
    }
    .result-value{
      text-align:right;
      font-feature-settings:"tnum" 1;
    }
    canvas{max-width:100%;}
    #curveChart{height:180px !important;}
    #velChart{height:180px !important;}
    .fan-panel{max-height:300px;overflow-y:auto;}

    #view3D{
      width:100%;
      height:260px;
      border-radius:10px;
      border:1px solid #e5e7eb;
      background:#f9fafb;
      position:relative;
      overflow:hidden;
    }
    #view3D-msg{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:12px;
      color:#6b7280;
      pointer-events:none;
    }

    #velLegend{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
    }
    #velLegend .row{
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:3px;
    }
    #velLegend .swatch{
      width:14px;
      height:14px;
      border-radius:3px;
      border:1px solid #cbd5e1;
    }

    @media (max-width:860px){
      .col-left{flex:1 1 200px; max-width:none;}
      .col-mid{flex:1 1 320px; max-width:none;}
    }
  </style>
</head>
<body>
<header>
  <h1>Plenum / Fan Matching ‚Äì V2 Simple Flow</h1>
  <p>IP units: in, inH‚ÇÇO, cfm. Solver uses SI internally. 3D view is illustrative only.</p>
</header>

<main>
  <!-- LEFT COLUMN: PANELS 1‚Äì4 -->
  <section class="col col-left">
    <!-- 1. Air -->
    <div class="panel">
      <h2>1. Air (solver)</h2>
      <small>Used for Re and pressure-drop calcs (SI).</small>
      <div class="grid-2">
        <div class="field">
          <label for="rho">Density œÅ (kg/m¬≥)</label>
          <input id="rho" type="number" value="1.20">
        </div>
        <div class="field">
          <label for="mu">Viscosity Œº (Pa¬∑s)</label>
          <input id="mu" type="number" value="1.82e-5" step="1e-6">
        </div>
      </div>
    </div>

    <!-- 2. Plenum & Inlet -->
    <div class="panel">
      <h2>2. Plenum & Inlet</h2>
      <small>Geometry in inches (display + 3D).</small>
      <div class="section-label">Plenum</div>
      <div class="grid-2">
        <div class="field">
          <label for="plenumW">Width W (in)</label>
          <input id="plenumW" type="number" value="12" step="0.1">
        </div>
        <div class="field">
          <label for="plenumH">Height H (in)</label>
          <input id="plenumH" type="number" value="6" step="0.1">
        </div>
        <div class="field">
          <label for="plenumL">Length L (in)</label>
          <input id="plenumL" type="number" value="12" step="0.1">
        </div>
      </div>

      <div class="section-label">Fan / Blower Inlet</div>
      <div class="grid-2">
        <div class="field">
          <label for="inletW">Inlet width w (in)</label>
          <input id="inletW" type="number" value="4" step="0.1">
        </div>
        <div class="field">
          <label for="inletH">Inlet height h (in)</label>
          <input id="inletH" type="number" value="4" step="0.1">
        </div>
        <div class="field">
          <label for="inletX">Inlet x from start (in)</label>
          <input id="inletX" type="number" value="4" step="0.1">
        </div>
      </div>
    </div>

    <!-- 3. Heat Sink -->
    <div class="panel">
      <h2>3. Heat Sink (Finned)</h2>
      <small>For channel geometry and pressure drop.</small>
      <div class="grid-2">
        <div class="field">
          <label for="b">Fin height b (in)</label>
          <input id="b" type="number" value="2" step="0.05">
        </div>
        <div class="field">
          <label for="tfin">Fin thickness t (in)</label>
          <input id="tfin" type="number" value="0.05" step="0.01">
        </div>
        <div class="field">
          <label for="sfin">Fin spacing s (in)</label>
          <input id="sfin" type="number" value="1" step="0.1">
        </div>
        <div class="field">
          <label for="Lfin">Fin length L<sub>f</sub> (in)</label>
          <input id="Lfin" type="number" value="8" step="0.1">
        </div>
        <div class="field">
          <label for="xHS">HS lead edge x (in)</label>
          <input id="xHS" type="number" value="3" step="0.1">
        </div>
        <div class="field">
          <label for="WHS">HS width (in, ‚â§ W)</label>
          <input id="WHS" type="number" value="12" step="0.1">
        </div>
      </div>
    </div>

    <!-- 4. Fan Curve -->
    <div class="panel">
      <h2>4. Fan Curve (IP)</h2>
      <small>Q in cfm, Œîp in inH‚ÇÇO (0.5 HP-ish default curve).</small>
      <table id="fanTable">
        <thead>
        <tr><th>#</th><th>Q (cfm)</th><th>Œîp (inH‚ÇÇO)</th></tr>
        </thead>
        <tbody>
        <tr><td>1</td><td><input value="0"></td><td><input value="2.2"></td></tr>
        <tr><td>2</td><td><input value="200"></td><td><input value="2.0"></td></tr>
        <tr><td>3</td><td><input value="400"></td><td><input value="1.7"></td></tr>
        <tr><td>4</td><td><input value="600"></td><td><input value="1.3"></td></tr>
        <tr><td>5</td><td><input value="800"></td><td><input value="0.8"></td></tr>
        <tr><td>6</td><td><input value="1000"></td><td><input value="0.3"></td></tr>
        <tr><td>7</td><td><input value="1100"></td><td><input value="0.0"></td></tr>
        </tbody>
      </table>
      <div class="btn-row">
        <button type="button" class="secondary" id="addRowBtn">+ Row</button>
        <button type="button" class="secondary" id="delRowBtn">‚Äì Row</button>
      </div>
    </div>
  </section>

  <!-- MIDDLE COLUMN: PANELS 5‚Äì8 -->
  <section class="col col-mid">
    <!-- 5. Solve -->
    <div class="panel">
      <h2>5. Solve</h2>
      <small>Fan scaled to meet target channel velocity; velocities, Re, and air power.</small>

      <div class="grid-2">
        <div class="field">
          <label for="Vch_target">Target channel velocity V<sub>ch,target</sub> (ft/s)</label>
          <input id="Vch_target" type="number" value="20" step="0.1">
        </div>
      </div>

<div class="btn-row" style="justify-content:flex-start;">
  <button type="button" id="solveBtn">Solve</button>
  
  <!-- ADD THESE FOUR BUTTONS HERE -->
  <button type="button" id="exportJsonBtn" class="secondary" style="background: #fff3cd; border-color: #ffc107; color: #856404;">üíæ JSON</button>
  <button type="button" id="importJsonBtn" class="secondary" style="background: #d1ecf1; border-color: #bee5eb; color: #0c5460;">üìÇ Import</button>
  <button type="button" id="exportCsvBtn" class="secondary" style="background: #d4edda; border-color: #c3e6cb; color: #155724;">üìä CSV</button>
  <button type="button" id="exportZipBtn" class="secondary" style="background: #cfe2ff; border-color: #b6d4fe; color: #084298;">üì¶ ZIP</button>
  <!-- END OF NEW BUTTONS -->
</div>      

</div>

      <div class="section-label">Key Results</div>
      <div class="results-grid">
        <div class="result-label">Flow rate Q* (cfm)</div>
        <div class="result-value" id="Qstar">‚Äî</div>

        <div class="result-label">Back pressure Œîp* (inH‚ÇÇO)</div>
        <div class="result-value" id="Dpstar">‚Äî</div>

        <div class="result-label">Inlet velocity V<sub>in</sub> (ft/s)</div>
        <div class="result-value" id="Vin">‚Äî</div>

        <div class="result-label">Channel velocity V<sub>ch,avg</sub> (ft/s)</div>
        <div class="result-value" id="Vch">‚Äî</div>

        <div class="result-label">Reynolds (plenum) Re<sub>pl</sub></div>
        <div class="result-value" id="Re_pl">‚Äî</div>

        <div class="result-label">Reynolds (channel) Re<sub>ch</sub></div>
        <div class="result-value" id="Re_ch">‚Äî</div>

        <div class="result-label">Fan air power (HP)</div>
        <div class="result-value" id="HP">‚Äî</div>

        <div class="result-label">Fan scale factor (√ó)</div>
        <div class="result-value" id="ScaleFactor">‚Äî</div>
      </div>
    </div>

    <!-- 6. Velocity vs x -->
    <div class="panel">
      <h2>6. Velocity Distribution (V2)</h2>
      <small>1D plenum-over-HS manifold ‚Äì channel velocity vs x along fins.</small>
      <div class="grid-2">
        <div class="field">
          <label for="nSlices"># slices along HS</label>
          <input id="nSlices" type="number" value="20" min="3" max="80" step="1">
        </div>
      </div>
      <div class="section-label">V<sub>ch</sub>(x) (m/s, internal)</div>
      <canvas id="velChart"></canvas>
    </div>

    <!-- 7. 3D View -->
    <div class="panel">
      <h2>7. 3D Geometry View</h2>
      <small>Rotatable view of plenum, inlet, and finned heat sink with velocity-colored regions.</small>
      <div id="view3D">
        <div id="view3D-msg">Click and drag to rotate, mouse wheel to zoom.</div>
      </div>
      <div id="velLegend"></div>
    </div>

    <!-- 8. Fan & System Curves -->
    <div class="panel fan-panel">
      <h2>8. Fan & System Curves</h2>
      <small>Scaled fan curve vs. fixed system curve (IP axes).</small>
      <canvas id="curveChart"></canvas>
    </div>
  </section>
</main>

<script>
  // ---------- constants / helpers ----------
  const CFM_TO_M3S = 0.00047194745;
  const IN_TO_M    = 0.0254;
  const INH2O_TO_PA= 249.0889;

  // minor loss coefficients
  const K_INLET = 1.0;   // plenum inlet
  const K_EXIT  = 1.0;   // plenum outlet
  const K_CH_MINOR   = 2.0; // entrance/exit + bundle effects (lumped)
  const K_TOP_MINOR  = 1.0;
  const K_SIDE_MINOR = 1.0;

  function frictionFactor(Re){
    if (!isFinite(Re) || Re <= 0) return 0;
    if (Re < 2300) return 64/Re;
    return 0.3164/Math.pow(Re,0.25);
  }

  // ---------- fan table ----------
  function readFanTable(){
    const tbody = document.querySelector('#fanTable tbody');
    const pts = [];
    for (const row of tbody.rows){
      const Q = parseFloat(row.cells[1].querySelector('input').value);
      const dp= parseFloat(row.cells[2].querySelector('input').value);
      if (!isNaN(Q) && !isNaN(dp)) pts.push({x:Q, y:dp});
    }
    pts.sort((a,b)=>a.x-b.x);
    return pts;
  }

  function fanDeltaP_IP(Q, pts){
    if (pts.length===0) return 0;
    if (pts.length===1) return pts[0].y;
    if (Q <= pts[0].x){
      const p0=pts[0], p1=pts[1];
      const t=(Q-p0.x)/(p1.x-p0.x || 1e-9);
      return p0.y + t*(p1.y-p0.y);
    }
    const last=pts[pts.length-1];
    const secondLast=pts[pts.length-2];
    if (Q >= last.x){
      const p0=secondLast, p1=last;
      const t=(Q-p0.x)/(p1.x-p0.x || 1e-9);
      return p0.y + t*(p1.y-p0.y);
    }
    for (let i=0;i<pts.length-1;i++){
      const p0=pts[i], p1=pts[i+1];
      if (Q>=p0.x && Q<=p1.x){
        const t=(Q-p0.x)/(p1.x-p0.x || 1e-9);
        return p0.y + t*(p1.y-p0.y);
      }
    }
    return last.y;
  }

  document.getElementById('addRowBtn').addEventListener('click',()=>{
    const tbody=document.querySelector('#fanTable tbody');
    const idx=tbody.rows.length+1;
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${idx}</td><td><input value=""></td><td><input value=""></td>`;
    tbody.appendChild(tr);
    refreshFanChart(); // base (unscaled) display until next solve
  });
  document.getElementById('delRowBtn').addEventListener('click',()=>{
    const tbody=document.querySelector('#fanTable tbody');
    if (tbody.rows.length>1) tbody.deleteRow(-1);
    refreshFanChart();
  });

  // ---------- 3-branch flow split helper ----------
  // Given total Q (m¬≥/s), returns per-branch flows/velocities and branch Œîp (Pa)
  function computeBranchFlows(Q_m3s, rho, mu){
    if (Q_m3s <= 0){
      return {
        dp_branch:0,
        branches:{}
      };
    }

    // geometry in SI
    const W  = (parseFloat(document.getElementById('plenumW').value)||12)*IN_TO_M;
    const H  = (parseFloat(document.getElementById('plenumH').value)||6 )*IN_TO_M;
    const L  = (parseFloat(document.getElementById('plenumL').value)||12)*IN_TO_M;

    const b   = (parseFloat(document.getElementById('b').value)||2)*IN_TO_M;
    const s   = (parseFloat(document.getElementById('sfin').value)||1)*IN_TO_M;
    const t   = (parseFloat(document.getElementById('tfin').value)||0.05)*IN_TO_M;
    const Lf  = (parseFloat(document.getElementById('Lfin').value)||8)*IN_TO_M;
    const WHS = (parseFloat(document.getElementById('WHS').value)||W/IN_TO_M)*IN_TO_M;

    const sideGap = Math.max(0, (W - WHS)/2);
    const topGap  = Math.max(0, H - b);

    const branches = {};

    // Channel region
    const pitch = s + t;
    let AchTot = 0, Dh_ch = 0;
    if (pitch > 0 && WHS > 0 && b > 0 && Lf > 0){
      let Nch = Math.floor((WHS + s)/pitch);
      if (Nch < 1) Nch = 1;
      AchTot = Nch * s * b;
      Dh_ch = 2*s*b / Math.max(s + b,1e-9);
      branches.ch = {
        name:'Channels',
        A:AchTot,
        Dh:Dh_ch,
        L:Lf,
        Kminor:K_CH_MINOR
      };
    }

    // Top gap above fins
    if (topGap > 1e-6 && WHS > 0){
      const A_top = WHS * topGap;
      const Dh_top = 2*WHS*topGap / Math.max(WHS + topGap,1e-9);
      branches.top = {
        name:'Top gap',
        A:A_top,
        Dh:Dh_top,
        L:L,
        Kminor:K_TOP_MINOR
      };
    }

    // Side gaps
    if (sideGap > 1e-6 && b > 0){
      const A_side = 2 * sideGap * b;
      const Dh_side = 2*sideGap*b / Math.max(sideGap + b,1e-9);
      branches.side = {
        name:'Side gaps',
        A:A_side,
        Dh:Dh_side,
        L:L,
        Kminor:K_SIDE_MINOR
      };
    }

    // Fallback: if no branches defined, treat whole plenum as one duct
    if (Object.keys(branches).length === 0){
      const Apl = W * H;
      const Dh  = 2*W*H / Math.max(W + H,1e-9);
      branches.ch = {
        name:'Plenum',
        A:Apl,
        Dh:Dh,
        L:L,
        Kminor:1.0
      };
    }

    // For each branch, compute k_i such that Œîp_i ‚âà k_i Q_i¬≤
    const Vref = 1.0; // m/s
    let sumInvSqrt = 0;
    for (const key of Object.keys(branches)){
      const br = branches[key];
      const Re_ref = rho*Vref*br.Dh / mu;
      const f_ref  = frictionFactor(Re_ref);
      const dp_ref = 0.5*rho*Vref*Vref * ( f_ref*(br.L/Math.max(br.Dh,1e-9)) + br.Kminor );
      const Q_ref  = br.A * Vref;
      let k_i = 1e12;
      if (dp_ref>0 && Q_ref>0){
        k_i = dp_ref / (Q_ref*Q_ref);
      }
      br.k = k_i;
      const invSqrt = 1/Math.sqrt(k_i || 1e-12);
      br.invSqrt = invSqrt;
      sumInvSqrt += invSqrt;
    }

    // Allocate Q_i based on k_i
    if (sumInvSqrt <= 0){
      const anyKey = Object.keys(branches)[0];
      branches[anyKey].Q = Q_m3s;
      branches[anyKey].V = branches[anyKey].A>0 ? Q_m3s/branches[anyKey].A : 0;
    } else {
      for (const key of Object.keys(branches)){
        const br = branches[key];
        const frac = br.invSqrt / sumInvSqrt;
        const Qi = frac * Q_m3s;
        br.Q = Qi;
        br.V = br.A>0 ? Qi/br.A : 0;
      }
    }

    // Common branch Œîp from any branch
    let dp_branch = 0;
    const anyKey = Object.keys(branches)[0];
    if (anyKey){
      const br = branches[anyKey];
      dp_branch = br.k * br.Q * br.Q;
    }

    return {
      dp_branch,
      branches
    };
  }

  // ---------- system Œîp(Q) in SI ----------
  function systemDeltaP_SI(Q_m3s){
    if (Q_m3s<=0) return 0;
    const rho=parseFloat(document.getElementById('rho').value)||1.2;
    const mu =parseFloat(document.getElementById('mu').value)||1.82e-5;

    // geometry (in -> m)
    const W  = (parseFloat(document.getElementById('plenumW').value)||12)*IN_TO_M;
    const H  = (parseFloat(document.getElementById('plenumH').value)||6 )*IN_TO_M;
    const wIn= (parseFloat(document.getElementById('inletW').value)||4 )*IN_TO_M;
    const hIn= (parseFloat(document.getElementById('inletH').value)||4 )*IN_TO_M;

    // Inlet loss
    const Ain = Math.max(wIn*hIn,1e-9);
    const Vin = Q_m3s/Ain;
    const dp_in = K_INLET * 0.5*rho*Vin*Vin;

    // Branch network (channels + top + sides)
    const branchInfo = computeBranchFlows(Q_m3s, rho, mu);
    const dp_branch = branchInfo.dp_branch;

    // Exit loss at plenum outlet
    const Aout = Math.max(W*H,1e-9);
    const Vout = Q_m3s/Aout;
    const dp_out = K_EXIT * 0.5*rho*Vout*Vout;

    return dp_in + dp_branch + dp_out;
  }

  // ---------- operating point with scale S on fan Œîp ----------
  function computeOperatingPointScaled(fanPtsIP, scaleS){
    if (!fanPtsIP || fanPtsIP.length < 2){
      return null;
    }
    const Qmax = fanPtsIP[fanPtsIP.length-1].x;
    if (!isFinite(Qmax) || Qmax<=0){
      return null;
    }
    const nScan=80;
    let bestQ=0, bestErr=Infinity;
    const sysCurveIP=[];
    for (let i=0;i<=nScan;i++){
      const Q_ip = Qmax*i/nScan;
      const Q_si = Q_ip*CFM_TO_M3S;
      const dpFan_ip = scaleS * fanDeltaP_IP(Q_ip,fanPtsIP);
      const dpSys_pa = systemDeltaP_SI(Q_si);
      const dpSys_ip = dpSys_pa/INH2O_TO_PA;
      const err=Math.abs(dpFan_ip-dpSys_ip);
      if (err<bestErr){ bestErr=err; bestQ=Q_ip; }
      sysCurveIP.push({x:Q_ip, y:dpSys_ip});
    }
    const dpStar_ip = scaleS * fanDeltaP_IP(bestQ,fanPtsIP);
    return {Qstar_ip:bestQ, Dpstar_ip:dpStar_ip, sysCurveIP};
  }

  // For a given scale S, compute operating point AND resulting channel velocity (ft/s)
  function evaluateScale(fanPtsIP, scaleS){
    const op = computeOperatingPointScaled(fanPtsIP, scaleS);
    if (!op) return null;

    const {Qstar_ip, Dpstar_ip, sysCurveIP} = op;
    const Qstar_m3s = Qstar_ip * CFM_TO_M3S;

    const rho = parseFloat(document.getElementById('rho').value) || 1.2;
    const mu  = parseFloat(document.getElementById('mu').value)  || 1.82e-5;

    const branchInfo = computeBranchFlows(Qstar_m3s, rho, mu);
    const br = branchInfo.branches || {};

    let Vch_m = NaN;
    if (br.ch){
      Vch_m = br.ch.V;
    }
    const Vch_ft = isFinite(Vch_m) ? Vch_m * 3.28084 : NaN;

    return {
      Qstar_ip,
      Dpstar_ip,
      sysCurveIP,
      Qstar_m3s,
      Vch_ft,
      branchInfo
    };
  }

  // ---------- V2 velocity vs x ----------
  function computeVelocityProfile(Qstar_m3s){
    const rho=parseFloat(document.getElementById('rho').value)||1.2;
    const mu =parseFloat(document.getElementById('mu').value)||1.82e-5;

    const W  = (parseFloat(document.getElementById('plenumW').value)||12)*IN_TO_M;
    const H  = (parseFloat(document.getElementById('plenumH').value)||6 )*IN_TO_M;
    const b  = (parseFloat(document.getElementById('b').value)||2)*IN_TO_M;
    const s  = (parseFloat(document.getElementById('sfin').value)||1)*IN_TO_M;
    const t  = (parseFloat(document.getElementById('tfin').value)||0.05)*IN_TO_M;
    const Lf = (parseFloat(document.getElementById('Lfin').value)||8)*IN_TO_M;
    let nSlices=parseInt(document.getElementById('nSlices').value,10);
    if (!isFinite(nSlices)||nSlices<3) nSlices=20;
    if (nSlices>80) nSlices=80;

    if (Qstar_m3s<=0 || Lf<=0 || W<=0 || H<=0 || b<=0 || s<=0) return null;

    const Hp=Math.max(H-b,1e-6);
    const Apl=Math.max(W*Hp,1e-9);
    const Dh_pl = 2*W*Hp/Math.max(W+Hp,1e-9);

    const pitch=s+t;
    let Nch=Math.floor(( (parseFloat(document.getElementById('WHS').value)||12)*IN_TO_M + s)/pitch);
    if (Nch<1) Nch=1;
    const AchTot=Nch*s*b;

    const Vch_star=Qstar_m3s/Math.max(AchTot,1e-9);
    const Dh_ch=2*s*b/Math.max(s+b,1e-9);
    const Re_ch=rho*Vch_star*Dh_ch/mu;
    const f_ch =frictionFactor(Re_ch);
    const dp_ch_star=f_ch*(Lf/Math.max(Dh_ch,1e-9))*0.5*rho*Vch_star*Vch_star + 2.0*0.5*rho*Vch_star*Vch_star;

    let Kch_eff=dp_ch_star>0 ? dp_ch_star/(0.5*rho*Vch_star*Vch_star) : 0;
    if (!isFinite(Kch_eff) || Kch_eff<=0){
      const xs=[],Vs=[],dx=Lf/nSlices;
      for (let i=0;i<nSlices;i++){ xs.push((i+0.5)*dx); Vs.push(Vch_star); }
      return {xs,Vs};
    }

    const dx=Lf/nSlices;
    const Aslice=AchTot/nSlices;
    const P_out=0;

    function runForP0(P0,capture){
      let Pp=P0, Qp=Qstar_m3s, sumQ=0;
      const xs=[],Vs=[];
      for (let i=0;i<nSlices;i++){
        let Vch_i=0, qi=0;
        if (Pp>P_out){
          Vch_i=Math.sqrt(2*(Pp-P_out)/(rho*Kch_eff));
          qi=Aslice*Vch_i;
        }
        sumQ+=qi;
        if (capture){ xs.push((i+0.5)*dx); Vs.push(Vch_i); }
        Qp=Qstar_m3s-sumQ;
        if (Qp<0) Qp=0;
        const Vpl_i = Apl>0 ? Qp/Apl : 0;
        const Re_pl_i = rho*Vpl_i*Dh_pl/mu;
        const f_pl_i = frictionFactor(Re_pl_i);
        const dp_pl_i = f_pl_i*(dx/Math.max(Dh_pl,1e-9))*0.5*rho*Vpl_i*Vpl_i;
        Pp -= dp_pl_i;
      }
      return {sumQ,xs,Vs};
    }

    let dpRef=dp_ch_star;
    if (!isFinite(dpRef)||dpRef<=0) dpRef=100;
    let P0_low=0.1*dpRef, P0_high=10*dpRef;
    if (P0_low<=0) P0_low=10;
    if (P0_high<=P0_low) P0_high=P0_low*100;

    let sum_low=runForP0(P0_low,false).sumQ;
    let sum_high=runForP0(P0_high,false).sumQ;
    if (!isFinite(sum_low)||!isFinite(sum_high)||sum_low>Qstar_m3s||sum_high<Qstar_m3s){
      const xs=[],Vs=[],dx=Lf/nSlices;
      for (let i=0;i<nSlices;i++){ xs.push((i+0.5)*dx); Vs.push(Vch_star); }
      return {xs,Vs};
    }

    let P0_mid=P0_low;
    for (let it=0;it<30;it++){
      P0_mid=0.5*(P0_low+P0_high);
      const smid=runForP0(P0_mid,false).sumQ;
      if (!isFinite(smid)) break;
      if (smid>Qstar_m3s) P0_high=P0_mid; else P0_low=P0_mid;
    }
    const finalRun=runForP0(P0_mid,true);
    return {xs:finalRun.xs, Vs:finalRun.Vs};
  }

  // ---------- charts ----------
  const ctxCurve=document.getElementById('curveChart').getContext('2d');
  const curveConfig={
    type:'line',
    data:{datasets:[
      {label:'Fan curve (scaled)', data:[], borderWidth:2, tension:0.2, pointRadius:2},
      {label:'System curve', data:[], borderWidth:2, borderDash:[4,4], tension:0.2, pointRadius:0},
      {label:'Operating point', data:[], type:'scatter', pointRadius:4, pointStyle:'circle'}
    ]},
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        x:{type:'linear', title:{display:true,text:'Q (cfm)'}, ticks:{maxTicksLimit:6}},
        y:{title:{display:true,text:'Œîp (inH‚ÇÇO)'}, ticks:{maxTicksLimit:6}}
      },
      plugins:{legend:{display:true,position:'bottom'}}
    }
  };
  const curveChart=new Chart(ctxCurve,curveConfig);

  function refreshFanChart(){
    const basePts = readFanTable();
    curveConfig.data.datasets[0].data = basePts;  // base fan until a Solve applies scaling
    curveConfig.data.datasets[1].data = [];       // system curve cleared
    curveConfig.data.datasets[2].data = [];       // operating point cleared
    curveChart.update();
  }
  refreshFanChart();

  const ctxVel=document.getElementById('velChart').getContext('2d');
  const velConfig={
    type:'line',
    data:{datasets:[
      {label:'V_ch(x)', data:[], borderWidth:2, tension:0.2, pointRadius:0}
    ]},
    options:{
      responsive:true, maintainAspectRatio:false,
      scales:{
        x:{type:'linear', title:{display:true,text:'x / L_f'}, ticks:{maxTicksLimit:6}},
        y:{title:{display:true,text:'V_ch (m/s)'}, ticks:{maxTicksLimit:6}}
      },
      plugins:{legend:{display:false}}
    }
  };
  const velChart=new Chart(ctxVel,velConfig);

  // =========================
  // 3D VIEW (geometry + velocity-colored blocks)
  // =========================
  let scene, camera, renderer, plenumGroup, velGroup;
  let orbit = { radius:15, theta:Math.PI/4, phi:Math.PI/4, target:new THREE.Vector3(0,0,0) };
  let isDragging = false, lastX=0, lastY=0, startTheta=0, startPhi=0;
  let lastBranchVels = null; // {Vch_m, Vtop_m, Vside_m}

  function init3D() {
    if (!window.THREE) {
      const m = document.getElementById('view3D-msg');
      if (m) m.textContent = "Three.js failed to load.";
      return;
    }
    const container = document.getElementById('view3D');
    const w = container.clientWidth || 580;
    const h = container.clientHeight || 260;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf9fafb);

    camera = new THREE.PerspectiveCamera(40, w/h, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(w, h);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setClearColor(0xf9fafb, 1);
    container.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(10, 15, 8);
    scene.add(dir);

    plenumGroup = new THREE.Group();
    scene.add(plenumGroup);

    update3DGeometry();          // geometry only, no velocity blocks yet
    setup3DInteractions(renderer.domElement);

    window.addEventListener('resize', onResize3D);

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  }

  function setup3DInteractions(canvas) {
    canvas.addEventListener('mousedown', (e)=>{
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
      startTheta = orbit.theta;
      startPhi   = orbit.phi;
    });
    window.addEventListener('mousemove', (e)=>{
      if (!isDragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      const rotSpeed = 0.005;
      orbit.theta = startTheta - dx * rotSpeed;
      orbit.phi   = startPhi   - dy * rotSpeed;
      const eps = 0.1;
      orbit.phi = Math.max(eps, Math.min(Math.PI-eps, orbit.phi));
      updateCameraFromOrbit();
    });
    window.addEventListener('mouseup', ()=>{ isDragging=false; });
    canvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const zoomFactor = 1 + Math.sign(e.deltaY) * 0.1;
      orbit.radius *= zoomFactor;
      orbit.radius = Math.max(2, Math.min(100, orbit.radius));
      updateCameraFromOrbit();
    }, {passive:false});
  }

  function updateCameraFromOrbit() {
    if (!camera) return;
    const {radius, theta, phi, target} = orbit;
    const x = target.x + radius * Math.sin(phi) * Math.cos(theta);
    const y = target.y + radius * Math.cos(phi);
    const z = target.z + radius * Math.sin(phi) * Math.sin(theta);
    camera.position.set(x,y,z);
    camera.lookAt(target);
  }

  function onResize3D() {
    if (!renderer || !camera) return;
    const container = document.getElementById('view3D');
    const w = container.clientWidth || 580;
    const h = container.clientHeight || 260;
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
    renderer.setSize(w,h);
  }

  function clearGroup(group) {
    if (!group) return;
    while (group.children.length > 0) {
      const obj = group.children[0];
      group.remove(obj);
      if (obj.geometry) obj.geometry.dispose();
      if (obj.material) {
        if (Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
        else obj.material.dispose();
      }
    }
  }

  function update3DGeometry() {
    if (!plenumGroup || !window.THREE) return;

    // Clear everything (geometry + any old velocity blocks)
    clearGroup(plenumGroup);
    velGroup = null;

    const W   = parseFloat(document.getElementById('plenumW').value) || 12;
    const H   = parseFloat(document.getElementById('plenumH').value) || 6;
    const L   = parseFloat(document.getElementById('plenumL').value) || 12;
    const wIn = parseFloat(document.getElementById('inletW').value)  || 4;
    const hIn = parseFloat(document.getElementById('inletH').value)  || 4;

    const b   = parseFloat(document.getElementById('b').value)       || 2;
    const s   = parseFloat(document.getElementById('sfin').value)    || 1;
    const t   = parseFloat(document.getElementById('tfin').value)    || 0.05;
    const Lf  = parseFloat(document.getElementById('Lfin').value)    || 8;
    const xHS = parseFloat(document.getElementById('xHS').value)     || 3;
    const WHS = parseFloat(document.getElementById('WHS').value)     || W;

    const maxDim = Math.max(L, W, H, 0.1);
    const scale = 10 / maxDim;
    const Ls = L * scale;
    const Ws = W * scale;
    const Hs = H * scale;

    // Plenum box (wireframe + light fill)
    const plenumGeom = new THREE.BoxGeometry(Ls, Hs, Ws);
    const edges = new THREE.EdgesGeometry(plenumGeom);
    const wireMat = new THREE.LineBasicMaterial({color:0x111111});
    const wireMesh = new THREE.LineSegments(edges, wireMat);
    plenumGroup.add(wireMesh);

    const plenumMat = new THREE.MeshBasicMaterial({
      color:0xcbd5f5,
      transparent:true,
      opacity:0.12,
      depthWrite:false
    });
    const plenumMesh = new THREE.Mesh(plenumGeom, plenumMat);
    plenumGroup.add(plenumMesh);

    // Inlet block
    const AinW = Math.min(wIn, L) * scale;
    const AinH = Math.min(hIn, H) * scale;
    const inletGeom = new THREE.BoxGeometry(0.04*Ls, AinH, AinW);
    const inletMat  = new THREE.MeshBasicMaterial({color:0x4b5563});
    const inletMesh = new THREE.Mesh(inletGeom, inletMat);
    inletMesh.position.set(-Ls/2 - 0.02*Ls, 0, 0);
    plenumGroup.add(inletMesh);

    // Heat-sink base & fins (fins same color as base)
    if (b > 0 && Lf > 0 && WHS > 0) {
      const baseThickness = 0.03 * Hs;
      const baseLen   = Math.min(Lf, L - xHS) * scale;
      const baseWidth = Math.min(WHS, W) * scale;

      const baseColor = 0x9ca3af;

      const baseGeom = new THREE.BoxGeometry(baseLen, baseThickness, baseWidth);
      const baseMat  = new THREE.MeshPhongMaterial({color:baseColor});
      const baseMesh = new THREE.Mesh(baseGeom, baseMat);
      const xHSs = (-Ls/2) + xHS * scale + baseLen/2;
      const yBase = -Hs/2 + baseThickness/2;
      baseMesh.position.set(xHSs, yBase, 0);
      plenumGroup.add(baseMesh);

      const pitch = s + t;
      if (pitch > 0) {
        let Nch = Math.floor((WHS + s) / pitch);
        if (Nch < 1) Nch = 1;
        const maxFinsToDraw = 60;
        const drawEvery = Math.max(1, Math.floor(Nch / maxFinsToDraw));

        const finHeight = Math.min(b, H) * scale;
        const finThick  = t * scale;
        const finLen    = baseLen;
        const WfinTotal = baseWidth;

        const finGeom = new THREE.BoxGeometry(finLen, finHeight, finThick);
        const finMat  = new THREE.MeshPhongMaterial({color:baseColor});

        for (let i=0; i<Nch; i+=drawEvery) {
          const z0 = -WfinTotal/2 + (i + 0.5) * pitch * scale;
          if (z0 < -WfinTotal/2 || z0 > WfinTotal/2) continue;

          const finMesh = new THREE.Mesh(finGeom, finMat.clone());
          const yFin = yBase + baseThickness/2 + finHeight/2;
          finMesh.position.set(xHSs, yFin, z0);
          plenumGroup.add(finMesh);
        }
      }
    }

    // Fit camera to plenum box
    if (camera) {
      const box = new THREE.Box3().setFromObject(plenumGroup);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);
      const maxSize = Math.max(size.x, size.y, size.z);
      orbit.target.copy(center);
      orbit.radius = maxSize * 1.8;
      camera.near = orbit.radius / 50;
      camera.far  = orbit.radius * 50;
      camera.updateProjectionMatrix();
      updateCameraFromOrbit();
    }
  }

  // Velocity-colored blocks
  function updateVelocityBlocks(branchVels){
    if (!plenumGroup || !window.THREE) return;
    if (!branchVels) return;

    // Remove old velocity blocks
    if (velGroup) {
      clearGroup(velGroup);
      plenumGroup.remove(velGroup);
    }
    velGroup = new THREE.Group();
    plenumGroup.add(velGroup);

    const W   = parseFloat(document.getElementById('plenumW').value) || 12;
    const H   = parseFloat(document.getElementById('plenumH').value) || 6;
    const L   = parseFloat(document.getElementById('plenumL').value) || 12;
    const b   = parseFloat(document.getElementById('b').value)       || 2;
    const Lf  = parseFloat(document.getElementById('Lfin').value)    || 8;
    const xHS = parseFloat(document.getElementById('xHS').value)     || 3;
    const WHS = parseFloat(document.getElementById('WHS').value)     || W;

    const maxDim = Math.max(L, W, H, 0.1);
    const scale = 10 / maxDim;
    const Ls = L * scale;
    const Ws = W * scale;
    const Hs = H * scale;

    const sideGap = Math.max(0, (W - WHS)/2);
    const topGap  = Math.max(0, H - b);

    const yBottom = -Hs/2;

    const b_s  = b * scale;
    const WHS_s = WHS * scale;
    const sideGap_s = sideGap * scale;
    const topGap_s  = topGap * scale;

    const xHS_start = (-Ls/2) + xHS * scale;
    const Lf_s = Math.min(Lf, L - xHS) * scale;
    const xHS_mid   = xHS_start + 0.5*Lf_s;

    // Velocities (m/s)
    const Vch = branchVels.Vch_m || 0;
    const Vtop = branchVels.Vtop_m || 0;
    const Vside = branchVels.Vside_m || 0;

    const entries = [];
    if (Vch > 0) entries.push({key:'ch', V:Vch});
    if (Vtop > 0) entries.push({key:'top', V:Vtop});
    if (Vside> 0) entries.push({key:'side',V:Vside});

    if (entries.length === 0) return;

    // Rank by velocity
    entries.sort((a,b)=>b.V - a.V); // highest first

    // Color palette: darkest for fastest, lightest for slowest
    const palette = [0x0b3a8a, 0x1d4ed8, 0x93c5fd];

    const colorMap = {};
    for (let i=0;i<entries.length;i++){
      colorMap[entries[i].key] = palette[Math.min(i, palette.length-1)];
    }

    // Channel block: over the fin region
    if (Vch > 0 && Lf_s>0 && b_s>0 && WHS_s>0){
      const chGeom = new THREE.BoxGeometry(Lf_s, b_s, WHS_s);
      const chMat  = new THREE.MeshBasicMaterial({
        color: colorMap.ch || palette[1],
        transparent:true,
        opacity:0.35
      });
      const yChCenter = yBottom + b_s/2;
      const chMesh = new THREE.Mesh(chGeom, chMat);
      chMesh.position.set(xHS_mid, yChCenter, 0);
      velGroup.add(chMesh);
    }

    // Top block: above fins, over HS width
    if (Vtop > 0 && topGap_s>0 && WHS_s>0){
      const topGeom = new THREE.BoxGeometry(Ls, topGap_s, WHS_s);
      const topMat  = new THREE.MeshBasicMaterial({
        color: colorMap.top || palette[2],
        transparent:true,
        opacity:0.30
      });
      const yTopCenter = yBottom + b_s + topGap_s/2;
      const topMesh = new THREE.Mesh(topGeom, topMat);
      topMesh.position.set(0, yTopCenter, 0);
      velGroup.add(topMesh);
    }

    // Side blocks: left & right, height b
    if (Vside > 0 && sideGap_s>0 && b_s>0){
      const sideGeom = new THREE.BoxGeometry(Ls, b_s, sideGap_s);
      const sideMat  = new THREE.MeshBasicMaterial({
        color: colorMap.side || palette[2],
        transparent:true,
        opacity:0.30
      });

      const ySideCenter = yBottom + b_s/2;
      const zLeft  = -(WHS_s/2 + sideGap_s/2);
      const zRight = +(WHS_s/2 + sideGap_s/2);

      const leftMesh = new THREE.Mesh(sideGeom, sideMat);
      leftMesh.position.set(0, ySideCenter, zLeft);
      velGroup.add(leftMesh);

      const rightMesh = new THREE.Mesh(sideGeom, sideMat.clone());
      rightMesh.position.set(0, ySideCenter, zRight);
      velGroup.add(rightMesh);
    }
  }

  function updateVelocityLegend(branchVels){
    const div = document.getElementById('velLegend');
    if (!div) return;

    if (!branchVels){
      div.textContent = '';
      return;
    }

    const Vch = branchVels.Vch_m || 0;
    const Vtop = branchVels.Vtop_m || 0;
    const Vside = branchVels.Vside_m || 0;

    const entries = [];
    if (Vch > 0) entries.push({key:'ch', name:'Channels', V:Vch});
    if (Vtop> 0) entries.push({key:'top', name:'Top gap', V:Vtop});
    if (Vside>0) entries.push({key:'side',name:'Side gaps', V:Vside});

    if (entries.length === 0){
      div.textContent = '';
      return;
    }

    // Same ranking as blocks
    entries.sort((a,b)=>b.V - a.V);
    const paletteCSS = ['#0b3a8a','#1d4ed8','#93c5fd'];
    const colorByKey = {};
    for (let i=0;i<entries.length;i++){
      colorByKey[entries[i].key] = paletteCSS[Math.min(i, paletteCSS.length-1)];
    }

    let html = '<div style="margin-top:4px;margin-bottom:2px;">Velocity legend (ft/s):</div>';
    for (const e of entries){
      const V_ft = e.V * 3.28084;
      html += `
        <div class="row">
          <span class="swatch" style="background:${colorByKey[e.key]};"></span>
          <span>${e.name}: ${V_ft.toFixed(1)} ft/s</span>
        </div>`;
    }
    div.innerHTML = html;
  }

  // Kick off 3D on load
  window.addEventListener('load', () => {
    init3D();
  });

  // Rebuild geometry (but NOT velocity blocks) when geometry inputs change
  const geomIds = [
    'plenumW','plenumH','plenumL',
    'inletW','inletH','xHS','Lfin','b','WHS','sfin','tfin'
  ];
  geomIds.forEach(id=>{
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', () => {
      update3DGeometry();
      // clear legend and blocks if geometry changes
      lastBranchVels = null;
      updateVelocityLegend(null);
    });
  });

  // -------------------------
  // Solve button: target Vch (ft/s) + fan scaling + 3-branch split + velocity blocks
  // -------------------------
  document.getElementById('solveBtn').addEventListener('click', () => {
    const fanPtsIP = readFanTable();
    if (!fanPtsIP || fanPtsIP.length < 2){
      alert("Need at least two fan points.");
      return;
    }

    let Vch_target_ft = parseFloat(document.getElementById('Vch_target').value);
    if (!isFinite(Vch_target_ft) || Vch_target_ft <= 0){
      // If no valid target specified, just treat scale factor as 1.0
      Vch_target_ft = NaN;
    }

    const rho = parseFloat(document.getElementById('rho').value) || 1.2;
    const mu  = parseFloat(document.getElementById('mu').value)  || 1.82e-5;

    let scaleS = 1.0;
    let bestEval = null;

    if (isFinite(Vch_target_ft) && Vch_target_ft > 0){
      // Iteratively adjust scaleS so Vch_avg ‚âà target (ft/s)
      for (let it=0; it<15; it++){
        const evalObj = evaluateScale(fanPtsIP, scaleS);
        if (!evalObj || !isFinite(evalObj.Vch_ft)){
          break;
        }
        bestEval = {...evalObj, scaleS};
        const err = evalObj.Vch_ft - Vch_target_ft;
        if (Math.abs(err) <= 0.01 * Vch_target_ft){ // within 1%
          break;
        }
        // Update scale: if channel velocity is too low, increase S; if too high, decrease S
        scaleS *= Vch_target_ft / Math.max(evalObj.Vch_ft, 1e-6);
        // Keep S within reasonable bounds
        if (scaleS < 0.05) scaleS = 0.05;
        if (scaleS > 20)  scaleS = 20;
      }
    }

    // If no target or iteration failed, fall back to S = 1
    if (!bestEval){
      const evalObj = evaluateScale(fanPtsIP, 1.0);
      if (!evalObj){
        alert("Unable to find operating point. Check inputs.");
        return;
      }
      bestEval = {...evalObj, scaleS:1.0};
      scaleS = 1.0;
    }

    const {Qstar_ip, Dpstar_ip, sysCurveIP, Qstar_m3s, Vch_ft} = bestEval;

    // Basic plenum / inlet metrics at final Q*
    const W_in   = (parseFloat(document.getElementById('plenumW').value) || 12) * IN_TO_M;
    const H_in   = (parseFloat(document.getElementById('plenumH').value) ||  6) * IN_TO_M;
    const wIn_in = (parseFloat(document.getElementById('inletW').value)  ||  4) * IN_TO_M;
    const hIn_in = (parseFloat(document.getElementById('inletH').value)  ||  4) * IN_TO_M;

    // Inlet velocity
    const Ain = Math.max(wIn_in * hIn_in, 1e-9);
    const Vin_m = Qstar_m3s / Ain;
    const Vin_ft = Vin_m * 3.28084;

    // Plenum Re based on full cross-section
    const Apl_full = Math.max(W_in * H_in, 1e-9);
    const Vpl = Qstar_m3s / Apl_full;
    const Dh_pl = 2 * W_in * H_in / Math.max(W_in + H_in, 1e-9);
    const Re_pl = rho * Vpl * Dh_pl / mu;

    // Channel Reynolds
    const branchInfo = computeBranchFlows(Qstar_m3s, rho, mu);
    const br = branchInfo.branches || {};
    let Vch_m = NaN, Re_ch = NaN;
    if (br.ch){
      Vch_m = br.ch.V;
      Re_ch = rho * br.ch.V * br.ch.Dh / mu;
    }
    const Vch_ft_final = isFinite(Vch_m) ? Vch_m * 3.28084 : Vch_ft;

    // Fan air power
    const Dpstar_Pa = Dpstar_ip * INH2O_TO_PA;
    const power_W = Qstar_m3s * Dpstar_Pa;
    const HP = power_W / 745.7;

    // Update numeric results (IP display)
    document.getElementById('Qstar').textContent  = isFinite(Qstar_ip) ? Qstar_ip.toFixed(1) : '‚Äî';
    document.getElementById('Dpstar').textContent = isFinite(Dpstar_ip) ? Dpstar_ip.toFixed(3) : '‚Äî';
    document.getElementById('Vin').textContent    = isFinite(Vin_ft)    ? Vin_ft.toFixed(1)     : '‚Äî';
    document.getElementById('Vch').textContent    = isFinite(Vch_ft_final) ? Vch_ft_final.toFixed(1) : '‚Äî';
    document.getElementById('Re_pl').textContent  = isFinite(Re_pl)     ? Re_pl.toFixed(0)      : '‚Äî';
    document.getElementById('Re_ch').textContent  = isFinite(Re_ch)     ? Re_ch.toFixed(0)      : '‚Äî';
    document.getElementById('HP').textContent     = isFinite(HP)        ? HP.toFixed(3)         : '‚Äî';
    document.getElementById('ScaleFactor').textContent = isFinite(scaleS) ? scaleS.toFixed(3)   : '‚Äî';

    // Update fan/system chart:
    // - dataset[0]: scaled fan curve
    // - dataset[1]: system curve
    // - dataset[2]: operating point
    const scaledFan = fanPtsIP.map(p => ({x:p.x, y:p.y*scaleS}));
    curveConfig.data.datasets[0].data = scaledFan;
    curveConfig.data.datasets[1].data = sysCurveIP;
    curveConfig.data.datasets[2].data = [{x: Qstar_ip, y: Dpstar_ip}];
    curveChart.update();

    // V2 velocity profile chart (internal m/s)
    const prof = computeVelocityProfile(Qstar_m3s);
    if (!prof || !prof.Vs || prof.Vs.length === 0) {
      velConfig.data.datasets[0].data = [];
    } else {
      const { xs, Vs } = prof;
      const Lf_in = (parseFloat(document.getElementById('Lfin').value) || 8) * IN_TO_M;
      const data = [];
      for (let i = 0; i < xs.length; i++) {
        const xNorm = Lf_in > 0 ? xs[i] / Lf_in : 0;
        data.push({ x: xNorm, y: Vs[i] });
      }
      velConfig.data.datasets[0].data = data;
    }
    velChart.update();

    // Store branch velocities for 3D coloring (m/s)
    const Vtop_m = (br.top && br.top.V) ? br.top.V : 0;
    const Vside_m = (br.side && br.side.V) ? br.side.V : 0;
    lastBranchVels = {
      Vch_m: isFinite(Vch_m) ? Vch_m : 0,
      Vtop_m: isFinite(Vtop_m) ? Vtop_m : 0,
      Vside_m: isFinite(Vside_m) ? Vside_m : 0
    };

    // Refresh geometry and draw velocity-colored blocks + legend
    update3DGeometry();
    updateVelocityBlocks(lastBranchVels);
    updateVelocityLegend(lastBranchVels);
  });

// -------------------------
  // EXPORT/IMPORT FUNCTIONS
  // -------------------------

  // Helper function to get formatted timestamp
  function getTimestamp() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
  }

  // 1. EXPORT JSON BUTTON
  document.getElementById('exportJsonBtn').addEventListener('click', () => {
    const data = {
      timestamp: new Date().toISOString(),
      moduleType: 'plenum_fan_matching_v2_target_velocity',
      air: {
        rho: parseFloat(document.getElementById('rho').value),
        mu: parseFloat(document.getElementById('mu').value)
      },
      plenum: {
        width_W: parseFloat(document.getElementById('plenumW').value),
        height_H: parseFloat(document.getElementById('plenumH').value),
        length_L: parseFloat(document.getElementById('plenumL').value)
      },
      inlet: {
        width_w: parseFloat(document.getElementById('inletW').value),
        height_h: parseFloat(document.getElementById('inletH').value),
        position_x: parseFloat(document.getElementById('inletX').value)
      },
      heatSink: {
        fin_height_b: parseFloat(document.getElementById('b').value),
        fin_thickness_t: parseFloat(document.getElementById('tfin').value),
        fin_spacing_s: parseFloat(document.getElementById('sfin').value),
        fin_length_Lf: parseFloat(document.getElementById('Lfin').value),
        hs_lead_edge_x: parseFloat(document.getElementById('xHS').value),
        hs_width: parseFloat(document.getElementById('WHS').value)
      },
      fanCurve: readFanTable(),
      velocity: {
        target_Vch_ft_s: parseFloat(document.getElementById('Vch_target').value),
        nSlices: parseInt(document.getElementById('nSlices').value, 10)
      }
    };
    
    const jsonStr = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `plenum_fan_target_vel_config_${getTimestamp()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // 2. IMPORT JSON BUTTON
  document.getElementById('importJsonBtn').addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          
          // Air properties
          if (data.air) {
            document.getElementById('rho').value = data.air.rho;
            document.getElementById('mu').value = data.air.mu;
          }
          
          // Plenum
          if (data.plenum) {
            document.getElementById('plenumW').value = data.plenum.width_W;
            document.getElementById('plenumH').value = data.plenum.height_H;
            document.getElementById('plenumL').value = data.plenum.length_L;
          }
          
          // Inlet
          if (data.inlet) {
            document.getElementById('inletW').value = data.inlet.width_w;
            document.getElementById('inletH').value = data.inlet.height_h;
            document.getElementById('inletX').value = data.inlet.position_x;
          }
          
          // Heat Sink
          if (data.heatSink) {
            document.getElementById('b').value = data.heatSink.fin_height_b;
            document.getElementById('tfin').value = data.heatSink.fin_thickness_t;
            document.getElementById('sfin').value = data.heatSink.fin_spacing_s;
            document.getElementById('Lfin').value = data.heatSink.fin_length_Lf;
            document.getElementById('xHS').value = data.heatSink.hs_lead_edge_x;
            document.getElementById('WHS').value = data.heatSink.hs_width;
          }
          
          // Fan Curve
          if (data.fanCurve && Array.isArray(data.fanCurve)) {
            const tbody = document.querySelector('#fanTable tbody');
            tbody.innerHTML = '';
            data.fanCurve.forEach((pt, idx) => {
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${idx + 1}</td><td><input value="${pt.x}"></td><td><input value="${pt.y}"></td>`;
              tbody.appendChild(tr);
            });
            refreshFanChart();
          }
          
          // Velocity
          if (data.velocity) {
            document.getElementById('Vch_target').value = data.velocity.target_Vch_ft_s;
            document.getElementById('nSlices').value = data.velocity.nSlices;
          }
          
          // Update 3D view
          update3DGeometry();
          
          alert('Configuration loaded successfully!');
        } catch (err) {
          alert('Error loading JSON file: ' + err.message);
        }
      };
      reader.readAsText(file);
    };
    input.click();
  });

  // 3. EXPORT CSV BUTTON
  document.getElementById('exportCsvBtn').addEventListener('click', () => {
    const timestamp = getTimestamp();
    
    // Get current results
    const Qstar = document.getElementById('Qstar').textContent;
    const Dpstar = document.getElementById('Dpstar').textContent;
    const Vin = document.getElementById('Vin').textContent;
    const Vch = document.getElementById('Vch').textContent;
    const Re_pl = document.getElementById('Re_pl').textContent;
    const Re_ch = document.getElementById('Re_ch').textContent;
    const HP = document.getElementById('HP').textContent;
    const ScaleFactor = document.getElementById('ScaleFactor').textContent;
    
    if (Qstar === '‚Äî') {
      alert('No results to export. Please solve first.');
      return;
    }
    
    // Results CSV
    let csv = 'Parameter,Value,Units\n';
    csv += `Flow rate Q*,${Qstar},cfm\n`;
    csv += `Back pressure Œîp*,${Dpstar},inH‚ÇÇO\n`;
    csv += `Inlet velocity,${Vin},ft/s\n`;
    csv += `Channel velocity avg,${Vch},ft/s\n`;
    csv += `Reynolds plenum,${Re_pl},-\n`;
    csv += `Reynolds channel,${Re_ch},-\n`;
    csv += `Fan air power,${HP},HP\n`;
    csv += `Fan scale factor,${ScaleFactor},-\n`;
    csv += `Target channel velocity,${document.getElementById('Vch_target').value},ft/s\n`;
    
    // Download results CSV
    const blob1 = new Blob([csv], { type: 'text/csv' });
    const url1 = URL.createObjectURL(blob1);
    const a1 = document.createElement('a');
    a1.href = url1;
    a1.download = `plenum_fan_target_vel_results_${timestamp}.csv`;
    a1.click();
    URL.revokeObjectURL(url1);
    
    // Fan curve CSV (base, unscaled)
    const fanPts = readFanTable();
    let fanCsv = 'Q (cfm),Œîp (inH‚ÇÇO) [base]\n';
    fanPts.forEach(pt => {
      fanCsv += `${pt.x},${pt.y}\n`;
    });
    
    const blob2 = new Blob([fanCsv], { type: 'text/csv' });
    const url2 = URL.createObjectURL(blob2);
    const a2 = document.createElement('a');
    a2.href = url2;
    a2.download = `plenum_fan_base_curve_${timestamp}.csv`;
    a2.click();
    URL.revokeObjectURL(url2);
    
    // Scaled fan curve CSV
    const scaleFactorNum = parseFloat(ScaleFactor);
    if (isFinite(scaleFactorNum)) {
      let scaledCsv = 'Q (cfm),Œîp (inH‚ÇÇO) [scaled]\n';
      fanPts.forEach(pt => {
        scaledCsv += `${pt.x},${(pt.y * scaleFactorNum).toFixed(4)}\n`;
      });
      
      const blob2b = new Blob([scaledCsv], { type: 'text/csv' });
      const url2b = URL.createObjectURL(blob2b);
      const a2b = document.createElement('a');
      a2b.href = url2b;
      a2b.download = `plenum_fan_scaled_curve_${timestamp}.csv`;
      a2b.click();
      URL.revokeObjectURL(url2b);
    }
    
    // Velocity profile CSV if available
    const velData = velConfig.data.datasets[0].data;
    if (velData && velData.length > 0) {
      let velCsv = 'x/Lf,V_ch (m/s)\n';
      velData.forEach(pt => {
        velCsv += `${pt.x.toFixed(4)},${pt.y.toFixed(4)}\n`;
      });
      
      const blob3 = new Blob([velCsv], { type: 'text/csv' });
      const url3 = URL.createObjectURL(blob3);
      const a3 = document.createElement('a');
      a3.href = url3;
      a3.download = `plenum_velocity_profile_${timestamp}.csv`;
      a3.click();
      URL.revokeObjectURL(url3);
    }
  });

  // 4. EXPORT ZIP BUTTON (CSV + Images + Config)
  document.getElementById('exportZipBtn').addEventListener('click', async () => {
    if (typeof JSZip === 'undefined') {
      alert('JSZip library not loaded. Please refresh the page.');
      return;
    }
    
    const Qstar = document.getElementById('Qstar').textContent;
    if (Qstar === '‚Äî') {
      alert('No results to export. Please solve first.');
      return;
    }
    
    const zip = new JSZip();
    const timestamp = getTimestamp();
    
    const ScaleFactor = document.getElementById('ScaleFactor').textContent;
    const scaleFactorNum = parseFloat(ScaleFactor);
    
    // 1. Results CSV
    let resultsCsv = 'Parameter,Value,Units\n';
    resultsCsv += `Flow rate Q*,${document.getElementById('Qstar').textContent},cfm\n`;
    resultsCsv += `Back pressure Œîp*,${document.getElementById('Dpstar').textContent},inH‚ÇÇO\n`;
    resultsCsv += `Inlet velocity,${document.getElementById('Vin').textContent},ft/s\n`;
    resultsCsv += `Channel velocity avg,${document.getElementById('Vch').textContent},ft/s\n`;
    resultsCsv += `Reynolds plenum,${document.getElementById('Re_pl').textContent},-\n`;
    resultsCsv += `Reynolds channel,${document.getElementById('Re_ch').textContent},-\n`;
    resultsCsv += `Fan air power,${document.getElementById('HP').textContent},HP\n`;
    resultsCsv += `Fan scale factor,${ScaleFactor},-\n`;
    resultsCsv += `Target channel velocity,${document.getElementById('Vch_target').value},ft/s\n`;
    zip.file(`results_${timestamp}.csv`, resultsCsv);
    
    // 2. Base fan curve CSV
    const fanPts = readFanTable();
    let fanCsv = 'Q (cfm),Œîp (inH‚ÇÇO) [base]\n';
    fanPts.forEach(pt => {
      fanCsv += `${pt.x},${pt.y}\n`;
    });
    zip.file(`fan_curve_base_${timestamp}.csv`, fanCsv);
    
    // 3. Scaled fan curve CSV
    if (isFinite(scaleFactorNum)) {
      let scaledCsv = 'Q (cfm),Œîp (inH‚ÇÇO) [scaled]\n';
      fanPts.forEach(pt => {
        scaledCsv += `${pt.x},${(pt.y * scaleFactorNum).toFixed(4)}\n`;
      });
      zip.file(`fan_curve_scaled_${timestamp}.csv`, scaledCsv);
    }
    
    // 4. Velocity profile CSV
    const velData = velConfig.data.datasets[0].data;
    if (velData && velData.length > 0) {
      let velCsv = 'x/Lf,V_ch (m/s)\n';
      velData.forEach(pt => {
        velCsv += `${pt.x.toFixed(4)},${pt.y.toFixed(4)}\n`;
      });
      zip.file(`velocity_profile_${timestamp}.csv`, velCsv);
    }
    
    // 5. Fan & System curves chart image
    const curveCanvas = document.getElementById('curveChart');
    const curveDataUrl = curveCanvas.toDataURL('image/png');
    const curveBase64 = curveDataUrl.split(',')[1];
    zip.file(`fan_system_curves_${timestamp}.png`, curveBase64, { base64: true });
    
    // 6. Velocity chart image
    const velCanvas = document.getElementById('velChart');
    const velImgUrl = velCanvas.toDataURL('image/png');
    const velBase64 = velImgUrl.split(',')[1];
    zip.file(`velocity_distribution_${timestamp}.png`, velBase64, { base64: true });
    
    // 7. 3D view image
    if (renderer && renderer.domElement) {
      const view3dUrl = renderer.domElement.toDataURL('image/png');
      const view3dBase64 = view3dUrl.split(',')[1];
      zip.file(`3d_geometry_view_${timestamp}.png`, view3dBase64, { base64: true });
    }
    
    // 8. Configuration JSON
    const config = {
      timestamp: new Date().toISOString(),
      moduleType: 'plenum_fan_matching_v2_target_velocity',
      air: {
        rho: parseFloat(document.getElementById('rho').value),
        mu: parseFloat(document.getElementById('mu').value)
      },
      plenum: {
        width_W_in: parseFloat(document.getElementById('plenumW').value),
        height_H_in: parseFloat(document.getElementById('plenumH').value),
        length_L_in: parseFloat(document.getElementById('plenumL').value)
      },
      inlet: {
        width_w_in: parseFloat(document.getElementById('inletW').value),
        height_h_in: parseFloat(document.getElementById('inletH').value),
        position_x_in: parseFloat(document.getElementById('inletX').value)
      },
      heatSink: {
        fin_height_b_in: parseFloat(document.getElementById('b').value),
        fin_thickness_t_in: parseFloat(document.getElementById('tfin').value),
        fin_spacing_s_in: parseFloat(document.getElementById('sfin').value),
        fin_length_Lf_in: parseFloat(document.getElementById('Lfin').value),
        hs_lead_edge_x_in: parseFloat(document.getElementById('xHS').value),
        hs_width_in: parseFloat(document.getElementById('WHS').value)
      },
      fanCurve_base: readFanTable(),
      velocity: {
        target_Vch_ft_s: parseFloat(document.getElementById('Vch_target').value),
        nSlices: parseInt(document.getElementById('nSlices').value, 10)
      },
      results: {
        flow_rate_Q_cfm: document.getElementById('Qstar').textContent,
        back_pressure_dp_inH2O: document.getElementById('Dpstar').textContent,
        inlet_velocity_ft_s: document.getElementById('Vin').textContent,
        channel_velocity_avg_ft_s: document.getElementById('Vch').textContent,
        reynolds_plenum: document.getElementById('Re_pl').textContent,
        reynolds_channel: document.getElementById('Re_ch').textContent,
        fan_air_power_HP: document.getElementById('HP').textContent,
        fan_scale_factor: ScaleFactor
      },
      branchVelocities: lastBranchVels ? {
        channels_m_s: lastBranchVels.Vch_m,
        top_gap_m_s: lastBranchVels.Vtop_m,
        side_gaps_m_s: lastBranchVels.Vside_m,
        channels_ft_s: (lastBranchVels.Vch_m * 3.28084).toFixed(2),
        top_gap_ft_s: (lastBranchVels.Vtop_m * 3.28084).toFixed(2),
        side_gaps_ft_s: (lastBranchVels.Vside_m * 3.28084).toFixed(2)
      } : null
    };
    zip.file(`config_${timestamp}.json`, JSON.stringify(config, null, 2));
    
    // 9. README
    const readme = `Plenum / Fan Matching Analysis - V2 with Target Velocity Export
Generated: ${new Date().toLocaleString()}

Contents:
- results_${timestamp}.csv: Operating point and key results
- fan_curve_base_${timestamp}.csv: Base (unscaled) fan curve data points
- fan_curve_scaled_${timestamp}.csv: Scaled fan curve (scale factor: ${ScaleFactor})
- velocity_profile_${timestamp}.csv: Channel velocity distribution along fin length
- fan_system_curves_${timestamp}.png: Scaled fan and system curves with operating point
- velocity_distribution_${timestamp}.png: Velocity profile chart
- 3d_geometry_view_${timestamp}.png: 3D visualization of plenum and heat sink
- config_${timestamp}.json: Complete configuration and results

System Configuration:
Air Properties:
- Density œÅ: ${document.getElementById('rho').value} kg/m¬≥
- Viscosity Œº: ${document.getElementById('mu').value} Pa¬∑s

Plenum Geometry (inches):
- Width W: ${document.getElementById('plenumW').value} in
- Height H: ${document.getElementById('plenumH').value} in
- Length L: ${document.getElementById('plenumL').value} in

Inlet Geometry (inches):
- Width w: ${document.getElementById('inletW').value} in
- Height h: ${document.getElementById('inletH').value} in
- Position x: ${document.getElementById('inletX').value} in from start

Heat Sink (Finned) (inches):
- Fin height b: ${document.getElementById('b').value} in
- Fin thickness t: ${document.getElementById('tfin').value} in
- Fin spacing s: ${document.getElementById('sfin').value} in
- Fin length Lf: ${document.getElementById('Lfin').value} in
- HS lead edge x: ${document.getElementById('xHS').value} in
- HS width: ${document.getElementById('WHS').value} in

Target Velocity:
- Target channel velocity: ${document.getElementById('Vch_target').value} ft/s

Operating Point Results:
- Flow rate Q*: ${document.getElementById('Qstar').textContent} cfm
- Back pressure Œîp*: ${document.getElementById('Dpstar').textContent} inH‚ÇÇO
- Inlet velocity: ${document.getElementById('Vin').textContent} ft/s
- Channel velocity (avg): ${document.getElementById('Vch').textContent} ft/s
- Reynolds (plenum): ${document.getElementById('Re_pl').textContent}
- Reynolds (channel): ${document.getElementById('Re_ch').textContent}
- Fan air power: ${document.getElementById('HP').textContent} HP
- Fan scale factor: ${ScaleFactor}

${lastBranchVels ? `
Branch Flow Distribution:
- Channels: ${(lastBranchVels.Vch_m * 3.28084).toFixed(2)} ft/s
- Top gap: ${(lastBranchVels.Vtop_m * 3.28084).toFixed(2)} ft/s
- Side gaps: ${(lastBranchVels.Vside_m * 3.28084).toFixed(2)} ft/s
` : ''}

Methodology:
- IP units (inches, cfm, inH‚ÇÇO, ft/s) used for display
- SI units used internally for calculations
- 3-branch flow model: channels (through fins), top gap, side gaps
- V2 plenum-over-HS manifold model for velocity distribution
- Fan curve iteratively scaled to meet target channel velocity
- Operating point found at scaled fan/system curve intersection
`;
    zip.file('README.txt', readme);
    
    // Generate and download ZIP
    try {
      const content = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(content);
      const a = document.createElement('a');
      a.href = url;
      a.download = `plenum_fan_target_vel_export_${timestamp}.zip`;
      a.click();
      URL.revokeObjectURL(url);
    } catch (err) {
      alert('Error creating ZIP file: ' + err.message);
    }
  });
</script>

</script>
</body>
</html>





















