<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="icon" href="data:,">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bonded Rubber — Mold → Cool (v1.2.5 • FEM + Two-k Curved Cones)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{ --panel-w:280px; --gap:16px; --pad:14px; --bg:#f6f7fb; --ink:#111; --muted:#666; --border:#ddd; --accent:#0b73c8; }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  body{margin:18px;background:var(--bg);color:var(--ink)}
  h2{margin:0 0 8px}

  /* --- ROW stays horizontal, scrolls if needed --- */
  .row{
    display:flex;
    gap:var(--gap);
    align-items:flex-start;
    flex-wrap:nowrap;        /* keep panels side-by-side */
    overflow-x:auto;         /* allow sideways scroll on small viewports */
    scroll-behavior:smooth;
  }
  /* remove any previous wrap behavior */
  /* (If you had a media query that set flex-wrap:wrap, this overrides it) */

  /* Fix the left UI panel width; keep content from shrinking */
  #inputs{
    flex:0 0 var(--panel-w);
    min-width:var(--panel-w);
  }

  /* Right panel can stay auto; its explicit width comes from inline style below */
  .panel-right{
    flex:0 0 auto;
    min-width:0; /* allow inner canvases to define the width */
  }

  .panel{width:var(--panel-w);background:#fff;border:1px solid var(--border);border-radius:12px;padding:var(--pad);overflow:hidden}
  .panel[style*="flex:1"]{width:auto}
  .field{display:grid;grid-template-columns: 1fr 190px;align-items:center;gap:12px;margin:6px 0}
  .field label{font-size:13px;color:#222}
  .field input, .field select, .field button{height:36px;border:1px solid var(--border);border-radius:10px;padding:0 10px;font-size:14px;background:#fff}
  .field input[type="number"]{text-align:right}
  .group{border-top:1px dashed #e2e2e2;margin:10px 0;padding-top:10px}
  .btn{background:var(--accent);color:#fff;border:none;cursor:pointer;font-weight:600}
  .btn:active{transform:translateY(1px)}
  .note{font-size:12px;color:var(--muted)}
  canvas{background:#fff;border:1px solid var(--border);border-radius:12px; width:auto; height:auto; display:block}
  .hide{display:none}
  .subsec{margin-left:0}
  .legend{display:flex;align-items:center;gap:8px;font-size:12px;color:#333;margin-top:6px;flex-wrap:wrap;max-width:565px}
  .sw{width:14px;height:10px;border-radius:3px;border:1px solid #999}
  .row2{display:grid;grid-template-columns:1fr;grid-auto-rows:auto;row-gap:4px;align-items:start}
  .subtle{color:#666;font-size:12px;justify-self:end;text-align:right;white-space:normal;overflow-wrap:anywhere;word-break:break-word;hyphens:auto;max-width:100%;display:block}
  .testbar{margin-top:10px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  pre#testsOut{background:#fafafa;border:1px solid #eee;border-radius:8px;padding:10px;max-height:260px;overflow:auto;font-size:12px}
  .rangeRow{display:grid;grid-template-columns:minmax(0,1fr) 80px;gap:8px;align-items:center;width:100%;}
  .rangeRow input[type="range"]{width:100%;min-width:0}
  .rangeRow input[type="number"]{width:80px}
  .actionBar{position:sticky;top:0;background:#fff;padding-bottom:10px;margin:-14px -14px 10px -14px;padding:10px 14px 10px 14px;border-bottom:1px solid #eee;display:flex;gap:8px;align-items:center;z-index:2}
  .actionBar .btn{height:34px;padding:0 14px}
  .actionBar small{color:#666}
  .canvasWrap{position:relative}
  .solveBadge{position:absolute;top:6px;left:6px;padding:4px 8px;border-radius:10px;font-size:12px;border:1px solid #ccc;background:#f5f5f5;color:#333}
  .solveBadge.solving{background:#fff3cd;border-color:#ffe08a;color:#7a5d00}
  .solveBadge.done{background:#e6ffed;border-color:#b7efc5;color:#0a6b2b}
  .solveBadge.error{background:#fdecea;border-color:#facdcd;color:#b42318}
  .hdr{font-weight:600;margin:8px 0 6px 2px}
</style>
</head>
<body>
  <h2>Bonded Rubber Disk — Molding Shrinkage and Shear Strains</h2>
  <div class="row">
    <div class="panel" id="inputs">
      <div class="actionBar">
        <button class="btn" id="moldBtn">Shrinkage</button>
        <small>Build FE model and solve cooling shrinkage</small>
      </div>

      <div class="field">
        <label id="unitsLabel" for="units">Units</label>
        <select id="units" aria-labelledby="unitsLabel">
          <option value="us" selected>lbs & inches & °F</option>
          <option value="si">N & mm & °C</option>
        </select>
      </div>

      <div class="group"></div>

      <div class="field"><label for="G">Rubber Shear Modulus, G</label><input id="G" type="number" step="0.01" value="120"></div>
      <div class="field"><label for="alpha">Thermal CTE (per °F or per °C)</label><input id="alpha" type="number" step="1e-6" value="0.000110"></div>

      <div class="group"></div>

      <div class="field g-cyl"><label for="OD">Mold Cavity OD</label><input id="OD" type="number" step="0.001" value="4"></div>
      <div class="field g-cyl"><label for="ID">Mold Cavity ID</label><input id="ID" type="number" step="0.001" value="0.5"></div>
      <div class="field"><label for="H">Mold Cavity Height</label><input id="H" type="number" step="0.001" value="0.5"></div>

      <div class="field"><label id="geomSelLabel" for="geomSel">Geometry</label>
        <select id="geomSel" aria-labelledby="geomSelLabel">
          <option value="cyl" selected>Cylinder</option>
          <option value="cone">Straight cone</option>
          <option value="curved">Curved cone (two-k: k_out & k_in)</option>
        </select>
      </div>

      <div id="coneFields" class="subsec hide">
        <div class="field"><label for="OD0">OD @ z=0</label><input id="OD0" type="number" step="0.001" value="4"></div>
        <div class="field"><label for="OD1">OD @ z=H</label><input id="OD1" type="number" step="0.001" value="4"></div>
        <div class="field"><label for="ID0">ID @ z=0</label><input id="ID0" type="number" step="0.001" value="0.5"></div>
        <div class="field"><label for="ID1">ID @ z=H</label><input id="ID1" type="number" step="0.001" value="0.5"></div>
      </div>

      <div id="curvFields" class="subsec hide">
        <div class="field"><label for="kOutVal">Outer curvature k_out (− concave … + convex)</label>
          <div class="rangeRow">
            <input id="kOutSlider" type="range" min="-3" max="3" step="0.05" value="0">
            <input id="kOutVal" type="number" step="0.05" value="0" min="-3" max="3">
          </div>
        </div>
        <div class="field"><label for="kInVal">Inner curvature k_in (− concave … + convex)</label>
          <div class="rangeRow">
            <input id="kInSlider" type="range" min="-3" max="3" step="0.05" value="0">
            <input id="kInVal" type="number" step="0.05" value="0" min="-3" max="3">
          </div>
        </div>
      </div>

      <div class="field"><label id="endsLabel" for="ends">End condition</label>
        <select id="ends" aria-labelledby="endsLabel">
          <option value="bonded" selected>Bonded ends (z=0 & z=H fixed)</option>
          <option value="free">Free ends</option>
        </select>
      </div>

      <div class="group"></div>
      <div class="field">
        <label for="Tm">Molding Temp</label><input id="Tm" type="number" step="0.1" value="305">
      </div>
      <div class="field">
        <label for="Tr">Room Temp</label><input id="Tr" type="number" step="0.1" value="70">
      </div>

      <div class="group"></div>
      <div class="field">
        <label for="defScaleSlider">Deflection Scale (visual only)</label>
        <div class="rangeRow">
          <input id="defScaleSlider" type="range" min="0" max="5" step="0.1" value="1">
          <input id="defScale" type="number" step="0.1" value="1">
        </div>
      </div>

      <div class="group"></div>

      <!-- EXPORT BUTTONS -->
      <div class="testbar">
        <button class="btn" id="btnJson">Export JSON</button>
        <button class="btn" id="btnImportJson">Import JSON</button>
        <button class="btn" id="btnCsv">Export CSV</button>
        <input id="jsonFileInput" type="file" accept=".json,application/json" style="display:none;">
        <small class="subtle">Exports original &amp; cooled outlines</small>
      </div>



    </div>

    <!-- Right results panel: width remains explicit so legends/plots fit -->
    <div class="panel panel-right" style="flex:0 0 auto;min-width:0;width:calc(565px + 2*var(--pad));max-width:calc(565px + 2*var(--pad))">
      <div class="hdr">Original geometry (live preview, full −r…+r)</div>
      <div class="canvasWrap" style="margin-bottom:10px;width:565px">
        <canvas id="cvPrev" width="565" height="240" aria-label="Original geometry preview"></canvas>
      </div>

      <div class="hdr">Solved overlay: BEFORE (blue) + AFTER (red) in r–z</div>
      <div class="canvasWrap" style="width:565px">
        <div id="solveBadge" class="solveBadge" aria-live="polite">Ready</div>
        <canvas id="cv" width="565" height="380" aria-label="Solved after-shape with shear"></canvas>
      </div>
      <div class="legend">
        <span class="sw" style="background:#2d6cdf"></span> Before outline
        <span class="sw" style="background:#d43f3a"></span> After outline (FEM, deflection-scaled)
        <span class="sw" style="background:linear-gradient(90deg,#0000ff,#00ffff,#00ff00,#ffff00,#ff7f00,#ff0000)"></span> Shear γ<sub>rz</sub> (low→high)
      </div>

      <div class="hdr">Resultant displacement |u| contours (r–z view)</div>
      <div class="canvasWrap" style="width:565px">
        <canvas id="cvDefl" width="565" height="380" aria-label="Deflection contours"></canvas>
      </div>
      <div class="legend">
        <span class="sw" style="background:linear-gradient(90deg,#0000ff,#ff0000)"></span> |u| magnitude (blue → red)
      </div>
    </div>
  </div>

<script>
(function(){
  'use strict';

  const el = id => document.getElementById(id);
  const unitsEl = el('units');
  const GEl = el('G');
  const aEl = el('alpha');
  const geomEl = el('geomSel');
  const coneBox = el('coneFields');
  const curvBox = el('curvFields');
  const OD0El = el('OD0');
  const OD1El = el('OD1');
  const ID0El = el('ID0');
  const ID1El = el('ID1');
  const kOutSlider = el('kOutSlider');
  const kOutVal = el('kOutVal');
  const kInSlider = el('kInSlider');
  const kInVal = el('kInVal');
  const ODEl = el('OD');
  const IDEl = el('ID');
  const HEl = el('H');
  const endsEl = el('ends');
  const TmEl = el('Tm');
  const TrEl = el('Tr');
  const defScaleEl = el('defScale');
  const defScaleSlider = el('defScaleSlider');
  let defScaleLbl = el('defScaleLbl');
  const cvPrev = el('cvPrev');
  const cv = el('cv');
  const cvDefl = el('cvDefl');
  let statusEl = el('status');


  const badge = el('solveBadge');
  const btnJson = el('btnJson');
  const btnImportJson = el('btnImportJson');
  const btnCsv  = el('btnCsv');
  const jsonFileInput = el('jsonFileInput');




  function fitCanvases(){ /* fixed size */ }

  function ensureStatusElements(){ /* status removed */ }
  function setStatus(txt){ /* status removed */ }
  function setStatusHTML(html){ /* status removed */ }
  function safeSetDefScaleLabel(text){ /* status removed */ }

  let ctxPrev = null, ctx = null, ctxDefl = null;
  try{ ctxPrev = cvPrev.getContext('2d'); ctx = cv.getContext('2d'); }catch(err){ console.error('Canvas context error:', err); }
  try{ ctxDefl = cvDefl.getContext('2d'); }catch(err){ console.error('Deflection canvas context error:', err); }

  let lastFE = null;

  function scrubEscapedLabelArtifacts(){
    try{
      document.querySelectorAll('.field').forEach(f=>{
        [...f.childNodes].forEach(n=>{
          if(n && n.nodeType===Node.TEXT_NODE){
            const t=(n.textContent||'').trim();
            if(t.includes('</label>') || t.includes('<\/label>') || t.includes('\/label>')){ n.remove(); }
          }
        });
      });
    }catch(err){ /* no-op */ }
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function valueRange(arr){
    if(!arr || !arr.length) return {min:NaN, max:NaN};
    let mn=Infinity, mx=-Infinity, any=false;
    for(let v of arr){ if(Number.isFinite(v)){ any=true; if(v<mn) mn=v; if(v>mx) mx=v; } }
    return any ? {min:mn, max:mx} : {min:NaN, max:NaN};
  }
  function normalize(values){
    const r = valueRange(values||[]);
    if(!Number.isFinite(r.min) || !Number.isFinite(r.max) || (r.max-r.min) <= 1e-30){
      return (values||[]).map(_=> 0.5);
    }
    const span = r.max - r.min; return values.map(v => (v - r.min)/span);
  }
  function fmt(x){ if(!Number.isFinite(x)) return '—'; const ax=Math.abs(x); if(ax>=1e-2 && ax<1e3) return x.toFixed(4).replace(/0+$/,'').replace(/\.$/,''); return x.toExponential(2).replace('+',''); }
  function ramp(t){ t = clamp(t,0,1); const segs = 5; const s = t*segs; const i = Math.floor(s); const f = s - i; function col(r,g,b){ return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`; } switch(i){ case 0: return col(0,255*f,255); case 1: return col(0,255,255*(1-f)); case 2: return col(255*f,255,0); case 3: return col(255,255*(1-f),0); default:return col(255,0,0);} }
  function rampBlueRed(t){ t = clamp(t,0,1); const r=Math.round(255*t), g=0, b=Math.round(255*(1-t)); return `rgb(${r},${g},${b})`; }

  window.addEventListener('error', (e) => { const msg = e && e.message ? e.message : 'Unknown script error'; setStatus('Global JS error: ' + msg); setSolveState('error', msg); });

  function updateDefScaleLabel(){ const s = Number(defScaleEl && defScaleEl.value)||1; safeSetDefScaleLabel(s.toFixed(2).replace(/\.00$/, '') + '×'); }
  function syncRangePair(rangeEl, numEl, onChange){ const sync = (src, dst) => () => { if(dst) dst.value = src.value; onChange && onChange(); }; if(rangeEl&&numEl){ rangeEl.addEventListener('input', sync(rangeEl, numEl)); numEl.addEventListener('input', sync(numEl, rangeEl)); } }

  if(unitsEl){
    unitsEl.addEventListener('change', () => {
      const u = unitsEl.value; const a = Number(aEl.value); if(!Number.isFinite(a)) return;
      if(u==='si') aEl.value = (a * 9/5).toFixed(9); else aEl.value = (a * 5/9).toFixed(9);
      drawPreview();
    });
  }

  const moldBtnEl = el('moldBtn');
  if(moldBtnEl) moldBtnEl.addEventListener('click', computeAndDraw);

  function updateGeomUI(){
    const g=geomEl.value;
    document.querySelectorAll('.g-cyl').forEach(n=> n.style.display=(g==='cyl')?'grid':'none');
    if(coneBox) coneBox.style.display=(g==='cone'||g==='curved')?'block':'none';
    if(curvBox) curvBox.style.display=(g==='curved')?'block':'none';
  }
  geomEl.addEventListener('change', ()=>{ updateGeomUI(); scrubEscapedLabelArtifacts(); drawPreview(); });
  updateGeomUI();

  syncRangePair(defScaleSlider, defScaleEl, () => { updateDefScaleLabel(); redrawResults(); });
  syncRangePair(kOutSlider, kOutVal, () => drawPreview());
  syncRangePair(kInSlider,  kInVal,  () => drawPreview());
  ;[ODEl, IDEl, HEl, OD0El, OD1El, ID0El, ID1El].forEach(inp => { if(inp) inp.addEventListener('input', drawPreview); });

  function setSolveState(state, note){
    if(!badge) return;
    badge.classList.remove('solving','done','error');
    if(state==='solving'){ badge.textContent = 'Solving…'; badge.classList.add('solving'); }
    else if(state==='done'){ badge.textContent = 'Solved'; badge.classList.add('done'); }
    else if(state==='error'){ badge.textContent = 'Error'; badge.classList.add('error'); if(note) badge.title = note; }
    else { badge.textContent = 'Ready'; }
  }
  window._test_setSolveState = setSolveState;

  function readGeom(){
    const H = Number(HEl.value)||0.5; const geom = geomEl.value;
    let OD=Number(ODEl.value)||4, ID=Number(IDEl.value)||0.5;
    let OD0=OD, OD1=OD, ID0=ID, ID1=ID;
    let roAt, riAt;
    if(geom==='cyl'){
      roAt = z => OD/2; riAt = z => ID/2;
    } else if(geom==='cone'){
      OD0 = Number(OD0El.value)||OD; OD1 = Number(OD1El.value)||OD; ID0 = Number(ID0El.value)||ID; ID1 = Number(ID1El.value)||ID;
      roAt = z => { const t=z/Math.max(1e-12,H); return (1-t)*(OD0/2) + t*(OD1/2); };
      riAt = z => { const t=z/Math.max(1e-12,H); return (1-t)*(ID0/2) + t*(ID1/2); };
    } else {
      OD0 = Number(OD0El.value)||OD; OD1 = Number(OD1El.value)||OD; ID0 = Number(ID0El.value)||ID; ID1 = Number(ID1El.value)||ID;
      let kOut = Number(kOutVal ? kOutVal.value : 0); if(!Number.isFinite(kOut)) kOut=0; kOut=Math.max(-3, Math.min(3, kOut));
      let kIn  = Number(kInVal  ? kInVal.value  : 0); if(!Number.isFinite(kIn))  kIn=0;  kIn =Math.max(-3, Math.min(3, kIn ));
      const ro0=OD0/2, ro1=OD1/2, ri0=ID0/2, ri1=ID1/2;
      const rlin_o = t => (1-t)*ro0 + t*ro1; const rlin_i = t => (1-t)*ri0 + t*ri1;
      const bump = t => { const b=t*t*(1-t)*(1-t); return b/0.0625; };
      const gamma = 0.15;
      roAt = z => { const t=z/Math.max(1e-12,H); return rlin_o(t) * (1 + kOut*gamma*bump(t)); };
      riAt = z => { const t=z/Math.max(1e-12,H); return rlin_i(t) * (1 + kIn*gamma*bump(t)); };
    }
    return {H, geom, roAt, riAt, OD, ID, OD0, OD1, ID0, ID1};
  }

  function drawPreview(){
    if(!ctxPrev) return;
    const g = readGeom();
    const pad=28; ctxPrev.clearRect(0,0,cvPrev.width,cvPrev.height); ctxPrev.save(); ctxPrev.translate(pad,pad);
    const viewW=cvPrev.width-2*pad, viewH=cvPrev.height-2*pad; const H=g.H; const Rmax = Math.max(sampleMax(g.roAt,H), g.OD/2);
    const scale = Math.min((viewW)/(2*Rmax*1.25), (viewH)/(H*1.25));
    const originX = Math.round(viewW/2), originY = 10;
    const X = r => originX + r*scale, Y = z => originY + z*scale;
    ctxPrev.strokeStyle='#bbb'; ctxPrev.lineWidth=1; ctxPrev.beginPath(); ctxPrev.moveTo(originX, originY); ctxPrev.lineTo(originX, originY + H*scale); ctxPrev.stroke();
    ctxPrev.fillStyle='#666'; ctxPrev.fillText('z', originX - 12, originY + H*scale + 12);
    ctxPrev.fillText('−r', originX - (Rmax*scale) - 16, originY - 4); ctxPrev.fillText('+r', originX + (Rmax*scale) + 8, originY - 4);
    drawOutlineSymGenericPrev(ctxPrev, {H}, '#2d6cdf', X, Y, g.roAt, g.riAt);
    ctxPrev.restore();
  }

  function sampleMax(fn, H){ let mx=0; const N=240, dz=H/N; for(let i=0;i<=N;i++){ const r=fn(i*dz); if(r>mx) mx=r; } return mx; }

  function drawOutlineSymGenericPrev(ctxX, shape, color, X, Y, roFunc, riFunc){
    const H = shape.H; ctxX.save(); ctxX.strokeStyle=color; ctxX.lineWidth=2; ctxX.beginPath();
    for(let i=0;i<=240;i++){ const z = H*(i/240); const r = roFunc(z); const x=X(r), y=Y(z); if(i===0) ctxX.moveTo(x,y); else ctxX.lineTo(x,y); }
    for(let i=240;i>=0;i--){ const z = H*(i/240); const r = roFunc(z); const x=X(-r), y=Y(z); ctxX.lineTo(x,y); }
    ctxX.closePath(); ctxX.stroke();
    if(riFunc){ ctxX.beginPath(); for(let i=0;i<=240;i++){ const z = H*(i/240); const r = riFunc(z); const x=X(r), y=Y(z); if(i===0) ctxX.moveTo(x,y); else ctxX.lineTo(x,y); } for(let i=240;i>=0;i--){ const z = H*(i/240); const r = riFunc(z); const x=X(-r), y=Y(z); ctxX.lineTo(x,y); } ctxX.stroke(); }
    ctxX.restore();
  }

  function computeAndDraw(){
    try{
      const inp = readInputs();
      setSolveState('solving');
      setStatus('Solving… (clicks/edits won\'t re-solve)');
      setTimeout(() => {
        try{
          const approx = analyticShrink(inp);
          const fe = solveFENeoHookean(inp);
          const res = Object.assign({}, fe, { dT:approx.dT, s_r:approx.s_r, s_z:approx.s_z });
          lastFE = res;
          drawResults(res);
          const rng = valueRange(res.shearValsRZ||[]);
          setStatusHTML(`ΔT=${fmt(approx.dT)}°, s_r≈${fmt(approx.s_r)}, s_z≈${fmt(approx.s_z)}<br>Strain range: ${isFinite(rng.min)?fmt(rng.min):'—'} … ${isFinite(rng.max)?fmt(rng.max):'—'} • Defl scale: <span id="defScaleLbl">${(+inp.defScale).toFixed(2).replace(/\.00$/, '')}×</span>`);
          setSolveState('done');
        }catch(err){ console.error(err); setStatus('Error: ' + (err && err.message ? err.message : err)); setSolveState('error', err && err.message); }
      }, 0);
    }catch(e){ console.error(e); setStatus('Error: ' + (e && e.message ? e.message : e)); setSolveState('error', e && e.message); }
  }

  function redrawResults(){ if(lastFE){ const sNow = Number(defScaleEl.value)||1; if(lastFE.params) lastFE.params.defScale = sNow; drawResults(lastFE); } }

  function readInputs(){
    const u = unitsEl.value; const G = Number(GEl.value); const alpha = Number(aEl.value);
    const H = Number(HEl.value); const ends = String(endsEl.value); const Tm = Number(TmEl.value); const Tr = Number(TrEl.value);
    const defScale = Math.max(0, Number(defScaleEl.value)||1);
    if(!(H>0) || !(Tm>Tr)) throw new Error('Check Height and that molding temp > room temp.');
    if(!(alpha>=0)) throw new Error('CTE must be ≥ 0.');

    const geom = geomEl.value;
    let OD=Number(ODEl.value), ID=Number(IDEl.value);
    let roAt, riAt, OD0=OD, OD1=OD, ID0=ID, ID1=ID;

    if(geom==='cyl'){
      if(ID<0 || ID>=OD) throw new Error('ID must be ≥ 0 and < OD.');
      roAt = z => OD/2; riAt = z => ID/2;
    } else if(geom==='cone') {
      OD0 = Number(OD0El.value); OD1 = Number(OD1El.value); ID0 = Number(ID0El.value); ID1 = Number(ID1El.value);
      if(!(OD0>0) || !(OD1>0)) throw new Error('OD@ends must be > 0');
      if(ID0<0 || ID1<0) throw new Error('ID@ends must be ≥ 0');
      roAt = z => { const t=z/H; return (1-t)*(OD0/2) + t*(OD1/2); };
      riAt = z => { const t=z/H; return (1-t)*(ID0/2) + t*(ID1/2); };
      for(let k=0;k<=20;k++){ const zz=k*H/20; if(roAt(zz) - riAt(zz) <= 0) throw new Error('Cone creates negative wall at z='+zz.toFixed(3)); }
      const zMid=0.5*H; OD = 2*roAt(zMid); ID = 2*riAt(zMid);
    } else if(geom==='curved') {
      OD0 = Number(OD0El.value); OD1 = Number(OD1El.value); ID0 = Number(ID0El.value); ID1 = Number(ID1El.value);
      if(!(OD0>0) || !(OD1>0)) throw new Error('OD@ends must be > 0');
      if(ID0<0 || ID1<0) throw new Error('ID@ends must be ≥ 0');
      let kOut = Number(kOutVal ? kOutVal.value : 0); if(!Number.isFinite(kOut)) kOut=0; kOut=Math.max(-3, Math.min(3, kOut));
      let kIn  = Number(kInVal  ? kInVal.value  : 0); if(!Number.isFinite(kIn))  kIn=0;  kIn =Math.max(-3, Math.min(3, kIn ));
      const ro0=OD0/2, ro1=OD1/2, ri0=ID0/2, ri1=ID1/2;
      const rlin_o = t => (1-t)*ro0 + t*ro1; const rlin_i = t => (1-t)*ri0 + t*ri1;
      const bump = t => { const b = t*t*(1-t)*(1-t); return b/0.0625; };
      const gamma = 0.15;
      roAt = z => { const t=z/H; return rlin_o(t) * (1 + kOut*gamma*bump(t)); };
      riAt = z => { const t=z/H; return rlin_i(t) * (1 + kIn*gamma*bump(t)); };
      for(let k=0;k<=40;k++){ const zz=k*H/40; if(roAt(zz) - riAt(zz) <= 1e-9) throw new Error('Curved cone creates non-positive wall at z='+zz.toFixed(3)); }
      const zMid=0.5*H; OD = 2*roAt(zMid); ID = 2*riAt(zMid);
    }

    return {u,G,alpha,OD,ID,H,ends,Tm,Tr,defScale,geom,roAt,riAt,OD0,OD1,ID0,ID1};
  }

  function analyticShrink(p){
    const dT = p.Tm - p.Tr; const s_r = p.alpha * dT; const s_z = (p.ends==='free') ? (p.alpha * dT) : 0;
    const before = {OD:p.OD, ID:p.ID, H:p.H};
    const after  = {OD:p.OD*(1-s_r), ID:p.ID*(1-s_r), H:p.H*(1-s_z)};
    const mesh = buildRZMesh(after.ID/2, after.OD/2, after.H, 6, 6);
    const shearValsRZ = mesh.cells.map(_=> Math.abs(s_r-s_z));
    return {dT, s_r, s_z, before, after, meshRZ:mesh, shearValsRZ, params:p};
  }

  function buildRZMesh(ri, ro, H, nr=60, nz=60){
    const dr = (ro - ri)/Math.max(1, nr); const dz = (H)/Math.max(1, nz);
    const cells = []; for(let i=0;i<nr;i++){ for(let j=0;j<nz;j++){ const r0 = ri + i*dr, r1 = r0 + dr; const z0 = 0 + j*dz, z1 = z0 + dz; cells.push({r0,r1,z0,z1}); }}
    return {ri,ro,H,nr,nz,cells};
  }

  function drawResults(res){
    if(!ctx){ return; }
    updateDefScaleLabel();
    ctx.clearRect(0,0,cv.width,cv.height);
    ctx.save(); const pad = 24; ctx.translate(pad,pad);
    const viewW = cv.width - 2*pad, viewH = cv.height - 2*pad;
    if(!res){ ctx.fillStyle='#777'; ctx.fillText('Click MOLD IT to compute & draw.', 40, 24); ctx.restore(); return; }

    const before = res.before; const p = res.params||{}; const s = p.defScale||1;
    const roBefore = (z)=> (p.roAt? p.roAt(z) : (before.OD||0)/2);
    const riBefore = (z)=> (p.riAt? p.riAt(z) : (before.ID||0)/2);

    const zRows = res.boundary.z, zCur = res.boundary.zCur; const rIn = res.boundary.rInner, rOut = res.boundary.rOuter;
    const H0 = before.H; const Hcur = (zCur[zCur.length-1]-zCur[0]); const Hviz = H0 + s*(Hcur - H0);
    const ro0 = before.OD/2, ri0 = before.ID/2;
    const roViz = (z) => { const rc = interp1(zRows, rOut, (z/Hviz)*H0); return ro0 + s*(rc - ro0); };
    const riViz = (z) => { const rc = interp1(zRows, rIn,  (z/Hviz)*H0); return ri0 + s*(rc - ri0); };

    const Rmax = Math.max(ro0, sampleMax(roViz, Hviz)); const Hmax = Math.max(H0, Hviz);
    const cbW = 20, cbGap = 40, cbTotal = cbW + cbGap + 40;
    const scale = Math.min( (viewW - cbTotal)/(2*Rmax*1.1), (viewH-40)/(Hmax*1.1) );
    const originX = 60 + ( (viewW - cbTotal)/2 ); const originY = 8;
    const X = r => originX + r*scale, Y = z => originY + z*scale;

    ctx.strokeStyle = '#bbb'; ctx.fillStyle = '#666'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(originX, originY + Hmax*scale); ctx.stroke();
    ctx.fillText('z', originX - 12, originY + Hmax*scale + 12);
    ctx.fillText('−r', originX - (Rmax*scale) - 16, originY - 4); ctx.fillText('+r', originX + (Rmax*scale) + 8, originY - 4);

    if(res.meshRZ && res.shearValsRZ){
      const valsN = normalize(res.shearValsRZ); const mesh = res.meshRZ; const HA = mesh.H; const riA = mesh.ri, roA = mesh.ro;
      for(let k=0;k<mesh.cells.length;k++){
        const c = mesh.cells[k]; const z0 = c.z0, z1 = c.z1; const zMidV = mapZLinear(0.5*(z0+z1), 0, HA, 0, Hviz);
        const ri = riViz(zMidV), ro = roViz(zMidV);
        const x0p = X( mapRLinear(c.r0, riA, roA, ri, ro) ); const x1p = X( mapRLinear(c.r1, riA, roA, ri, ro) );
        const y0 = Y( mapZLinear(z0, 0, HA, 0, Hviz) ); const y1 = Y( mapZLinear(z1, 0, HA, 0, Hviz) );
        ctx.fillStyle = ramp(valsN[k]); ctx.fillRect(x0p, y0, Math.max(0, x1p-x0p), Math.max(0, y1-y0));
        const x0m = X( -mapRLinear(c.r1, riA, roA, ri, ro) ); const x1m = X( -mapRLinear(c.r0, riA, roA, ri, ro) );
        ctx.fillRect(x0m, y0, Math.max(0, x1m-x0m), Math.max(0, y1-y0));
      }
    }

    drawOutlineSymGenericRes(ctx, {H:H0}, '#2d6cdf', X, Y, roBefore, riBefore);
    drawOutlineSymGenericRes(ctx, {H:Hviz}, '#d43f3a', X, Y, roViz, riViz);

    if(res.shearValsRZ){ drawColorbar(ctx, originX + Rmax*scale + 12, originY, 20, Math.max(140, Hmax*scale*0.6), res.shearValsRZ, 'shear γ_rz'); }

    ctx.restore();

    // Deflection |u| contours
    if(ctxDefl && res.meshRZ && res.deflValsRZ){
      ctxDefl.clearRect(0,0,cvDefl.width,cvDefl.height);
      ctxDefl.save(); const pad2=24; ctxDefl.translate(pad2,pad2);
      const vW = cvDefl.width-2*pad2, vH = cvDefl.height-2*pad2;
      const Hviz2 = Hviz, Rmax2 = Rmax;
      const cbW2 = 20, cbGap2 = 40, cbTotal2 = cbW2 + cbGap2 + 40;
      const scale2 = Math.min( (vW - cbTotal2)/(2*Rmax2*1.1), (vH-40)/(Hviz2*1.1) );
      const originX2 = 60 + ( (vW - cbTotal2)/2 ), originY2 = 8;
      const X2 = r => originX2 + r*scale2, Y2 = z => originY2 + z*scale2;

      ctxDefl.strokeStyle='#bbb'; ctxDefl.fillStyle='#666'; ctxDefl.lineWidth=1;
      ctxDefl.beginPath(); ctxDefl.moveTo(originX2, originY2); ctxDefl.lineTo(originX2, originY2 + Hviz2*scale2); ctxDefl.stroke();
      ctxDefl.fillText('z', originX2 - 12, originY2 + Hviz2*scale2 + 12);
      ctxDefl.fillText('−r', originX2 - (Rmax2*scale2) - 16, originY2 - 4); ctxDefl.fillText('+r', originX2 + (Rmax2*scale2) + 8, originY2 - 4);

      const mesh = res.meshRZ; const HA = mesh.H; const riA = mesh.ri, roA = mesh.ro;
      const valsN = normalize(res.deflValsRZ);
      for(let k=0;k<mesh.cells.length;k++){
        const c = mesh.cells[k]; const z0 = c.z0, z1 = c.z1; const zMidV = mapZLinear(0.5*(z0+z1), 0, HA, 0, Hviz2);
        const ri = riViz(zMidV), ro = roViz(zMidV);
        const x0p = X2( mapRLinear(c.r0, riA, roA, ri, ro) ); const x1p = X2( mapRLinear(c.r1, riA, roA, ri, ro) );
        const y0 = Y2( mapZLinear(z0, 0, HA, 0, Hviz2) ); const y1 = Y2( mapZLinear(z1, 0, HA, 0, Hviz2) );
        ctxDefl.fillStyle = rampBlueRed(valsN[k]); ctxDefl.fillRect(x0p, y0, Math.max(0, x1p-x0p), Math.max(0, y1-y0));
        const x0m = X2( -mapRLinear(c.r1, riA, roA, ri, ro) ); const x1m = X2( -mapRLinear(c.r0, riA, roA, ri, ro) );
        ctxDefl.fillRect(x0m, y0, Math.max(0, x1m-x0m), Math.max(0, y1-y0));
      }
      drawColorbar(ctxDefl, originX2 + Rmax2*scale2 + 12, originY2, 20, Math.max(140, Hviz2*scale2*0.6), res.deflValsRZ, '|u|');
      ctxDefl.restore();
    }
  }

  function mapRLinear(r, riA, roA, riV, roV){ const t = (r - riA) / Math.max(1e-12, (roA - riA)); return riV + t * (roV - riV); }
  function mapZLinear(z, z0A, z1A, z0V, z1V){ const t = (z - z0A) / Math.max(1e-12, (z1A - z0A)); return z0V + t * (z1V - z0V); }

  function drawOutlineSymGenericRes(ctxX, shape, color, X, Y, roFunc, riFunc){
    const H = shape.H; ctxX.save(); ctxX.strokeStyle = color; ctxX.lineWidth = 2; ctxX.beginPath();
    for(let i=0;i<=240;i++){ const z = H * (i/240); const r = roFunc ? roFunc(z) : 0; const x = X(r), y = Y(z); if(i===0) ctxX.moveTo(x,y); else ctxX.lineTo(x,y); }
    for(let i=240;i>=0;i--){ const z = H * (i/240); const r = roFunc ? roFunc(z) : 0; const x = X(-r), y = Y(z); ctxX.lineTo(x,y); }
    ctxX.closePath(); ctxX.stroke();
    if(riFunc){ ctxX.beginPath(); for(let i=0;i<=240;i++){ const z = H * (i/240); const r = riFunc(z); const x = X(r), y = Y(z); if(i===0) ctxX.moveTo(x,y); else ctxX.lineTo(x,y); } for(let i=240;i>=0;i--){ const z = H * (i/240); const r = riFunc(z); const x = X(-r), y = Y(z); ctxX.lineTo(x,y); } ctxX.stroke(); }
    ctxX.restore();
  }

  function drawColorbar(ctxX, x, y, w, h, values, label){
    const rng = valueRange(values||[]); const n = Math.max(64, Math.floor(h));
    for(let i=0;i<n;i++){ const t = i/(n-1); ctxX.fillStyle = (label==='|u|') ? rampBlueRed(t) : ramp(t); ctxX.fillRect(x, y + i*(h/n), w, (h/n)+0.5); }
    ctxX.strokeStyle = '#666'; ctxX.strokeRect(x, y, w, h);
    ctxX.fillStyle = '#333'; ctxX.font = '12px Inter';
    if(isFinite(rng.max)) ctxX.fillText(fmt(rng.max), x + w + 8, y + 10);
    if(isFinite(rng.min) && isFinite(rng.max)) ctxX.fillText(fmt((rng.min + rng.max)/2), x + w + 8, y + h/2 + 4);
    if(isFinite(rng.min)) ctxX.fillText(fmt(rng.min), x + w + 8, y + h - 2);
    ctxX.fillText(label || 'shear γ_rz', x + w + 8, y - 6);
  }

  function readInputsFrom(over){ const base = {u:'us',G:120,alpha:0.00011,OD:4,ID:0.5,H:0.5,ends:'bonded',Tm:305,Tr:70}; const p = {...base, ...over}; if(!(p.OD>0) || !(p.H>0) || !(p.Tm>p.Tr)) throw new Error('Check OD, Height, and that molding temp > room temp.'); if(!(p.alpha>=0)) throw new Error('CTE must be ≥ 0.'); if(p.ID<0 || p.ID>=p.OD) throw new Error('ID must be ≥ 0 and < OD.'); return p; }

  // FEM SOLVER
  function solveFENeoHookean(p, opts={}){
    const nr = opts.nr || 24, nz = opts.nz || 36;
    const H = (p.H||1);
    const nR = nr+1, nZ = nz+1; const dZ = H/nz;
    const G = p.G; const nu = 0.49; const lam = (2*G*nu)/(1-2*nu); const mu = G;
    const alpha = p.alpha; const dT = p.Tm - p.Tr; const eps_th = alpha*dT;

    const idx = (i,j)=> j*nR + i; const nd = 2*nR*nZ;
    const Rnod = new Float64Array(nR*nZ); const Znod = new Float64Array(nR*nZ);
    const roAt = (typeof p.roAt==='function') ? p.roAt : (z)=> (p.OD||1)/2;
    const riAt = (typeof p.riAt==='function') ? p.riAt : (z)=> (p.ID||0)/2;
    for(let j=0;j<nZ;j++){
      const z = j*dZ; const ri_line = riAt(z), ro_line = roAt(z);
      for(let i=0;i<nR;i++){ const s = i/nr; const k=idx(i,j); Rnod[k] = ri_line + s*(ro_line - ri_line); Znod[k] = z; }
    }

    const N = nd; const K = new Float64Array(N*N); const f = new Float64Array(N);

    const gp = [-1/Math.sqrt(3), +1/Math.sqrt(3)], w=[1,1];
    function shape(xi,eta){
      const N=[0.25*(1-xi)*(1-eta), 0.25*(1+xi)*(1-eta), 0.25*(1+xi)*(1+eta), 0.25*(1-xi)*(1+eta)];
      const dN_dxi=[ -0.25*(1-eta), 0.25*(1-eta), 0.25*(1+eta), -0.25*(1+eta) ];
      const dN_deta=[ -0.25*(1-xi), -0.25*(1+xi), 0.25*(1+xi), 0.25*(1-xi) ];
      return {N, dN_dxi, dN_deta};
    }

    const D = new Float64Array(16);
    D[0*4+0]=lam+2*mu; D[0*4+1]=lam;       D[0*4+2]=lam;       D[0*4+3]=0;
    D[1*4+0]=lam;       D[1*4+1]=lam+2*mu; D[1*4+2]=lam;       D[1*4+3]=0;
    D[2*4+0]=lam;       D[2*4+1]=lam;       D[2*4+2]=lam+2*mu; D[2*4+3]=0;
    D[3*4+0]=0;         D[3*4+1]=0;         D[3*4+2]=0;         D[3*4+3]=mu;

    function addKe(i,j){
      const nids=[idx(i,j), idx(i+1,j), idx(i+1,j+1), idx(i,j+1)];
      const Ru = nids.map(k=>Rnod[k]); const Zu = nids.map(k=>Znod[k]);
      const ke = new Float64Array(64); const fe = new Float64Array(8);
      for(let a=0;a<2;a++) for(let b=0;b<2;b++){
        const xi=gp[a], eta=gp[b]; const {N:Ni, dN_dxi, dN_deta}=shape(xi,eta);
        let R_xi=0,R_eta=0,Z_xi=0,Z_eta=0, Rgp=0; for(let m=0;m<4;m++){ R_xi+=dN_dxi[m]*Ru[m]; R_eta+=dN_deta[m]*Ru[m]; Z_xi+=dN_dxi[m]*Zu[m]; Z_eta+=dN_deta[m]*Zu[m]; Rgp+=Ni[m]*Ru[m]; }
        const detJ = R_xi*Z_eta - R_eta*Z_xi; if(Math.abs(detJ)<1e-14) return;
        const invJ00 =  Z_eta/detJ, invJ01 = -R_eta/detJ;
        const invJ10 = -Z_xi/detJ, invJ11 =  R_xi/detJ;
        const dN_dR = new Array(4), dN_dZ = new Array(4); for(let m=0;m<4;m++){ dN_dR[m]=dN_dxi[m]*invJ00 + dN_deta[m]*invJ10; dN_dZ[m]=dN_dxi[m]*invJ01 + dN_deta[m]*invJ11; }
        const vol = 2*Math.PI*Math.max(1e-9,Rgp) * detJ * w[a]*w[b];
        const B = new Float64Array(32);
        for(let m=0;m<4;m++){
          const dR_m=dN_dR[m], dZ_m=dN_dZ[m], N_m=Ni[m]; const c = 2*m;
          B[0*8 + c + 0] += dR_m;      // ε_rr
          B[1*8 + c + 1] += dZ_m;      // ε_zz
          B[2*8 + c + 0] += N_m / Math.max(1e-9,Rgp); // ε_tt
          B[3*8 + c + 0] += dZ_m;      // γ_rz
          B[3*8 + c + 1] += dR_m;
        }
        const t = new Float64Array(32);
        for(let r=0;r<4;r++) for(let c=0;c<8;c++){ let s=0; for(let k=0;k<4;k++) s += D[r*4+k]*B[k*8+c]; t[r*8+c]=s; }
        for(let r=0;r<8;r++) for(let c=0;c<8;c++){ let s=0; for(let k=0;k<4;k++) s += B[k*8+r]*t[k*8+c]; ke[r*8+c]+=s*vol; }
        const eth = [eps_th, eps_th, eps_th, 0];
        const De = [ D[0]*eth[0]+D[1]*eth[1]+D[2]*eth[2]+D[3]*eth[3],
                     D[4]*eth[0]+D[5]*eth[1]+D[6]*eth[2]+D[7]*eth[3],
                     D[8]*eth[0]+D[9]*eth[1]+D[10]*eth[2]+D[11]*eth[3],
                     D[12]*eth[0]+D[13]*eth[1]+D[14]*eth[2]+D[15]*eth[3] ];
        for(let c=0;c<8;c++){ let s=0; for(let k=0;k<4;k++) s += B[k*8+c]*De[k]; fe[c] -= s*vol; }
      }
      for(let a=0;a<4;a++){
        const ka = nids[a]; const a_r = 2*ka, a_z = 2*ka+1;
        for(let b=0;b<4;b++){
          const kb = nids[b]; const b_r = 2*kb, b_z = 2*kb+1;
          K[(a_r)*N + (b_r)] += ke[(2*a+0)*8 + (2*b+0)];
          K[(a_r)*N + (b_z)] += ke[(2*a+0)*8 + (2*b+1)];
          K[(a_z)*N + (b_r)] += ke[(2*a+1)*8 + (2*b+0)];
          K[(a_z)*N + (b_z)] += ke[(2*a+1)*8 + (2*b+1)];
        }
        f[a_r] += fe[2*a+0]; f[a_z] += fe[2*a+1];
      }
    }

    for(let j=0;j<nz;j++) for(let i=0;i<nr;i++) addKe(i,j);

    function fix(gid){ for(let c=0;c<N;c++){ K[gid*N + c] = 0; } for(let r=0;r<N;r++){ K[r*N + gid] = 0; } K[gid*N + gid] = 1; f[gid] = 0; }
    if(p.ends==='bonded'){ for(let i=0;i<nR;i++){ const k0=idx(i,0), k1=idx(i,nZ-1); fix(2*k0+0); fix(2*k0+1); fix(2*k1+0); fix(2*k1+1); } }
    else { const k0=idx(0,0); fix(2*k0+1); }

    function matvec(out, x){ for(let r=0;r<N;r++){ let s=0; const rowOff=r*N; for(let c=0;c<N;c++) s+=K[rowOff+c]*x[c]; out[r]=s; } }
    const u = new Float64Array(N); const r = new Float64Array(N); const z = new Float64Array(N); const pvec = new Float64Array(N); const Ap = new Float64Array(N); const M = new Float64Array(N);
    for(let i=0;i<N;i++){ M[i] = K[i*N + i] || 1; }
    matvec(r,u);
    for(let i=0;i<N;i++){ r[i] = f[i] - r[i]; z[i] = r[i]/M[i]; pvec[i] = z[i]; }
    let rz_old = 0; for(let i=0;i<N;i++) rz_old += r[i]*z[i];
    const normF = (()=>{ let s=0; for(let i=0;i<N;i++) s += f[i]*f[i]; return Math.sqrt(s); })();
    const tol = 1e-10 * Math.max(1, normF); const maxIt = opts.maxIter || 2000;
    for(let it=0; it<maxIt && rz_old>tol; it++){
      matvec(Ap, pvec);
      let pAp=0; for(let i=0;i<N;i++) pAp += pvec[i]*Ap[i];
      const alpha_pcg = rz_old/(pAp||1e-30);
      for(let i=0;i<N;i++){ u[i] += alpha_pcg*pvec[i]; r[i] -= alpha_pcg*Ap[i]; z[i] = r[i]/M[i]; }
      let rz_new=0; for(let i=0;i<N;i++) rz_new += r[i]*z[i];
      if(Math.sqrt(rz_new) < 1e-9) break;
      const beta = rz_new/(rz_old||1e-30);
      for(let i=0;i<N;i++) pvec[i] = z[i] + beta*pvec[i];
      rz_old = rz_new;
    }

    const ur = new Float64Array(nR*nZ); const uz = new Float64Array(nR*nZ);
    for(let k=0;k<nR*nZ;k++){ ur[k]=u[2*k+0]; uz[k]=u[2*k+1]; }

    const zRows=[], rInner=[], rOuter=[], zCur=[];
    for(let j=0;j<nZ;j++){
      const kI = idx(0,j), kO = idx(nR-1,j); zRows.push(Znod[kI]);
      rInner.push(Rnod[kI] + ur[kI]); rOuter.push(Rnod[kO] + ur[kO]);
      zCur.push( Znod[kI] + uz[kI] );
    }

    const cells=[]; const shearVals=[]; const deflVals=[]; const dS = 1/nr;
    const gp0 = 0;
    function shape0(){ return {
      N:[0.25*(1-gp0)*(1-gp0),0.25*(1+gp0)*(1-gp0),0.25*(1+gp0)*(1+gp0),0.25*(1-gp0)*(1+gp0)],
      dN_dxi:[ -0.25*(1-gp0), 0.25*(1-gp0), 0.25*(1+gp0), -0.25*(1+gp0) ],
      dN_deta:[ -0.25*(1-gp0), -0.25*(1+gp0), 0.25*(1+gp0), 0.25*(1-gp0) ]
    }; }
    const {N:Ni0, dN_dxi, dN_deta} = shape0();

    for(let j=0;j<nz;j++){
      const z0 = j*dZ, z1 = (j+1)*dZ;
      for(let i=0;i<nr;i++){
        const nids=[idx(i,j), idx(i+1,j), idx(i+1,j+1), idx(i,j+1)];
        let R_xi=0,R_eta=0,Z_xi=0,Z_eta=0; for(let m=0;m<4;m++){ const k=nids[m]; R_xi+=dN_dxi[m]*Rnod[k]; R_eta+=dN_deta[m]*Rnod[k]; Z_xi+=dN_dxi[m]*Znod[k]; Z_eta+=dN_deta[m]*Znod[k]; }
        const detJ = R_xi*Z_eta - R_eta*Z_xi; const invJ00 =  Z_eta/detJ, invJ01 = -R_eta/detJ; const invJ10 = -Z_xi/detJ, invJ11 =  R_xi/detJ;
        const dNr = new Array(4), dNz = new Array(4); for(let m=0;m<4;m++){ dNr[m]=dN_dxi[m]*invJ00 + dN_deta[m]*invJ10; dNz[m]=dN_dxi[m]*invJ01 + dN_deta[m]*invJ11; }
        let ur_R=0, ur_Z=0, uz_R=0, uz_Z=0, ur_c=0, uz_c=0;
        for(let m=0;m<4;m++){ const k=nids[m]; ur_R+=dNr[m]*u[2*k+0]; ur_Z+=dNz[m]*u[2*k+0]; uz_R+=dNr[m]*u[2*k+1]; uz_Z+=dNz[m]*u[2*k+1]; ur_c+=Ni0[m]*u[2*k+0]; uz_c+=Ni0[m]*u[2*k+1]; }
        const gamma = Math.abs(ur_Z + uz_R);
        const mag = Math.hypot(ur_c, uz_c);
        const s0=i*dS, s1=s0+dS; cells.push({r0:s0,r1:s1,z0:z0,z1:z1}); shearVals.push(gamma); deflVals.push(mag);
      }
    }

    return {
      before:{OD:p.OD,ID:p.ID,H:p.H},
      meshRZ:{ri:0,ro:1,H:H,cells},
      shearValsRZ:shearVals,
      deflValsRZ:deflVals,
      boundary:{z:zRows,rInner,rOuter,zCur},
      ur:Array.from(ur), uz:Array.from(uz),
      params:p
    };
  }

  function interp1(xs, ys, x){ const n=xs.length; if(n===0) return NaN; if(x<=xs[0]) return ys[0]; if(x>=xs[n-1]) return ys[n-1]; let i=1; while(i<n && x>xs[i]) i++; const x0=xs[i-1], x1=xs[i], y0=ys[i-1], y1=ys[i]; const t=(x-x0)/(x1-x0); return y0 + t*(y1-y0); }

  function runSanityTests(){
    const out=[];
    try{ updateDefScaleLabel(); out.push('defScale label OK'); }catch(e){ out.push('defScale label FAIL:'+e.message); }
    try{ const g=readGeom(); if(g && g.H>0) out.push('readGeom OK'); else out.push('readGeom FAIL'); }catch(e){ out.push('readGeom EXC:'+e.message); }
    return out;
  }
  if(/(^|[?&])autotest=1(&|$)/.test(location.search)){
    console.log('[sanity]', runSanityTests());
  }

  // -------- EXPORTS --------
  function downloadBlob(filename, text, type='application/octet-stream'){
    const blob = new Blob([text], {type});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  function buildExportPayload(res){
    if(!res || !res.params || !res.boundary) throw new Error('No solution to export. Click “Shrinkage” first.');
    const p = res.params;

    const zBefore = res.boundary.z;        // original z
    const zAfter  = res.boundary.zCur;     // cooled z
    const rInA    = res.boundary.rInner;   // cooled inner
    const rOutA   = res.boundary.rOuter;   // cooled outer

    const ro0Fn = (typeof p.roAt==='function') ? p.roAt : (z)=> (p.OD||0)/2;
    const ri0Fn = (typeof p.riAt==='function') ? p.riAt : (z)=> (p.ID||0)/2;

    const original = zBefore.map(z => ({ z, ri: ri0Fn(z), ro: ro0Fn(z) }));
    const shrunken = zAfter.map((z_after, j) => ({ z_after, ri_after: rInA[j], ro_after: rOutA[j] }));

    const payload = {
      units: p.u,
      inputs: {
        G: p.G, alpha: p.alpha, Tm: p.Tm, Tr: p.Tr, ends: p.ends, geom: p.geom,
        OD: p.OD, ID: p.ID, H: p.H, OD0: p.OD0, OD1: p.OD1, ID0: p.ID0, ID1: p.ID1
      },
      original,   // [{z, ri, ro}]
      shrunken,   // [{z_after, ri_after, ro_after}]
      notes: "Axisymmetric r–z; radii/lengths in selected units; rows align by FE z-row index."
    };

    const rows = ['z_before,ri_before,ro_before,z_after,ri_after,ro_after'];
    const n = Math.min(original.length, shrunken.length);
    for(let j=0;j<n;j++){
      const o = original[j], a = shrunken[j];
      rows.push([o.z, o.ri, o.ro, a.z_after, a.ri_after, a.ro_after].map(v => (Number.isFinite(v)?v:'')).join(','));
    }
    const csv = rows.join('\n');

    return { json: JSON.stringify(payload, null, 2), csv };
  }

  function exportJSON(){
    try{
      const now = new Date();
      const { json } = buildExportPayload(lastFE);
      
      // Parse and add timestamp to the JSON object
      const payload = JSON.parse(json);
      payload.timestamp = {
        date: now.toLocaleDateString(),
        time: now.toLocaleTimeString(),
        iso: now.toISOString()
      };
      
      const jsonWithTimestamp = JSON.stringify(payload, null, 2);
      const ts = now.toISOString().replace(/[:.]/g,'-');
      downloadBlob(`rubber_shrinkage_${ts}.json`, jsonWithTimestamp, 'application/json');
    }catch(err){ alert(err.message || String(err)); }
  }



  function exportCSV(){
    try{
      const now = new Date();
      const { csv } = buildExportPayload(lastFE);
      
      // Add timestamp header to CSV
      const csvWithTimestamp = `Export Date,${now.toLocaleDateString()}\n` +
                               `Export Time,${now.toLocaleTimeString()}\n\n` +
                               csv;
      
      const ts = now.toISOString().replace(/[:.]/g,'-');
      downloadBlob(`rubber_shrinkage_${ts}.csv`, csvWithTimestamp, 'text/csv');
    }catch(err){ alert(err.message || String(err)); }
  }




  if(btnJson) btnJson.addEventListener('click', exportJSON);
  if(btnCsv)  btnCsv.addEventListener('click', exportCSV);

  function importJSON(){
    if(!jsonFileInput) return;
    jsonFileInput.click();
  }

  if(jsonFileInput){
    jsonFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(!file) return;
      
      const reader = new FileReader();
      reader.onload = (evt) => {
        try{
          const data = JSON.parse(evt.target.result);
          
          // Validate structure
          if(!data.inputs){
            throw new Error('Invalid JSON: missing inputs section');
          }
          
          const inp = data.inputs;
          
          // Set units first
          if(inp.u && unitsEl){
            unitsEl.value = inp.u;
          }
          
          // Set basic material properties
          if(inp.G !== undefined && GEl) GEl.value = inp.G;
          if(inp.alpha !== undefined && aEl) aEl.value = inp.alpha;
          if(inp.Tm !== undefined && TmEl) TmEl.value = inp.Tm;
          if(inp.Tr !== undefined && TrEl) TrEl.value = inp.Tr;
          
          // Set geometry type
          if(inp.geom && geomEl){
            geomEl.value = inp.geom;
            updateGeomUI();
          }
          
          // Set dimensions based on geometry type
          if(inp.geom === 'cyl'){
            if(inp.OD !== undefined && ODEl) ODEl.value = inp.OD;
            if(inp.ID !== undefined && IDEl) IDEl.value = inp.ID;
            if(inp.H !== undefined && HEl) HEl.value = inp.H;
          } else if(inp.geom === 'cone' || inp.geom === 'curved'){
            if(inp.H !== undefined && HEl) HEl.value = inp.H;
            if(inp.OD0 !== undefined && OD0El) OD0El.value = inp.OD0;
            if(inp.OD1 !== undefined && OD1El) OD1El.value = inp.OD1;
            if(inp.ID0 !== undefined && ID0El) ID0El.value = inp.ID0;
            if(inp.ID1 !== undefined && ID1El) ID1El.value = inp.ID1;
          }
          
          // Set end condition
          if(inp.ends && endsEl){
            endsEl.value = inp.ends;
          }
          
          // Clear last solution
          lastFE = null;
          setSolveState('ready');
          
          // Update preview
          drawPreview();
          
          // Show success message
          const timestamp = data.timestamp ? 
            ` (from ${data.timestamp.date} ${data.timestamp.time})` : '';
          alert(`Model imported successfully${timestamp}\n\nClick "Shrinkage" to solve.`);
          
        }catch(err){
          console.error(err);
          alert('Failed to import JSON: ' + (err.message || String(err)));
        }
        
        // Clear the file input so the same file can be re-imported if needed
        jsonFileInput.value = '';
      };
      
      reader.readAsText(file);
    });
  }

  if(btnImportJson) btnImportJson.addEventListener('click', importJSON);






  // ---- boot
  scrubEscapedLabelArtifacts();
  updateDefScaleLabel();
  setSolveState('ready');
  fitCanvases();
  drawPreview();
  redrawResults();
})();
</script>
</body>
</html>



