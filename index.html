<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beam Modal Solver</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <style>
    body { background: #f4f4f4; font-family: sans-serif; margin: 20px; }
    h2 { margin-bottom: 10px; }
    
    /* 1. CHANGED: Reduced width from 900px to 720px */
    #container { width: 720px; }

    #beamCanvas { border: 1px solid #ccc; margin-top: 12px; cursor: pointer; background: #fff; display: block; }
    
    .swal2-popup { font-size: 12px !important; width: auto !important; min-width: 250px !important; }
    .swal2-input, .swal2-select { font-size: 12px !important; width: 120px !important; margin: 5px !important; }
    .swal2-html-container label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
    .swal2-html-container label span { margin-right: 10px; }

    /* Updated Toolbar Layout */
    .toolbar { 
      display: flex; 
      gap: 8px; 
      align-items: center;
      flex-wrap: wrap; /* Added wrapping for narrower width */
      /* 2. CHANGED: Reduced width from 900px to 720px */
      width: 720px; 
      background: #e0e0e0;
      padding: 8px;
      box-sizing: border-box;
      border-radius: 4px;
    }

    /* 3. CHANGED: Reduced width from 900px to 720px */
    .results { margin-top: 8px; font-size: 14px; width: 720px; }
    .muted { color:#666; font-size: 12px; }
    
    .modeCanvas { display:block; margin: 12px 0; border: 1px solid #ccc; background:#fff; }
    
    #modeToggles label { margin-right: 10px; cursor: pointer; }
    #animControls label { margin-left: 12px; }
    #animControls button { margin-left: 6px; }

    /* Label styling */
    .toolbar label { display: inline-flex; align-items: center; gap: 4px; color: #000; font-size: 14px; }
    .toolbar input[type=number] { width: 50px; padding: 4px; height: 20px; border: 1px solid #999; border-radius: 3px;}
    
    /* Button styling */
    .toolbar button { 
      padding: 5px 12px; 
      font-size: 13px; 
      cursor: pointer; 
      background: #eee; 
      border: 1px solid #999; 
      border-radius: 3px; 
    }
    .toolbar button:hover { background: #ddd; }
  </style>
</head>
<body>
  <h2>Beam Modal Solver</h2>

  <div id="container">
    <div class="toolbar">
      <label>Segments (max 10): <input id="numSegments" type="number" min="1" max="10" value="2"></label>
      <label>Gravity (G): <input id="gravityInput" type="number" value="386" style="width:60px"></label>
      <button onclick="buildBeam()">Build Beam</button>
      <button onclick="computeModesRefined()">Compute Modes</button>
      
      <button onclick="exportJSON()">Export JSON</button>
      <button onclick="exportCSV()">Export CSV</button>
    </div>

    <canvas id="beamCanvas" width="720" height="220"></canvas>
    
    <div id="freqList" class="results"></div>
    <div id="modeToggles" class="results"></div>
    
    <div id="animControls" class="results">
      <strong>Animate:</strong>
      <button id="btnPlay" disabled>Play</button>
      <button id="btnPause" disabled>Pause</button>
      <label>Mode <select id="animMode" style="width:60px"></select></label>
      <label>Speed ×<input id="animSpeed" type="range" min="0.01" max="1" step="0.01" value="1" style="vertical-align: middle; width:120px"> <span id="animSpeedVal">1.00</span></label>
      <label>Amp ×<input id="animAmp" type="range" min="0.2" max="1.5" step="0.1" value="1" style="vertical-align: middle; width:120px"> <span id="animAmpVal">1.0</span></label>
      <span class="muted">(animates the selected mode only)</span>
    </div>
    
    <canvas id="modesCombined" width="720" height="340" class="modeCanvas"></canvas>
  </div>

<script>
// --- configuration ---
const INTERNAL_NODES_PER_SEG = 10; // fixed refinement (m)

let segments = [];
let nodes = [];      // primary nodes only (length = S+1)
let lastModes = null; // [{lambdaGEP, freq, vec(full DOF)}] on refined grid

// animation state
const anim = { running:false, rafId:0, t0:0, modeIndex:0, speed:1, amp:1 };

function getRefine(){ return INTERNAL_NODES_PER_SEG; }

function buildBeam() {
  stopAnimation();
  const S = Math.max(1, Math.min(10, parseInt(document.getElementById("numSegments").value)));
  const totalL = 96; // arbitrary default total length
  // reset segments
  segments = [];
  for (let i = 0; i < S; i++) {
    segments.push({ E: 12e6, I: 21.3, L: totalL / S, rho: 0.28, A: 2.0 });
  }
  // primary nodes only (S+1)
  nodes = Array(S + 1).fill().map(() => ({ bc: "free", W: 0, Kv: 0, Kr: 0 }));
  drawBeam();
  // reset UI areas
  lastModes = null;
  renderFreqList([]);
  buildModeToggles(0);
  buildAnimControls(0);
  renderCombinedModes();
}

async function editSegment(i){
  const s = segments[i];
  const { value: data } = await Swal.fire({
    title: `Segment ${i} Properties`,
    html:
      `<label><span>E:</span><input id="segE" class="swal2-input" value="${s.E}"></label>
       <label><span>I:</span><input id="segI" class="swal2-input" value="${s.I}"></label>
       <label><span>L:</span><input id="segL" class="swal2-input" value="${s.L}"></label>
       <label><span>ρ (dens):</span><input id="segRho" class="swal2-input" value="${s.rho}"></label>
       <label><span>A:</span><input id="segA" class="swal2-input" value="${s.A}"></label>`,
    focusConfirm:false,
    preConfirm:()=>[
      parseFloat(document.getElementById('segE').value),
      parseFloat(document.getElementById('segI').value),
      parseFloat(document.getElementById('segL').value),
      parseFloat(document.getElementById('segRho').value),
      parseFloat(document.getElementById('segA').value)
    ]
  });
  if (data){
    const [E,I,L,rho,A] = data.map(v=> (isFinite(v)? v:0));
    segments[i] = { E,I,L,rho,A };
    drawBeam();
  }
}

function drawBeam() {
  const canvas = document.getElementById("beamCanvas");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (segments.length === 0) return;
  const margin = 50;
  const midY = canvas.height/2;
  const totalLength = segments.reduce((sum, seg) => sum + seg.L, 0);
  const scaleX = (canvas.width - 2 * margin) / totalLength;
  const maxEI = Math.max(...segments.map(seg => seg.E * seg.I));
  
  // Height scaling set to 0.12 (approx 1/3 of previous 0.35)
  const maxHeight = 0.12 * canvas.height; 

  // PASS 1: Draw all Segments
  let x = margin;
  for (let i = 0; i < segments.length; i++) {
    const seg = segments[i];
    const width = seg.L * scaleX;
    const height = (seg.E * seg.I / maxEI) * maxHeight;
    
    // Light gray fill
    ctx.fillStyle = "#ccc"; 
    ctx.fillRect(x, midY - height / 2, width, height);

    // Segment text
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    const props = [ `E: ${seg.E}`, `I: ${seg.I}`, `L: ${seg.L}`, `ρ: ${seg.rho}`, `A: ${seg.A}` ];
    const startY = midY + height / 2 + 12;
    ctx.font = "11px sans-serif";
    for (let j = 0; j < props.length; j++) ctx.fillText(props[j], x + width / 2, startY + j * 14);

    x += width;
  }

  // PASS 2: Draw all Nodes on top (so blue dots are fully exposed)
  x = margin;
  // Draw first node
  drawNodeFeatures(ctx, x, midY, nodes[0]);
  
  // Draw subsequent nodes
  for (let i = 0; i < segments.length; i++) {
    const seg = segments[i];
    const width = seg.L * scaleX;
    x += width;
    drawNodeFeatures(ctx, x, midY, nodes[i+1]);
  }
}

function buildPrimaryNodePositionMap(){
  const margin = 50; 
  const totalLength = segments.reduce((sum, seg) => sum + seg.L, 0) || 1;
  const scaleX = (document.getElementById('beamCanvas').width - 2 * margin) / totalLength;
  const xs = [];
  let cumL = 0;
  xs.push(margin); // leftmost
  for (let i=0;i<segments.length;i++){
    cumL += segments[i].L;
    xs.push(margin + cumL * scaleX);
  }
  const is = xs.map((_,idx)=> idx);
  return { xs, is };
}

function drawNodeFeatures(ctx, x, y, node = { bc: 'free', W:0, Kv:0, Kr:0 }){
  ctx.save();
  ctx.strokeStyle = "black"; ctx.lineWidth = 2; 
  ctx.fillStyle = "#06f"; // Blue nodes

  // support glyphs (keep black outlines)
  if (node.bc === "pinned") {
    ctx.beginPath(); ctx.moveTo(x - 15, y + 17); ctx.lineTo(x, y); ctx.lineTo(x + 15, y + 17); ctx.closePath(); ctx.stroke();
  } else if (node.bc === "fixed") {
    ctx.beginPath(); ctx.moveTo(x - 5, y - 20); ctx.lineTo(x - 5, y + 20); ctx.moveTo(x + 5, y - 20); ctx.lineTo(x + 5, y + 20); ctx.stroke();
  }

  // Kv vertical spring
  if (node.Kv > 0) {
    ctx.beginPath(); let springY = y + 8; ctx.moveTo(x, springY);
    for (let i=0;i<4;i++){ ctx.lineTo(x + (i%2? -6:6), springY += 6); }
    ctx.lineTo(x, springY + 6); ctx.stroke();
  }

  // Kr rotational spring
  if (node.Kr > 0) {
    ctx.beginPath();
    ctx.moveTo(x-35, y-20); ctx.lineTo(x-25, y-20); ctx.lineTo(x-22, y-30); ctx.lineTo(x-16, y-10);
    ctx.lineTo(x-10, y-30); ctx.lineTo(x-8,  y-20); ctx.lineTo(x,    y-20); ctx.lineTo(x,    y+20);
    ctx.lineTo(x+8,  y+20); ctx.lineTo(x+10, y+30); ctx.lineTo(x+16, y+10); ctx.lineTo(x+22, y+30);
    ctx.lineTo(x+25, y+20); ctx.lineTo(x+35, y+20);
    ctx.stroke();
  }

  // node dot (Blue) - Drawn last to be on top of everything
  const r = (node.W && node.W > 0) ? 8 : 5;
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); 

  // labels
  function fmt(v){
    if (!isFinite(v)) return '0';
    const a = Math.abs(v);
    if (a >= 1000) return v.toFixed(0);
    if (a >= 100)  return v.toFixed(1);
    if (a >= 10)   return v.toFixed(2);
    if (a >= 1)    return v.toFixed(3);
    if (a >= 0.01) return v.toFixed(4);
    return v.toExponential(2);
  }
  ctx.fillStyle = "black"; ctx.textAlign = "center"; ctx.font = "11px sans-serif";
  const labels = [];
  if (Math.abs(Number(node.W)||0)  > 1e-12) labels.push(`W:${fmt(Number(node.W))}`);
  if (Math.abs(Number(node.Kv)||0) > 1e-12) labels.push(`Kv:${fmt(Number(node.Kv))}`);
  if (Math.abs(Number(node.Kr)||0) > 1e-12) labels.push(`Kr:${fmt(Number(node.Kr))}`);
  let y0 = y - 36;
  for (let i=0;i<labels.length;i++) ctx.fillText(labels[i], x, y0 - i*12);

  ctx.restore();
}

const beamCanvas = document.getElementById("beamCanvas");
beamCanvas.addEventListener("click", function (e) {
  const rect = beamCanvas.getBoundingClientRect();
  const xClick = e.clientX - rect.left;
  const yClick = e.clientY - rect.top;

  const margin = 50; 
  const midY = beamCanvas.height/2;
  const totalLength = segments.reduce((sum, seg) => sum + seg.L, 0);
  if (totalLength <= 0) return;
  const scaleX = (beamCanvas.width - 2 * margin) / totalLength;
  const maxEI = Math.max(...segments.map(seg => seg.E * seg.I)) || 1;
  const maxHeight = 0.12 * beamCanvas.height; // Updated height match

  const map = buildPrimaryNodePositionMap();
  const nodeXs = map.xs;
  const nodeIs = map.is;

  const nodeHitR = 14;
  for (let k = 0; k < nodeXs.length; k++) {
    const dx0 = xClick - nodeXs[k];
    const dy0 = yClick - midY;
    if (Math.hypot(dx0, dy0) <= nodeHitR) {
      const idx = nodeIs[k];
      if (idx >= 0 && idx < nodes.length) editNode(idx);
      return;
    }
  }

  let x = margin;
  for (let i = 0; i < segments.length; i++) {
    const seg = segments[i];
    const width = seg.L * scaleX;
    const height = (seg.E * seg.I / maxEI) * maxHeight;

    const left = x + nodeHitR + 2;
    const right = x + width - (nodeHitR + 2);

    if (right > left) {
      if (xClick >= left && xClick <= right && yClick >= (midY - height/2 - 10) && yClick <= (midY + height/2 + 10)) {
        editSegment(i);
        return;
      }
    }
    x += width;
  }
});

async function editNode(i) {
  if (i < 0 || i >= nodes.length) return;
  const node = nodes[i] || { bc:'free', W:0, Kv:0, Kr:0 };
  const { value: data } = await Swal.fire({
    title: `Node ${i} Properties`,
    html:
      `<label><span>BC:</span><select id=\"bc\" class=\"swal2-select\">\n          <option value=\"free\" ${node.bc === 'free' ? 'selected' : ''}>Free</option>\n          <option value=\"pinned\" ${node.bc === 'pinned' ? 'selected' : ''}>Simple support (w=0, θ free)</option>\n          <option value=\"fixed\" ${node.bc === 'fixed' ? 'selected' : ''}>Fixed</option>\n        </select></label>\n        <label><span>W (lbf):</span><input id=\"W\" class=\"swal2-input\" value=\"${node.W}\"></label>\n        <label><span>Kv (lb/in):</span><input id=\"Kv\" class=\"swal2-input\" value=\"${node.Kv}\"></label>\n        <label><span>Kr (in·lb/rad):</span><input id=\"Kr\" class=\"swal2-input\" value=\"${node.Kr}\"></label>\n        <span class=\"muted\">Used in modal: Mww += W/G; Kww += Kv; Kθθ += Kr</span>`,
    focusConfirm: false,
    preConfirm: () => [
      document.getElementById("bc").value,
      parseFloat(document.getElementById("W").value),
      parseFloat(document.getElementById("Kv").value),
      parseFloat(document.getElementById("Kr").value)
    ]
  });
  if (data) nodes[i] = { ...nodes[i], bc: data[0], W: (isFinite(data[1])? data[1]:0), Kv: (isFinite(data[2])? data[2]:0), Kr: (isFinite(data[3])? data[3]:0) };
  drawBeam();
}

function computeModesRefined() {
  stopAnimation();
  if (!segments.length) { buildBeam(); return; }
  const m = getRefine(); 

  const g = parseFloat(document.getElementById("gravityInput").value) || 386;
  const S = segments.length; 
  const Nn_ref = S * (m + 1) + 1; 
  const dofPerNode = 2; const N = dofPerNode * Nn_ref;

  const M = numeric.rep([N, N], 0); const K = numeric.rep([N, N], 0);

  for (let i = 0; i < S; i++) {
    const seg = segments[i];
    const EI = seg.E * seg.I;
    const mu = (seg.rho / g) * seg.A; 
    const sub = m + 1; 
    const Lsub = seg.L / sub;
    const startRef = i * (m + 1);

    for (let j = 0; j < sub; j++) {
      const n1 = startRef + j;
      const n2 = n1 + 1;
      const dofs = [ 2*n1, 2*n1+1, 2*n2, 2*n2+1 ];

      const kLocal = [
        [12, 6*Lsub, -12, 6*Lsub],
        [6*Lsub, 4*Lsub*Lsub, -6*Lsub, 2*Lsub*Lsub],
        [-12, -6*Lsub, 12, -6*Lsub],
        [6*Lsub, 2*Lsub*Lsub, -6*Lsub, 4*Lsub*Lsub]
      ].map(r => r.map(v => v * EI / (Lsub*Lsub*Lsub)));

      for (let a=0;a<4;a++){
        for (let b=0;b<4;b++){
          K[dofs[a]][dofs[b]] += kLocal[a][b];
        }
      }

      const c = mu * Lsub / 420;
      const mLocal = [
        [156,    22*Lsub,  54,    -13*Lsub],
        [22*Lsub, 4*Lsub*Lsub, 13*Lsub, -3*Lsub*Lsub],
        [54,     13*Lsub, 156,    -22*Lsub],
        [-13*Lsub, -3*Lsub*Lsub, -22*Lsub, 4*Lsub*Lsub]
      ].map(row => row.map(v => v * c));

      for (let a=0;a<4;a++){
        for (let b=0;b<4;b++){
          M[dofs[a]][dofs[b]] += mLocal[a][b];
        }
      }
    }
  }

  for (let p=0; p<nodes.length; p++){
    const refIdx = p * (m + 1); 
    const v = 2*refIdx, r = 2*refIdx+1;
    const W = Number(nodes[p].W)||0; const Kv = Number(nodes[p].Kv)||0; const Kr = Number(nodes[p].Kr)||0;
    if (W) M[v][v] += W / g;
    if (Kv) K[v][v] += Kv;
    if (Kr) K[r][r] += Kr;
  }

  const constrained = new Set();
  for (let p=0; p<nodes.length; p++){
    const bc = nodes[p].bc; const refIdx = p * (m + 1); const v = 2*refIdx, r = 2*refIdx+1;
    if (bc === 'fixed' || bc === 'pinned') { constrained.add(v); if (bc === 'fixed') constrained.add(r); }
  }
  const free = []; for (let i=0;i<N;i++){ if(!constrained.has(i)) free.push(i); }
  if (!free.length) { Swal.fire("Error", "All DOFs are constrained."); return; }

  const Kred = submat(K, free); const Mred = submat(M, free);

  let A; try { A = numeric.dot(numeric.inv(Mred), Kred); } catch(e){ Swal.fire('Error','M is singular. Check W/g and density/area.','error'); return; }
  const eig = numeric.eig(A); const vals = eig.lambda.x; const V = eig.E.x; 
  const pairs = vals.map((val, i) => ({ val: val, vec: V.map(row => row[i]) }))
                    .filter(p => p.val > 0 && isFinite(p.val))
                    .sort((a,b)=> a.val-b.val)
                    .slice(0, 3);

  let modes = [];
  pairs.forEach(p => {
    const freq = Math.sqrt(p.val)/(2*Math.PI);
    const full = expandToFull(p.vec, free, N);
    const fullN = normalizeMode(full);
    modes.push({ lambdaGEP: p.val, freq, vec: fullN });
  });

  lastModes = modes;
  renderFreqList(modes);
  buildModeToggles(modes.length);
  buildAnimControls(modes.length);
  renderCombinedModes();
}

function buildModeToggles(count){
  const div = document.getElementById('modeToggles');
  div.innerHTML = '';
  if (!count) return;
  const label = document.createElement('span');
  label.textContent = 'Show modes:'; label.style.marginRight = '8px';
  div.appendChild(label);
  for (let i=1;i<=count;i++){
    const id = 'showMode' + i;
    const wrap = document.createElement('label');
    const cb = document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.checked = true; cb.style.marginRight='4px';
    cb.addEventListener('change', ()=>{ if (!anim.running) renderCombinedModes(); });
    wrap.appendChild(cb); wrap.append(`Mode ${i}`);
    wrap.style.marginRight = '10px';
    div.appendChild(wrap);
  }
}

function buildAnimControls(count){
  const btnPlay = document.getElementById('btnPlay');
  const btnPause = document.getElementById('btnPause');
  const sel = document.getElementById('animMode');
  sel.innerHTML = '';
  for (let i=1;i<=count;i++){
    const opt = document.createElement('option');
    opt.value = i-1; opt.textContent = i; sel.appendChild(opt);
  }
  const enabled = count > 0;
  btnPlay.disabled = !enabled; btnPause.disabled = true; sel.disabled = !enabled;
}

function submat(mat, idx){ return idx.map(i => idx.map(j => mat[i][j])); }
function expandToFull(vecRed, free, N){ const full = Array(N).fill(0); for(let i=0;i<free.length;i++){ full[free[i]] = vecRed[i]; } return full; }
function normalizeMode(full){ let maxAbs = 0; for (let i=0;i<full.length;i+=2){ const a = Math.abs(full[i]); if (a > maxAbs) maxAbs = a; } if (maxAbs < 1e-20) return full.slice(); return full.map(v => v / maxAbs); }

function renderFreqList(modes){
  const div = document.getElementById('freqList');
  if (!modes || !modes.length){ div.textContent = ''; return; }
  let html = '<strong>Frequencies (Hz):</strong> ' + modes.map((m,i)=> `f${i+1}=${m.freq.toFixed(3)}`).join(', ');
  html += ' <span class="muted">(mode shapes normalized to max |w| = 1; consistent element mass used)</span>';
  div.innerHTML = html;
}

function renderCombinedModes(){
  const canvas = document.getElementById('modesCombined');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width, canvas.height);
  if (!lastModes || !lastModes.length) return;

  const m = getRefine();
  const xPositions = [];
  let x = 0;
  for (let i=0;i<segments.length;i++){
    const L = segments[i].L; const sub = m+1; const Lsub = L/sub;
    const start = (i===0) ? 0 : 1; 
    for (let j=start; j<=sub; j++) xPositions.push(x + j*Lsub);
    x += L;
  }

  const totalLength = segments.reduce((s,sg)=>s+sg.L,0) || 1;
  const scaleX = canvas.width / totalLength;
  const offsetY = canvas.height/2;
  const scaleY = canvas.height * 0.4; 

  drawGuides(ctx, canvas, offsetY, scaleY);

  const selected = [];
  for (let i=0;i<lastModes.length;i++){
    const cb = document.getElementById('showMode' + (i+1));
    if (!cb || cb.checked) selected.push(i);
  }

  const colors = ['#1f77b4', '#2ca02c', '#d62728'];

  for (let idx of selected){
    const mode = lastModes[idx];
    const full = mode.vec; 

    const w = []; for (let d=0; d<full.length; d+=2) w.push(full[d]);

    ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = colors[idx % colors.length];
    const n = Math.min(xPositions.length, w.length);
    for (let k=0;k<n;k++){
      const px = xPositions[k]*scaleX; const py = offsetY - (w[k]||0)*scaleY;
      if (k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  drawAxesAndLegend(ctx, canvas, lastModes, true);
}

function drawGuides(ctx, canvas, offsetY, scaleY){
  ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.beginPath();
  ctx.moveTo(0, offsetY - 1*scaleY); ctx.lineTo(canvas.width, offsetY - 1*scaleY);
  ctx.moveTo(0, offsetY); ctx.lineTo(canvas.width, offsetY);
  ctx.moveTo(0, offsetY + 1*scaleY); ctx.lineTo(canvas.width, offsetY + 1*scaleY);
  ctx.stroke();
  ctx.fillStyle = '#666'; ctx.font = '12px sans-serif';
  ctx.fillText('+1', 4, offsetY - 1*scaleY - 4);
  ctx.fillText('0', 4, offsetY - 2);
  ctx.fillText('-1', 4, offsetY + 1*scaleY + 12);
}

function drawAxesAndLegend(ctx, canvas, modes, useToggles){
  ctx.fillStyle = '#000'; ctx.font = '12px sans-serif';
  ctx.fillText('x (length units)', canvas.width - 140, canvas.height - 8);
  ctx.save(); ctx.translate(14, canvas.height/2); ctx.rotate(-Math.PI/2); ctx.fillText('Normalized deflection', 0, 0); ctx.restore();

  const colors = ['#1f77b4', '#2ca02c', '#d62728'];
  const legendX = canvas.width - 260; let legendY = 18;
  for (let i=0;i<modes.length;i++){
    const mode = modes[i];
    const cb = document.getElementById('showMode' + (i+1));
    const visible = !useToggles || !cb || cb.checked;
    ctx.strokeStyle = colors[i % colors.length]; ctx.lineWidth = visible ? 3 : 1; ctx.globalAlpha = visible ? 1 : 0.3;
    ctx.beginPath(); ctx.moveTo(legendX, legendY); ctx.lineTo(legendX+22, legendY); ctx.stroke(); ctx.globalAlpha = 1;
    ctx.fillStyle = '#000';
    ctx.fillText(`Mode ${i+1} (f${i+1}=${mode.freq.toFixed(3)} Hz) ${visible ? '' : '(hidden)'}`, legendX + 28, legendY + 4);
    legendY += 18;
  }
}

function startAnimation(){
  if (!lastModes || !lastModes.length) return;
  const sel = document.getElementById('animMode');
  anim.modeIndex = parseInt(sel.value||'0') || 0;
  anim.speed = parseFloat(document.getElementById('animSpeed').value)||1;
  anim.amp = parseFloat(document.getElementById('animAmp').value)||1;
  if (anim.running) cancelAnimationFrame(anim.rafId);
  anim.running = true; anim.t0 = performance.now();
  document.getElementById('btnPlay').disabled = true;
  document.getElementById('btnPause').disabled = false;
  const step = (ts)=>{ if (!anim.running) return; drawAnimatedFrame((ts-anim.t0)/1000); anim.rafId = requestAnimationFrame(step); };
  anim.rafId = requestAnimationFrame(step);
}
function stopAnimation(){
  anim.running = false; if (anim.rafId) cancelAnimationFrame(anim.rafId); anim.rafId = 0;
  const btnPlay = document.getElementById('btnPlay'); const btnPause = document.getElementById('btnPause');
  if (btnPlay) btnPlay.disabled = !(lastModes && lastModes.length);
  if (btnPause) btnPause.disabled = true;
  renderCombinedModes();
}

function drawAnimatedFrame(t){
  const canvas = document.getElementById('modesCombined');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width, canvas.height);
  if (!lastModes || !lastModes.length) return;
  const mode = lastModes[Math.min(anim.modeIndex, lastModes.length-1)];

  const m = getRefine();
  const xPositions = [];
  let x = 0;
  for (let i=0;i<segments.length;i++){
    const L = segments[i].L; const sub = m+1; const Lsub = L/sub;
    const start = (i===0)?0:1; for (let j=start;j<=sub;j++) xPositions.push(x + j*Lsub);
    x += L;
  }
  const totalLength = segments.reduce((s,sg)=>s+sg.L,0) || 1;
  const scaleX = canvas.width / totalLength;
  const offsetY = canvas.height/2;
  const scaleY = canvas.height * 0.4 * anim.amp; 

  drawGuides(ctx, canvas, offsetY, canvas.height*0.4);

  const full = mode.vec; const w = []; for (let d=0; d<full.length; d+=2) w.push(full[d]);
  const omega = 2*Math.PI*mode.freq*anim.speed;

  ctx.beginPath(); ctx.lineWidth = 2.5; ctx.strokeStyle = '#1f77b4';
  const n = Math.min(xPositions.length, w.length);
  for (let k=0;k<n;k++){
    const px = xPositions[k]*scaleX; const py = offsetY - (w[k]||0)*scaleY * Math.sin(omega*t);
    if (k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  drawAxesAndLegend(ctx, canvas, [mode], false);
}

// 6 & 7: Export Functions
function getModeDataForExport() {
  if (!lastModes || !lastModes.length) return null;
  const m = getRefine();
  const xPositions = [];
  let x = 0;
  // Reconstruct X positions based on refined grid
  for (let i=0;i<segments.length;i++){
    const L = segments[i].L; const sub = m+1; const Lsub = L/sub;
    const start = (i===0)?0:1; 
    for (let j=start;j<=sub;j++) xPositions.push(x + j*Lsub);
    x += L;
  }

  const rows = [];
  const numPoints = xPositions.length;
  for(let i=0; i<numPoints; i++){
    let row = { x: xPositions[i] };
    lastModes.forEach((mode, idx) => {
      // vec has [w0, th0, w1, th1...] -> we want w (even indices)
      // i corresponds to node index i, so we want vec[2*i]
      if (2*i < mode.vec.length) {
        row[`Mode ${idx+1} (${mode.freq.toFixed(2)}Hz)`] = mode.vec[2*i];
      }
    });
    rows.push(row);
  }
  return rows;
}

function exportJSON() {
  const data = getModeDataForExport();
  if (!data) { Swal.fire("No data", "Compute modes first.", "warning"); return; }
  
  const output = {
    version: "1.0",
    date: new Date().toLocaleDateString(),
    timestamp: new Date().toLocaleTimeString(),
    modes: data
  };
  
  const blob = new Blob([JSON.stringify(output, null, 2)], {type: "application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "beam_modes.json";
  a.click();
  URL.revokeObjectURL(url);
}

function exportCSV() {
  const data = getModeDataForExport();
  if (!data) { Swal.fire("No data", "Compute modes first.", "warning"); return; }
  
  // Headers
  const headers = Object.keys(data[0]);
  const csvRows = [];
  csvRows.push(headers.join(","));
  
  data.forEach(row => {
    const values = headers.map(header => row[header]);
    csvRows.push(values.join(","));
  });
  
  const blob = new Blob([csvRows.join("\n")], {type: "text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "beam_modes.csv";
  a.click();
  URL.revokeObjectURL(url);
}

(function(){
  const btnPlay = document.getElementById('btnPlay');
  const btnPause = document.getElementById('btnPause');
  const sel = document.getElementById('animMode');
  const speed = document.getElementById('animSpeed');
  const amp = document.getElementById('animAmp');
  const speedVal = document.getElementById('animSpeedVal');
  const ampVal = document.getElementById('animAmpVal');
  if (btnPlay) btnPlay.addEventListener('click', startAnimation);
  if (btnPause) btnPause.addEventListener('click', stopAnimation);
  if (sel) sel.addEventListener('change', ()=>{ if (anim.running) startAnimation(); });
  if (speed) speed.addEventListener('input', ()=>{ speedVal.textContent = parseFloat(speed.value).toFixed(2); if (anim.running) startAnimation(); });
  if (amp) amp.addEventListener('input', ()=>{ ampVal.textContent = parseFloat(amp.value).toFixed(1); if (anim.running) startAnimation(); });
})();

window.buildBeam = buildBeam;
window.computeModesRefined = computeModesRefined;
window.exportJSON = exportJSON;
window.exportCSV = exportCSV;

// initial
buildBeam();
</script>
</body>
</html>

