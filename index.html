<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beam Solver — Full Features</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <style>
    :root {
      --pad: 50px;
      --beam-w: 960px;
      --plot-h: 260px;
      --right-gutter: 25px;
    }
    body { background: #f4f4f4; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h2 { margin: 0 0 12px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row + .row { margin-top: 8px; }
    label { display: inline-flex; gap: 6px; align-items: center; }
    input, button, select { height: 30px; padding: 0 10px; border-radius: 6px; border: 1px solid #bbb; background: #fff; }
    button { cursor: pointer; }
    button.primary { background: #9aa0a6; color: #111; border-color: #9aa0a6; border-radius: 2px; }
    #stage { max-width: 100%; }
    #beamCanvas, .plot {
      display: block;
      width: min(var(--beam-w), calc(100% - var(--right-gutter)));
      max-width: calc(100% - var(--right-gutter));
      background: #fff;
      border: 1px solid #ddd;
    }
    #beamCanvas { height: 260px; cursor: crosshair; }
    .plot { height: var(--plot-h); }
    @media (max-width: 1100px) { :root { --right-gutter: 24px; } }
    .swal2-popup { font-size: 12px !important; width: auto !important; min-width: 260px !important; }
    .swal2-input, .swal2-select { font-size: 12px !important; width: 160px !important; margin: 4px !important; }
    .swal2-html-container label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
  </style>
</head>
<body>
  <h2>Beam Stiffness Solver — Full Version</h2>

  <div class="row">
    <label>Segments (max 10): <input id="numSegments" type="number" min="1" max="10" value="2"></label>
    <button class="primary" onclick="buildBeam()">Build Beam</button>
    <button onclick="solveBeam()">Solve</button>
    
    <button onclick="exportJSON()">Export JSON</button>
    
    <button onclick="exportCSV()">Export CSV</button>
    <label>EI scale: <input id="eiScale" type="number" step="0.01" value="1.00" style="width:70px"></label>
  </div>

  <div id="stage">
    <canvas id="beamCanvas" width="960" height="275"></canvas>
    <div id="charts">
      <canvas id="dispPlot" class="plot" width="960" height="260"></canvas>
      <canvas id="momentPlot" class="plot" width="960" height="260"></canvas>
      <canvas id="shearPlot" class="plot" width="960" height="260"></canvas>
      <canvas id="stressPlot" class="plot" width="960" height="260"></canvas>
    </div>
  </div>

  <script>
    // Canvas Sizing
    function syncCanvasSizes() {
      const ids = ['beamCanvas','dispPlot','momentPlot','shearPlot','stressPlot'];
      let changed = false;
      for (const id of ids) {
        const cv = document.getElementById(id);
        if (!cv) continue;
        const w = Math.round(cv.getBoundingClientRect().width);
        const h = Math.round(cv.getBoundingClientRect().height);
        if (w && h && (cv.width !== w || cv.height !== h)) {
          cv.width = w; cv.height = h; changed = true;
        }
      }
      if (changed) {
        try { drawBeam(); } catch(_) {}
        try { if (window.lastU) { plotDisplacement(lastU.u, lastU.map); plotMoment(); plotShearFromMoment(); plotBendingStress(); } } catch(_) {}
      }
    }
    window.addEventListener('load', syncCanvasSizes);
    window.addEventListener('resize', syncCanvasSizes);
  </script>

  <script>
    // -------------------- State --------------------
    let K_global = null, segments = [], nodes = [], elementForces = null, lastU = null, unitSystem = 'US';

    // -------------------- Helpers --------------------
    function isHinge(node){ return !!node.pinJoint; }
    function fmtSig3(n){
      if (n === 0) return '0';
      if (!isFinite(n)) return String(n);
      const abs = Math.abs(n);
      return (abs >= 1e-3 && abs < 1e4) 
        ? ((Number(n).toPrecision(3).includes('e')) ? Number(n).toString() : String(parseFloat(Number(n).toPrecision(3))))
        : Number(n).toExponential(2);
    }
    function normalizeSegments(){
      for (const seg of segments){
        if (seg.St === undefined) seg.St = 5.3;
        if (seg.Sb === undefined) seg.Sb = 5.3;
        if (seg.qL === undefined) seg.qL = 0;
        if (seg.qR === undefined) seg.qR = 0;
        if (seg.wd === undefined) seg.wd = 0;
        if (seg.A  === undefined) seg.A  = 0;
      }
    }
    function buildDOFMap(){
      const n = nodes.length; const idxW = new Array(n), thLeft = new Array(n), thRight = new Array(n); let dof=0;
      for (let i=0;i<n;i++) idxW[i] = dof++;
      for (let i=0;i<n;i++){
        const hinge = isHinge(nodes[i]);
        if (!hinge){ const r = dof++; thLeft[i] = r; thRight[i] = r; } 
        else { if (i>0) thLeft[i] = dof++; if (i<n-1) thRight[i] = dof++; }
      }
      return { idxW, thLeft, thRight, ndof: dof };
    }

    // -------------------- Editors --------------------
    function editNode(i) {
      const node = nodes[i];
      Swal.fire({
        title: `Node ${i} Properties`,
        html: `<label><span>BC:</span><select id="bc" class="swal2-select"><option value="free" ${node.bc==='free'?'selected':''}>Free</option><option value="pinned" ${node.bc==='pinned'?'selected':''}>Simple</option><option value="fixed" ${node.bc==='fixed'?'selected':''}>Fixed</option></select></label>
          <label><span>F (Pos=Down):</span><input id="F" class="swal2-input" value="${node.F}"></label>
          <label><span>M:</span><input id="M" class="swal2-input" value="${node.M}"></label>
          <label><span>Kv:</span><input id="Kv" class="swal2-input" value="${node.Kv}"></label>
          <label><span>Km:</span><input id="Km" class="swal2-input" value="${node.Km}"></label>
          <hr style='margin:6px 0;'><label><span>Pin Joint:</span><input type="checkbox" id="pinJoint" ${node.pinJoint?'checked':''}></label>
          <label><span>Set w:</span><input id="w0" class="swal2-input" value="${Number.isFinite(node.w0)? node.w0 : ''}"></label>
          <label><span>Set θ:</span><input id="th0" class="swal2-input" value="${Number.isFinite(node.th0)? node.th0 : ''}"></label>`,
        preConfirm: () => {
          const bcVal=document.getElementById('bc').value, Fv=parseFloat(document.getElementById('F').value), Mv=parseFloat(document.getElementById('M').value);
          const Kv=parseFloat(document.getElementById('Kv').value), Km=parseFloat(document.getElementById('Km').value), pin=document.getElementById('pinJoint').checked;
          const w0=document.getElementById('w0').value, th0=document.getElementById('th0').value;
          return [bcVal, Fv, Mv, Kv, Km, pin && !(bcVal==='fixed'||Km>0), w0===''?null:parseFloat(w0), th0===''?null:parseFloat(th0)];
        }
      }).then((res)=>{ if(res.value) { const d=res.value; nodes[i]={bc:d[0],F:d[1],M:d[2],Kv:d[3],Km:d[4],pinJoint:d[5],w0:d[6],th0:d[7]}; drawBeam(); }});
    }

    function editSegment(i) {
      const seg = segments[i];
      Swal.fire({
        title: `Segment ${i}`,
        html: `<div id="segForm"><label><span>E:</span><input id="E" class="swal2-input" value="${seg.E}"></label>
            <label><span>I:</span><input id="I" class="swal2-input" value="${seg.I}"></label>
            <label><span>A:</span><input id="A" class="swal2-input" value="${seg.A}"></label>
            <label><span>L:</span><input id="L" class="swal2-input" value="${seg.L}"></label>
            <label><span>St:</span><input id="St" class="swal2-input" value="${seg.St}"></label>
            <label><span>Sb:</span><input id="Sb" class="swal2-input" value="${seg.Sb}"></label>
            <label><span>qL (Pos=Down):</span><input id="qL" class="swal2-input" value="${seg.qL}"></label>
            <label><span>qR (Pos=Down):</span><input id="qR" class="swal2-input" value="${seg.qR}"></label>
            <label><span>wd:</span><input id="wd" class="swal2-input" value="${seg.wd}"></label>
            <div id="matRow" style="margin-top:6px;display:flex;gap:6px;"><span style="font-size:12px;color:#555">Mat:</span><button type="button" class="matBtn" data-mat="steel">Steel</button><button type="button" class="matBtn" data-mat="aluminum">Alum</button><button type="button" class="matBtn" data-mat="hardwood">Wood</button></div>
            <div style="margin-top:6px;"><button id="secCalcToggle" type="button" style="font-size:11px;">Calc Section...</button></div>
            <div id="secCalc" style="display:none;margin-top:8px;border-top:1px solid #ddd;"><div id="shapeGrid" style="display:flex;gap:4px;margin-top:4px;"><button type="button" class="shapeBtn" data-shape="rect">Rect</button><button type="button" class="shapeBtn" data-shape="circ">Circ</button><button type="button" class="shapeBtn" data-shape="tube">Tube</button><button type="button" class="shapeBtn" data-shape="ibeam">I-Beam</button></div><div id="secInputs" style="margin-top:6px;"></div></div></div>`,
        didOpen: (el)=>{ setupSectionCalc(el, i); setupMaterialPresets(el, i); },
        preConfirm: () => [parseFloat(document.getElementById('E').value), parseFloat(document.getElementById('I').value), parseFloat(document.getElementById('A').value), parseFloat(document.getElementById('L').value), parseFloat(document.getElementById('St').value), parseFloat(document.getElementById('Sb').value), parseFloat(document.getElementById('qL').value), parseFloat(document.getElementById('qR').value), parseFloat(document.getElementById('wd').value)]
      }).then((res)=>{ if(res.value) { const d=res.value; segments[i]={E:d[0],I:d[1],A:d[2],L:d[3],St:d[4],Sb:d[5],qL:d[6],qR:d[7],wd:d[8]}; drawBeam(); }});
    }

    function setupSectionCalc(el, segIndex){
        const toggle=el.querySelector('#secCalcToggle'), panel=el.querySelector('#secCalc'), inputs=el.querySelector('#secInputs');
        if(toggle) toggle.onclick=()=>panel.style.display=panel.style.display==='none'?'block':'none';
        el.querySelectorAll('.shapeBtn').forEach(b=>b.onclick=()=>{
            const s=b.dataset.shape;
            inputs.innerHTML = (s==='rect') ? `<label>b:<input id="sh_b" style="width:50px"></label><label>h:<input id="sh_h" style="width:50px"></label><button id="doSec">OK</button>` :
                               (s==='circ') ? `<label>OD:<input id="sh_od" style="width:50px"></label><label>ID:<input id="sh_id" value="0" style="width:50px"></label><button id="doSec">OK</button>` :
                               `<div style="font-size:11px;color:#888">Complete inputs...</div>`; 
            const ok=el.querySelector('#doSec');
            if(ok) ok.onclick=()=>{
                if(s==='rect'){
                    const b=parseFloat(el.querySelector('#sh_b').value), h=parseFloat(el.querySelector('#sh_h').value);
                    if(b>0 && h>0){
                       const I=b*h*h*h/12, A=b*h, S=I/(h/2);
                       const to3=v=>Number(v).toPrecision(3);
                       const t=segments[segIndex];
                       if(t) { t.I=parseFloat(to3(I)); t.A=parseFloat(to3(A)); t.St=parseFloat(to3(S)); t.Sb=parseFloat(to3(S)); drawBeam(); Swal.fire({icon:'success',title:'Updated',timer:800,showConfirmButton:false}); }
                    }
                }
            };
        });
    }
    function setupMaterialPresets(el, segIndex){
        const presets = { US:{steel:{E:29e6,wd:0.283}, aluminum:{E:10e6,wd:0.098}, hardwood:{E:1.6e6,wd:0.025}}, SI:{steel:{E:200e9,wd:77000}, aluminum:{E:69e9,wd:26500}, hardwood:{E:11e9,wd:7000}} };
        el.querySelectorAll('.matBtn').forEach(b=>{ b.onclick=()=>{
            const p = (presets[unitSystem]||presets.US)[b.dataset.mat];
            if(p){ document.getElementById('E').value=p.E; document.getElementById('wd').value=p.wd; }
        }});
    }

    // -------------------- Build & Draw --------------------
    function buildBeam() {
      const num = parseInt(document.getElementById("numSegments").value) || 2;
      if (segments.length !== num) {
        const seed = segments.length ? segments[0] : { E: 12e6, I: 21.3, L: 96, St: 5.3, Sb: 5.3, qL: 0, qR: 0, wd: 0, A: 0 };
        segments = Array(num).fill().map((_,i)=> i<segments.length ? segments[i] : {...seed});
        normalizeSegments();
        nodes = Array(num + 1).fill().map(() => ({ bc: 'free', F: 0, M: 0, Kv: 0, Km: 0, pinJoint: false, w0: null, th0: null }));
      }
      elementForces = null; K_global = null; lastU = null; drawBeam();
    }

    function drawBeam() {
      const cv = document.getElementById("beamCanvas"), ctx = cv.getContext("2d");
      ctx.clearRect(0, 0, cv.width, cv.height);
      if (!segments.length) return;

      const pad = 50, totalL = segments.reduce((s,o)=>s+o.L,0), scaleX = (cv.width - 2*pad)/totalL;
      const maxEI = Math.max(...segments.map(s=>s.E*s.I)), hMax = 0.4*cv.height*0.25;
      const eiScale = parseFloat(document.getElementById('eiScale').value)||1;
      const maxQ = Math.max(...segments.flatMap(s=>[Math.abs(s.qL),Math.abs(s.qR)]),0);
      const maxF = Math.max(...nodes.map(n=>Math.abs(n.F)),0);
      const maxW = Math.max(...segments.map(s=>Math.abs(s.wd*s.A)),0);
      const midY = Math.round(cv.height * 0.35);

      // Baseline
      ctx.strokeStyle = '#aaa'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(pad, midY); ctx.lineTo(cv.width-pad, midY); ctx.stroke();

      // Ticks
      const nTick = 10, pxTick = (cv.width - 2*pad)/nTick;
      ctx.fillStyle = '#666'; ctx.textAlign = 'center'; ctx.font = '11px sans-serif';
      const beamHalf = (hMax*eiScale)/2, tickY = midY + Math.max(beamHalf+26, 36);
      for(let i=0; i<=nTick; i++){
          const xx = pad + i*pxTick;
          ctx.beginPath(); ctx.moveTo(xx, midY-6); ctx.lineTo(xx, midY+6); ctx.strokeStyle='#ddd'; ctx.stroke();
          ctx.fillText((totalL*i/nTick).toFixed(0), xx, tickY);
      }

      let x = pad;
      for(let i=0; i<segments.length; i++){
          const seg = segments[i], w = seg.L*scaleX, h = (seg.E*seg.I/maxEI)*hMax*eiScale;
          
          // DARKER BEAM
          const wmag = Math.abs(seg.wd*seg.A), gray = Math.round(75 - (maxW>0 ? Math.min(1,wmag/maxW) : 0)*45);
          ctx.fillStyle = `hsl(0,0%,${gray}%)`;
          ctx.fillRect(x, midY-h/2, w, h);

          // LOADS ABOVE
          drawLoadBlanket(ctx, x, midY, w, h, seg.qL, seg.qR, maxQ);

          // TEXT BELOW (CLEAN)
          const txt = [`E:${fmtSig3(seg.E)}`, `I:${fmtSig3(seg.I)}`, `A:${fmtSig3(seg.A)}`, `L:${fmtSig3(seg.L)}`, `q:${fmtSig3(seg.qL)}/${fmtSig3(seg.qR)}`];
          ctx.fillStyle='#111'; ctx.font='11px sans-serif'; 
          const startTxt = Math.max(midY+h/2+14, tickY+14);
          txt.forEach((t,j)=> ctx.fillText(t, x+w/2, startTxt + j*12));

          drawNodeFeatures(ctx, x, midY, nodes[i], maxF);
          ctx.beginPath(); ctx.fillStyle='#06f'; ctx.arc(x, midY, 6, 0, 2*Math.PI); ctx.fill();
          x += w;
      }
      drawNodeFeatures(ctx, x, midY, nodes[segments.length], maxF);
      ctx.beginPath(); ctx.fillStyle='#06f'; ctx.arc(x, midY, 6, 0, 2*Math.PI); ctx.fill();
    }

    function drawLoadBlanket(ctx, x, midY, w, h, qL, qR, maxQ){
        if((!qL && !qR) || maxQ<=0) return;
        const nArr = Math.max(6, Math.floor(w/40)), step = w/(nArr+1);
        const yTop = midY - h/2 - 6; 
        const maxLen = 48;

        ctx.save(); ctx.strokeStyle = '#0a8'; ctx.lineWidth = 1.5; ctx.fillStyle = '#0a8';
        for(let k=1; k<=nArr; k++){
            const xi = x + k*step, r = (xi-x)/w;
            const qx = qL + (qR - qL)*r; 
            if(Math.abs(qx)<1e-6) continue;
            const len = Math.max(10, (maxLen * Math.abs(qx))/maxQ);
            const isPos = qx > 0;
            const yBase = yTop, ySky = yTop - len;
            ctx.beginPath();
            if(isPos){
                ctx.moveTo(xi, ySky); ctx.lineTo(xi, yBase); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(xi-4, yBase-6); ctx.lineTo(xi, yBase); ctx.lineTo(xi+4, yBase-6); ctx.stroke();
            } else {
                ctx.moveTo(xi, yBase); ctx.lineTo(xi, ySky); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(xi-4, ySky+6); ctx.lineTo(xi, ySky); ctx.lineTo(xi+4, ySky+6); ctx.stroke();
            }
        }
        ctx.restore();
    }

    function drawNodeFeatures(ctx, x, y, node, maxF){
        ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
        if(node.bc==='pinned'){ ctx.beginPath(); ctx.moveTo(x-16, y+18); ctx.lineTo(x, y); ctx.lineTo(x+16, y+18); ctx.stroke(); }
        else if(node.bc==='fixed'){ ctx.beginPath(); ctx.moveTo(x-6,y-24); ctx.lineTo(x-6,y+24); ctx.stroke(); for(let yy=y-24;yy<=y+24;yy+=8){ctx.beginPath();ctx.moveTo(x-6,yy);ctx.lineTo(x-18,yy+8);ctx.stroke();} }
        if(node.pinJoint){ ctx.beginPath(); ctx.arc(x,y,9,0,2*Math.PI); ctx.stroke(); }
        if(node.Kv){ let sy=y+10; ctx.beginPath(); ctx.moveTo(x,sy); for(let i=0;i<5;i++){ ctx.lineTo(x+(i%2?6:-6), sy+6); sy+=6;} ctx.stroke(); }
        if(node.Km){ ctx.beginPath(); ctx.arc(x-24,y,10,0,2*Math.PI); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-14,y); ctx.lineTo(x-6,y); ctx.stroke(); }

        if(Math.abs(node.M)>1e-9){
            const pos = node.M>0, r=22;
            ctx.beginPath(); ctx.arc(x,y,r, pos?-Math.PI/2:Math.PI/2, pos?Math.PI/2:-Math.PI/2); ctx.stroke();
            const tx = x + r*Math.cos(pos?Math.PI/2:-Math.PI/2), ty = y + r*Math.sin(pos?Math.PI/2:-Math.PI/2);
            ctx.beginPath(); ctx.moveTo(tx,ty); ctx.lineTo(tx-10,ty); 
            ctx.moveTo(tx,ty); ctx.lineTo(tx+12*Math.cos(Math.PI+Math.PI/6), ty+12*Math.sin(Math.PI+Math.PI/6));
            ctx.moveTo(tx,ty); ctx.lineTo(tx+12*Math.cos(Math.PI-Math.PI/6), ty+12*Math.sin(Math.PI-Math.PI/6));
            ctx.stroke();
        }

        if(Math.abs(node.F)>1e-9){
            const pos = node.F > 0, baseLen = 16, extra = 34;
            const len = maxF ? baseLen + extra*(Math.abs(node.F)/maxF) : baseLen+20;
            const yNode = y, ySky  = y - len;
            ctx.beginPath();
            if(pos){
                ctx.moveTo(x, ySky); ctx.lineTo(x, yNode); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x-6, yNode-8); ctx.lineTo(x, yNode); ctx.lineTo(x+6, yNode-8); ctx.fill();
            } else {
                ctx.moveTo(x, yNode); ctx.lineTo(x, ySky); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x-6, ySky+8); ctx.lineTo(x, ySky); ctx.lineTo(x+6, ySky+8); ctx.fill();
            }
        }
    }

    // --- HIT TEST LOGIC (FIXED) ---
    const beamCanvas = document.getElementById('beamCanvas');
    beamCanvas.addEventListener('click', (e) => {
      if (segments.length === 0) return;
      const rect = beamCanvas.getBoundingClientRect();
      const scaleMapX = beamCanvas.width / rect.width;
      const scaleMapY = beamCanvas.height / rect.height;
      const xClick = (e.clientX - rect.left) * scaleMapX;
      const yClick = (e.clientY - rect.top) * scaleMapY;

      const margin = 50; 
      const midY = Math.round(beamCanvas.height * 0.35);
      const totalLength = segments.reduce((sum, seg) => sum + seg.L, 0);
      const scaleX = (beamCanvas.width - 2 * margin) / totalLength;

      const maxEI = Math.max(...segments.map(seg => seg.E * seg.I));
      const maxHeight = 0.40 * beamCanvas.height * 0.25;
      const eiScale = parseFloat(document.getElementById('eiScale').value || '1');

      // Nodes
      const nodeXs = [margin];
      let accX = margin;
      for (let i = 0; i < segments.length; i++) { accX += segments[i].L * scaleX; nodeXs.push(accX); }
      for (let i = 0; i < nodes.length; i++) {
        if (Math.hypot(xClick - nodeXs[i], yClick - midY) < 20) { editNode(i); return; }
      }

      // Segments
      accX = margin;
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i], w = seg.L * scaleX;
        const h = ((seg.E * seg.I) / maxEI) * maxHeight * eiScale;
        const hitLimit = Math.max(20, h / 2 + 10);
        if (xClick >= accX && xClick <= accX + w && Math.abs(yClick - midY) <= hitLimit) { editSegment(i); return; }
        accX += w;
      }
    });

    // -------------------- Solver --------------------
    function solveBeam(){
      if(nodes.length<2){ Swal.fire('Err','Build beam first','error'); return; }
      const map = buildDOFMap(), dof=map.ndof, K=Array(dof).fill().map(()=>Array(dof).fill(0)), F=Array(dof).fill(0);
      
      for(let e=0; e<segments.length; e++){
          const s=segments[e], L=s.L, EI=s.E*s.I, k = [ [12,6*L,-12,6*L], [6*L,4*L*L,-6*L,2*L*L], [-12,-6*L,12,-6*L], [6*L,2*L*L,-6*L,4*L*L] ].map(r=>r.map(v=> v*EI/(L*L*L)));
          const idx = [map.idxW[e], map.thRight[e], map.idxW[e+1], map.thLeft[e+1]];
          for(let r=0;r<4;r++) for(let c=0;c<4;c++) K[idx[r]][idx[c]] += k[r][c];
          
          const qw = -s.wd*s.A, qL=s.qL+qw, qR=s.qR+qw;
          const gauss = [{t:-0.7746,w:0.5556},{t:0,w:0.8889},{t:0.7746,w:0.5556}];
          const fe=[0,0,0,0];
          for(const g of gauss){
              const xLoc=(g.t+1)*L/2, N=[1-3*(xLoc/L)**2+2*(xLoc/L)**3, xLoc*(1-2*(xLoc/L)+(xLoc/L)**2), 3*(xLoc/L)**2-2*(xLoc/L)**3, xLoc*((xLoc/L)**2-(xLoc/L))];
              const qx = qL + (qR-qL)*(xLoc/L);
              for(let z=0;z<4;z++) fe[z] += g.w * (L/2) * N[z] * qx;
          }
          for(let z=0;z<4;z++) if(idx[z]!==undefined) F[idx[z]] += fe[z];
      }

      for(let i=0; i<nodes.length; i++){
          const n=nodes[i], wIdx=map.idxW[i];
          F[wIdx] += n.F; 
          if(n.Kv) K[wIdx][wIdx]+=n.Kv;
          if(n.Km && !isHinge(n)){ const t=map.thRight[i]; if(t!==undefined) K[t][t]+=n.Km; }
          if(n.M){
               if(!isHinge(n)) F[map.thRight[i]] += n.M;
               else { if(map.thLeft[i]) F[map.thLeft[i]]+=n.M/2; if(map.thRight[i]) F[map.thRight[i]]+=n.M/2; }
          }
      }

      const fixIdx=[], fixVal=[];
      for(let i=0; i<nodes.length; i++){
          const n=nodes[i], w=map.idxW[i], tL=map.thLeft[i], tR=map.thRight[i];
          if(n.bc==='fixed'){ fixIdx.push(w); fixVal.push(0); if(tL) {fixIdx.push(tL);fixVal.push(0);} if(tR&&tR!==tL) {fixIdx.push(tR);fixVal.push(0);} }
          if(n.bc==='pinned'){ fixIdx.push(w); fixVal.push(0); }
          if(n.w0!==null){ fixIdx.push(w); fixVal.push(n.w0); }
          if(n.th0!==null){ if(tL){fixIdx.push(tL);fixVal.push(n.th0);} if(tR&&tR!==tL){fixIdx.push(tR);fixVal.push(n.th0);} }
      }
      
      const freeIdx = [...Array(dof).keys()].filter(k=> !fixIdx.includes(k));
      if(!freeIdx.length){ Swal.fire('Error','Fully constrained','error'); return; }
      
      const Kff = freeIdx.map(r=> freeIdx.map(c=> K[r][c]));
      const Kfs = freeIdx.map(r=> fixIdx.map(c=> K[r][c]));
      const Ff  = freeIdx.map(r=> F[r]);
      const Rs  = numeric.sub(Ff, numeric.dot(Kfs, fixVal));
      
      try {
          const Uf = numeric.solve(Kff, Rs);
          const U = Array(dof).fill(0);
          freeIdx.forEach((idx,i)=> U[idx]=Uf[i]);
          fixIdx.forEach((idx,i)=> U[idx]=fixVal[i]);
          lastU = {u:U, map}; K_global=K;
          elementForces = computeForces(U, map);
          drawBeam();
          plotDisplacement(U, map); plotMoment(); plotShearFromMoment(); plotBendingStress();
      } catch(e) { Swal.fire('Error','Singular Matrix (Unstable)','error'); }
    }

    function computeForces(U, map){
        return segments.map((s,e)=>{
            const L=s.L, EI=s.E*s.I, k = [ [12,6*L,-12,6*L], [6*L,4*L*L,-6*L,2*L*L], [-12,-6*L,12,-6*L], [6*L,2*L*L,-6*L,4*L*L] ].map(r=>r.map(v=> v*EI/(L*L*L)));
            const idx = [map.idxW[e], map.thRight[e], map.idxW[e+1], map.thLeft[e+1]];
            const u = idx.map(i=>U[i]);
            const fe = numeric.dot(k, u);
            const qw=-s.wd*s.A, qL=s.qL+qw, qR=s.qR+qw, feq=[0,0,0,0];
            const gauss = [{t:-0.7746,w:0.5556},{t:0,w:0.8889},{t:0.7746,w:0.5556}];
            for(const g of gauss){
                const xLoc=(g.t+1)*L/2, N=[1-3*(xLoc/L)**2+2*(xLoc/L)**3, xLoc*(1-2*(xLoc/L)+(xLoc/L)**2), 3*(xLoc/L)**2-2*(xLoc/L)**3, xLoc*((xLoc/L)**2-(xLoc/L))];
                const qx = qL + (qR-qL)*(xLoc/L);
                for(let z=0;z<4;z++) feq[z] += g.w*(L/2)*N[z]*qx;
            }
            const f = numeric.sub(fe, feq);
            return {V1:-f[0], M1:-f[1], V2:-f[2], M2:-f[3], L};
        });
    }

    // -------------------- Plotting --------------------
    function plotDisplacement(U, map){
        const pts=[]; let x=0;
        segments.forEach((s,e)=>{
            const L=s.L, u=[U[map.idxW[e]], U[map.thRight[e]], U[map.idxW[e+1]], U[map.thLeft[e+1]]];
            for(let i=0;i<=20;i++){
                const xi=i*L/20, r=xi/L, h=[1-3*r*r+2*r*r*r, xi*(1-2*r+r*r), 3*r*r-2*r*r*r, xi*(r*r-r)];
                pts.push({x:x+xi, y: h.reduce((a,b,k)=>a+b*u[k],0)});
            }
            x+=L;
        });
        chart('dispPlot', 'Deflection', pts, 'y');
    }
    function plotMoment(){
        const pts=[]; let x=0;
        elementForces.forEach((f,i)=>{
             const s=segments[i], qw=-s.wd*s.A, qL=s.qL+qw, qR=s.qR+qw;
             for(let k=0;k<=40;k++){
                 const xi=k*f.L/40, M = -f.M2 + f.V1*(f.L-xi) - 0.5*qL*(f.L**2-xi**2) - ((qR-qL)/(6*f.L))*(f.L**3-xi**3);
                 pts.push({x:x+xi, y:M});
             }
             x+=f.L;
        });
        chart('momentPlot', 'Moment', pts, 'Moment');
    }
    function plotShearFromMoment(){
        const pts=[]; let x=0;
        elementForces.forEach((f,i)=>{
             const s=segments[i], qw=-s.wd*s.A, qL=s.qL+qw, qR=s.qR+qw;
             for(let k=0;k<=20;k++){
                 const xi=k*f.L/20, V = f.V1 - (qL*xi + (qR-qL)*xi*xi/(2*f.L));
                 pts.push({x:x+xi, y:V});
             }
             x+=f.L;
        });
        chart('shearPlot', 'Shear', pts, 'Shear');
    }
    function plotBendingStress(){
        const ptT=[], ptB=[]; let x=0;
        elementForces.forEach((f,i)=>{
             const s=segments[i], qw=-s.wd*s.A, qL=s.qL+qw, qR=s.qR+qw;
             if(!s.St && !s.Sb) { x+=f.L; return; }
             for(let k=0;k<=40;k++){
                 const xi=k*f.L/40, M = -f.M2 + f.V1*(f.L-xi) - 0.5*qL*(f.L**2-xi**2) - ((qR-qL)/(6*f.L))*(f.L**3-xi**3);
                 if(s.St) ptT.push({x:x+xi, y: -M/s.St});
                 if(s.Sb) ptB.push({x:x+xi, y: M/s.Sb});
             }
             x+=f.L;
        });
        if(window.stressChart) window.stressChart.destroy();
        const ctx = document.getElementById('stressPlot').getContext('2d');
        window.stressChart = new Chart(ctx, { type:'line', data:{datasets:[
            {label:'Top', data:ptT, borderColor:'red', borderWidth:1, pointRadius:0},
            {label:'Bot', data:ptB, borderColor:'blue', borderWidth:1, pointRadius:0}
        ]}, options:{responsive:false, scales:{x:{type:'linear'},y:{title:{display:true,text:'Stress (Tens +)'}}}}});
    }

    function chart(id, label, data, yTitle){
        const ctx = document.getElementById(id).getContext('2d');
        if(id==='dispPlot' && window.dCh) window.dCh.destroy();
        if(id==='momentPlot' && window.mCh) window.mCh.destroy();
        if(id==='shearPlot' && window.sCh) window.sCh.destroy();
        const cfg = { type:'line', data:{datasets:[{label, data, borderColor:'#333', borderWidth:2, pointRadius:0}]}, options:{responsive:false, scales:{x:{type:'linear'}, y:{title:{display:true,text:yTitle}}}} };
        const c = new Chart(ctx, cfg);
        if(id==='dispPlot') window.dCh=c; if(id==='momentPlot') window.mCh=c; if(id==='shearPlot') window.sCh=c;
    }

    // -------------------- EXPORT JSON --------------------
    function exportJSON(){
        if(!elementForces){ Swal.fire('Note','Solve first','info'); return; }
        
        const results = [];
        let xTot = 0;
        const { u, map } = lastU;

        segments.forEach((s, e) => {
            const L = s.L;
            const qw = -s.wd*s.A, qL = s.qL+qw, qR = s.qR+qw;
            const uVals = [u[map.idxW[e]], u[map.thRight[e]], u[map.idxW[e+1]], u[map.thLeft[e+1]]];
            const f = elementForces[e];
            
            // 20 points per segment
            for(let i=0; i<=20; i++){
                const xi = i*L/20;
                const r = xi/L;
                
                // Displacement
                const h = [1-3*r*r+2*r*r*r, xi*(1-2*r+r*r), 3*r*r-2*r*r*r, xi*(r*r-r)];
                const w = h.reduce((acc, val, k) => acc + val*uVals[k], 0);
                
                // Shear
                const V = f.V1 - (qL*xi + (qR-qL)*xi*xi/(2*L));
                
                // Moment
                const M = -f.M2 + f.V1*(L-xi) - 0.5*qL*(L**2-xi**2) - ((qR-qL)/(6*L))*(L**3-xi**3);
                
                // Stress
                const sigT = s.St ? -M/s.St : null;
                const sigB = s.Sb ? M/s.Sb : null;

                results.push({
                    x: parseFloat((xTot + xi).toFixed(4)),
                    displacement: parseFloat(w.toPrecision(5)),
                    shear: parseFloat(V.toPrecision(5)),
                    moment: parseFloat(M.toPrecision(5)),
                    sigma_top: sigT !== null ? parseFloat(sigT.toPrecision(5)) : null,
                    sigma_bottom: sigB !== null ? parseFloat(sigB.toPrecision(5)) : null
                });
            }
            xTot += L;
        });

        const dataObj = {
            version: "1.0",
            date: new Date().toLocaleDateString(),
            time: new Date().toLocaleTimeString(),
            results: results
        };

        const blob = new Blob([JSON.stringify(dataObj, null, 2)], {type: 'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `beam_results_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function exportCSV(){
        if(!elementForces) return;
        const rows = [['x','w','V','M','SigTop','SigBot']];
        let x=0;
        segments.forEach((s,e)=>{
             const L=s.L, qw=-s.wd*s.A, qL=s.qL+qw, qR=s.qR+qw;
             const u = [lastU.u[lastU.map.idxW[e]], lastU.u[lastU.map.thRight[e]], lastU.u[lastU.map.idxW[e+1]], lastU.u[lastU.map.thLeft[e+1]]];
             const f = elementForces[e];
             for(let i=0; i<=20; i++){
                 const xi=i*L/20, r=xi/L;
                 const h=[1-3*r*r+2*r*r*r, xi*(1-2*r+r*r), 3*r*r-2*r*r*r, xi*(r*r-r)];
                 const w = h.reduce((a,b,k)=>a+b*u[k],0);
                 const V = f.V1 - (qL*xi + (qR-qL)*xi*xi/(2*L));
                 const M = -f.M2 + f.V1*(L-xi) - 0.5*qL*(L**2-xi**2) - ((qR-qL)/(6*L))*(L**3-xi**3);
                 rows.push([(x+xi).toFixed(4), w, V, M, s.St?-M/s.St:0, s.Sb?M/s.Sb:0]);
             }
             x+=L;
        });
        const blob = new Blob([rows.map(r=>r.join(',')).join('\n')], {type:'text/csv'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='beam.csv'; a.click();
    }

    // Expose API
    window.buildBeam = buildBeam;
    window.solveBeam = solveBeam;
    window.exportCSV = exportCSV;
    window.exportJSON = exportJSON;

    buildBeam();
  </script>
</body>
</html>
