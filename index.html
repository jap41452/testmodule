<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Frame Analysis (2D) — Complete</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>

<style>
  :root { --pad:14px; --panel-w:680px; --bg:#f4f6f8; --primary:#2563eb; --text:#1f2937; }
  body { background:var(--bg); font-family:system-ui,-apple-system,sans-serif; margin:20px; color:var(--text); }
  h2 { margin:0 0 12px; font-weight:700; color:#111; display:flex; justify-content:space-between; align-items:center; }
  
  /* Layout Grid */
  .row { display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
  .col { background:#fff; border:1px solid #d1d5db; border-radius:8px; padding:var(--pad); box-shadow:0 1px 3px rgba(0,0,0,0.05); }
  .col.canvas-col { flex: 1; min-width: 600px; }
  .col.panel-col { width: var(--panel-w); display:flex; flex-direction:column; gap:12px; }

  /* Toolbar */
  .controls { display:flex; flex-wrap:wrap; gap:8px; align-items:center; margin-bottom:12px; }
  
  /* Buttons & Inputs */
  button, select, input { height:32px; padding:0 12px; border:1px solid #9ca3af; border-radius:6px; background:#fff; font-size:13px; color:#111; box-sizing:border-box; }
  button { cursor:pointer; font-weight:600; display:inline-flex; align-items:center; justify-content:center; }
  button:hover { background:#f3f4f6; }
  button:active { background:#e5e7eb; }
  
  button.primary { background:var(--primary); color:#fff; border-color:var(--primary); }
  button.primary:hover { background:#1d4ed8; }
  
  button.ghost { background:#f9fafb; color:#374151; }
  
  /* Canvas Wrapper */
  #wrap { position:relative; width:100%; height:600px; background:#fff; border:1px solid #ccc; border-radius:6px; overflow:hidden; }
  canvas { position:absolute; inset:0; }
  #base { z-index:1; } #overlay { z-index:2; pointer-events:auto; cursor:crosshair; }

  /* Lists */
  .list-header { font-weight:700; font-size:13px; margin-bottom:6px; display:flex; justify-content:space-between; }
  .list-scroll { max-height:250px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:6px; background:#f9fafb; }
  .list-item { padding:6px 10px; border-bottom:1px solid #eee; font-size:12px; display:flex; justify-content:space-between; align-items:center; }
  .list-item:last-child { border-bottom:none; }
  .list-item:hover { background:#f0f9ff; cursor:pointer; }
  .del-btn { color:#ef4444; font-weight:bold; padding:2px 6px; border:1px solid #fecaca; border-radius:4px; background:#fff; margin-left:8px; }
  .del-btn:hover { background:#fee2e2; }

  /* Stress Panel */
  #stressPanelBlock { display:none; border:1px solid #d1d5db; border-radius:6px; padding:10px; background:#fff; margin-top:10px; }
  #stressPanel { width:100%; height:220px; display:block; border:1px solid #eee; margin-top:6px; background:#fafafa; }
  
  /* Helpers */
  .hint { color:#6b7280; font-size:11px; margin-left:8px; font-weight:400; }
  .label-text { font-size:12px; font-weight:600; color:#4b5563; margin-right:4px; }
  .sep { width:1px; height:24px; background:#d1d5db; margin:0 4px; }
</style>
</head>
<body>

<h2>
  <span>FRAME ANALYSIS <span style="font-weight:400; font-size:14px; color:#666;">(2D Static & Modal)</span></span>
</h2>

<div class="controls">
  <button id="btnDraw" class="primary">Draw Members</button>
  <button id="btnSelect" class="ghost">Select / Edit</button>
  <div class="sep"></div>
  <button id="btnUndo" class="ghost">Undo</button>
  <button id="btnClear" class="ghost">Clear</button>
  <div class="sep"></div>
  
  <button id="btnExportJSON" class="ghost">Export JSON</button>
  <button id="btnImportJSON" class="ghost">Import JSON</button>
  <button id="btnExportCSV" class="ghost" style="border-color:#059669; color:#059669;">Export CSV (Run & Data)</button>
  <button id="btnImportCSV" class="ghost" style="border-color:#059669; color:#059669;">Import CSV</button>
  
  <input id="fileInput" type="file" style="display:none;" />
</div>

<div class="row">
  
  <div class="col canvas-col">
    <div id="wrap">
      <canvas id="base" width="800" height="600"></canvas>
      <canvas id="overlay" width="800" height="600"></canvas>
    </div>
    
    <div class="controls" style="margin-top:12px; background:#f8fafc; padding:10px; border-radius:6px; border:1px solid #e2e8f0;">
      <span class="label-text">Analysis:</span>
      <button id="btnSolve" class="primary">Solve Static</button>
      <button id="btnModes" class="ghost">Solve Modes</button>
      <div class="sep"></div>
      
      <span class="label-text">View:</span>
      <button id="viewDef" class="ghost">Deflection</button>
      <button id="viewStress" class="ghost">Diagrams</button>
      <div class="sep"></div>

      <span class="label-text">Scale:</span>
      <input id="defScale" type="number" step="any" value="1" style="width:60px;">
      
      <span class="label-text" style="margin-left:8px;">Mode:</span>
      <select id="modeSelect" style="width:80px;"><option value="0">Static</option></select>
      
      <button id="btnAnimate" class="ghost" style="min-width:40px;">▶</button>
    </div>
  </div>

  <div class="col panel-col">
    
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
      <div class="list-header">System Units</div>
      <div>
        <button id="btnUS" class="ghost active" style="height:24px; font-size:11px;">US (kips, in)</button>
        <button id="btnSI" class="ghost" style="height:24px; font-size:11px;">SI (kN, m)</button>
      </div>
    </div>

    <div>
      <div class="list-header">Nodes <span class="hint">Double-click canvas node to edit</span></div>
      <div id="nodeList" class="list-scroll"></div>
    </div>

    <div>
      <div class="list-header">Members <span class="hint">Double-click canvas member to edit</span></div>
      <div id="memberList" class="list-scroll"></div>
    </div>

    <div>
      <div class="list-header">Nodal Results <span id="resHint" class="hint">Run solve to view</span></div>
      <div id="resultList" class="list-scroll" style="max-height:150px;"></div>
    </div>

    <div id="stressPanelBlock">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
        <div class="list-header" style="margin:0;">Member Diagrams</div>
        <select id="stressPlotMode" style="height:24px; font-size:11px;">
          <option value="M">Moment (M)</option>
          <option value="V">Shear (V)</option>
          <option value="N">Axial (N)</option>
          <option value="sigma">Stress (σ)</option>
        </select>
        <button id="closeStress" class="ghost" style="height:24px; padding:0 8px;">x</button>
      </div>
      <canvas id="stressPanel"></canvas>
      <div class="hint">Click a member in the viewport to plot results here.</div>
    </div>

  </div>
</div>

<script>
(() => {
  // --- GLOBALS ---
  const base = document.getElementById('base');
  const overlay = document.getElementById('overlay');
  const stressCanvas = document.getElementById('stressPanel');
  const ctx = base.getContext('2d');
  const ovr = overlay.getContext('2d');
  const spx = stressCanvas.getContext('2d');
  
  // Model Data
  let nodes = [];      // {id, x, y, bc, Fx, Fy, Mz, ...}
  let members = [];    // {id, n1, n2, E, A, I, ...}
  let nextNodeId = 1, nextMemberId = 1;
  let units = 'US';

  // Interaction
  let mode = 'draw';   // draw, select
  let viewMode = 'geom'; // geom, def, stress
  let dragStart = null, hoverNode = null, hoverMember = null;
  let selectedNode = null, selectedMember = null;
  let view = { scale:1, dx:0, dy:0, dirty:true };
  let isPanning = false, panStart = {x:0, y:0};

  // Analysis Results
  let lastSolution = null; 
  let modalData = { modes:[], dofMap:null };
  let currentMode = 0; // 0=Static
  let anim = { active:false, raf:null, t0:0, val:0 };

  // --- INITIALIZATION ---
  function init(){
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    bindEvents();
    refreshLists();
    requestAnimationFrame(renderLoop);
  }

  function resizeCanvas(){
    const rect = base.parentElement.getBoundingClientRect();
    base.width = rect.width; base.height = rect.height;
    overlay.width = rect.width; overlay.height = rect.height;
    stressCanvas.width = document.getElementById('stressPanelBlock').clientWidth - 22;
    view.dirty = true;
  }

  // --- MODEL FUNCTIONS ---
  function addNode(x, y){
    const id = nextNodeId++;
    nodes.push({ id, x, y, bc:'free', Fx:0, Fy:0, Mz:0, Kx:0, Ky:0, Kt:0 });
    refreshLists();
    view.dirty = true;
    return id;
  }

  function addMember(n1, n2){
    if(n1 === n2) return;
    // Check duplicate
    if(members.some(m => (m.n1===n1 && m.n2===n2) || (m.n1===n2 && m.n2===n1))) return;
    
    const id = nextMemberId++;
    members.push({
      id, n1, n2, label:`M${id}`,
      E:29000, A:10, I:200, S:40, c:5, wd:0 // Default Steel
    });
    refreshLists();
    view.dirty = true;
    return id;
  }

  function getNode(id) { return nodes.find(n => n.id === id); }
  function getMember(id) { return members.find(m => m.id === id); }

  function deleteEntity(type, id){
    if(type === 'node'){
      nodes = nodes.filter(n => n.id !== id);
      members = members.filter(m => m.n1 !== id && m.n2 !== id);
    } else {
      members = members.filter(m => m.id !== id);
    }
    clearResults();
    refreshLists();
    view.dirty = true;
  }

  function clearResults(){
    lastSolution = null;
    modalData = { modes:[], dofMap:null };
    currentMode = 0;
    document.getElementById('modeSelect').innerHTML = '<option value="0">Static</option>';
    document.getElementById('resultList').innerHTML = '';
    anim.val = 0;
  }

  // --- DRAWING ---
  function renderLoop(){
    if(anim.active) updateAnimation();
    if(view.dirty || anim.active){
      drawBase();
      view.dirty = false;
    }
    // Overlay is drawn every frame for interaction
    drawOverlay();
    requestAnimationFrame(renderLoop);
  }

  function worldToScreen(x, y){
    return { 
      x: base.width/2 + view.dx + x*view.scale, 
      y: base.height/2 + view.dy - y*view.scale // Flip Y
    };
  }
  function screenToWorld(sx, sy){
    return {
      x: (sx - base.width/2 - view.dx)/view.scale,
      y: -(sy - base.height/2 - view.dy)/view.scale
    };
  }

  function autoFit(){
    if(nodes.length === 0) return;
    let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
    nodes.forEach(n => {
      minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
      minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
    });
    const w = Math.max(maxX - minX, 10);
    const h = Math.max(maxY - minY, 10);
    const padding = 60;
    const scX = (base.width - padding*2) / w;
    const scY = (base.height - padding*2) / h;
    view.scale = Math.min(scX, scY);
    view.dx = -(minX + w/2) * view.scale;
    view.dy = (minY + h/2) * view.scale; // Y flip adjustment handled in worldToScreen
    view.dirty = true;
  }

  function drawBase(){
    ctx.clearRect(0,0, base.width, base.height);
    
    // Grid
    ctx.strokeStyle = '#f1f5f9';
    ctx.lineWidth = 1;
    ctx.beginPath();
    // Simple grid logic could go here
    ctx.stroke();

    // Members
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#374151';
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#374151';
    
    members.forEach(m => {
      const n1 = getNode(m.n1);
      const n2 = getNode(m.n2);
      if(!n1 || !n2) return;
      const p1 = worldToScreen(n1.x, n1.y);
      const p2 = worldToScreen(n2.x, n2.y);
      
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      
      const midX = (p1.x+p2.x)/2; 
      const midY = (p1.y+p2.y)/2;
      ctx.fillText(m.label, midX, midY);
    });

    // Nodes
    nodes.forEach(n => {
      const p = worldToScreen(n.x, n.y);
      
      // Supports
      if(n.bc !== 'free'){
        ctx.fillStyle = '#000';
        ctx.fillRect(p.x-6, p.y+4, 12, 4); // Simple ground representation
      }

      // Loads
      if(n.Fx !== 0 || n.Fy !== 0){
        ctx.strokeStyle = '#ec4899';
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + n.Fx*0.5, p.y - n.Fy*0.5); // Simple load vector viz
        ctx.stroke();
      }

      // Dot - BLUE as requested
      ctx.fillStyle = '#2563eb'; 
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, 2*Math.PI);
      ctx.fill();
    });

    // Deformed Shape
    if(viewMode === 'def' && (lastSolution || currentMode > 0)){
      drawDeformed(ctx);
    }
  }

  function drawOverlay(){
    ovr.clearRect(0,0, overlay.width, overlay.height);
    
    // Drag Line
    if(dragStart && mode === 'draw'){
      const p1 = worldToScreen(dragStart.x, dragStart.y);
      // Mouse pos logic needed here, see events
    }

    // Highlights
    if(selectedNode){
      const n = getNode(selectedNode);
      const p = worldToScreen(n.x, n.y);
      ovr.strokeStyle = '#ef4444';
      ovr.lineWidth = 2;
      ovr.beginPath(); ovr.arc(p.x, p.y, 8, 0, 2*Math.PI); ovr.stroke();
    }
    if(selectedMember){
      const m = getMember(selectedMember);
      const n1 = getNode(m.n1);
      const n2 = getNode(m.n2);
      const p1 = worldToScreen(n1.x, n1.y);
      const p2 = worldToScreen(n2.x, n2.y);
      ovr.strokeStyle = 'rgba(239, 68, 68, 0.5)';
      ovr.lineWidth = 6;
      ovr.beginPath(); ovr.moveTo(p1.x, p1.y); ovr.lineTo(p2.x, p2.y); ovr.stroke();
    }
  }

  function drawDeformed(c){
    // Determine displacements
    let U = [];
    if(currentMode > 0 && modalData.modes.length >= currentMode){
      U = modalData.modes[currentMode-1].U;
    } else if (lastSolution){
      U = lastSolution.U;
    } else return;

    const scaleBase = parseFloat(document.getElementById('defScale').value) || 1;
    const scale = scaleBase * (1 + anim.val); // Animation factor
    
    c.strokeStyle = '#dc2626';
    c.lineWidth = 2;
    c.beginPath();

    const dofMap = lastSolution ? lastSolution.dofMap : modalData.dofMap;

    members.forEach(m => {
      const n1 = getNode(m.n1), n2 = getNode(m.n2);
      const i = dofMap[n1.id], j = dofMap[n2.id];
      const u1 = U[i], v1 = U[i+1], th1 = U[i+2];
      const u2 = U[j], v2 = U[j+1], th2 = U[j+2];

      const dx = n2.x - n1.x, dy = n2.y - n1.y;
      const L = Math.hypot(dx, dy);
      const cos = dx/L, sin = dy/L;

      // Transform global disp to local
      const ul1 =  u1*cos + v1*sin;
      const vl1 = -u1*sin + v1*cos;
      const ul2 =  u2*cos + v2*sin;
      const vl2 = -u2*sin + v2*cos;

      // Draw curve segments
      const segs = 10;
      for(let k=0; k<=segs; k++){
        const t = k/segs;
        const x = t*L;

        // Cubic Hermite Shape Functions
        const h1 = 1 - 3*t*t + 2*t*t*t;
        const h2 = x * (1 - 2*t + t*t);
        const h3 = 3*t*t - 2*t*t*t;
        const h4 = x * (t*t - t);

        const v_loc = h1*vl1 + h2*th1 + h3*vl2 + h4*th2;
        const u_loc = ul1*(1-t) + ul2*t;

        // Transform back to global for plotting
        const u_glob = u_loc*cos - v_loc*sin;
        const v_glob = u_loc*sin + v_loc*cos;

        const p = worldToScreen(n1.x + x*cos + u_glob*scale, n1.y + x*sin + v_glob*scale);
        if(k===0) c.moveTo(p.x, p.y); else c.lineTo(p.x, p.y);
      }
    });
    c.stroke();
  }

  // --- ANALYSIS ENGINE ---
  function solve(){
    try {
      // 1. Build Matrices
      const dofCount = nodes.length * 3;
      const K = new Array(dofCount).fill(0).map(()=>new Array(dofCount).fill(0));
      const F = new Array(dofCount).fill(0);
      const dofMap = {};
      nodes.forEach((n, i) => dofMap[n.id] = i*3);

      members.forEach(m => {
        const n1 = getNode(m.n1), n2 = getNode(m.n2);
        const L = Math.hypot(n2.x-n1.x, n2.y-n1.y);
        const ang = Math.atan2(n2.y-n1.y, n2.x-n1.x);
        const c = Math.cos(ang), s = Math.sin(ang);

        // Local K (Bernoulli Beam)
        const E=m.E, A=m.A, I=m.I;
        const k = [
          [E*A/L, 0, 0, -E*A/L, 0, 0],
          [0, 12*E*I/L**3, 6*E*I/L**2, 0, -12*E*I/L**3, 6*E*I/L**2],
          [0, 6*E*I/L**2, 4*E*I/L, 0, -6*E*I/L**2, 2*E*I/L],
          [-E*A/L, 0, 0, E*A/L, 0, 0],
          [0, -12*E*I/L**3, -6*E*I/L**2, 0, 12*E*I/L**3, -6*E*I/L**2],
          [0, 6*E*I/L**2, 2*E*I/L, 0, -6*E*I/L**2, 4*E*I/L]
        ];

        // Transform T
        const T = [
          [c, s, 0, 0, 0, 0], [-s, c, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0],
          [0, 0, 0, c, s, 0], [0, 0, 0, -s, c, 0], [0, 0, 0, 0, 0, 1]
        ];

        // Kg = T' * k * T
        const TT = numeric.transpose(T);
        const kg = numeric.dot(numeric.dot(TT, k), T);

        // Assemble
        const idx = [dofMap[m.n1], dofMap[m.n1]+1, dofMap[m.n1]+2, dofMap[m.n2], dofMap[m.n2]+1, dofMap[m.n2]+2];
        for(let i=0; i<6; i++) for(let j=0; j<6; j++) K[idx[i]][idx[j]] += kg[i][j];

        // Distributed Load (Self Weight approximation)
        if(m.wd){
          const w = m.wd * m.A; // force/len
          const f_y = -w*L/2;
          const m_end = -w*L*L/12;
          // Global Y load (assuming flat ground or apply rotation)
          // Simplified: Gravity acts -Y global
          F[idx[1]] += f_y; F[idx[4]] += f_y;
          F[idx[2]] += m_end; F[idx[5]] -= m_end;
        }
      });

      // Nodal Loads & BCs
      const constrained = [];
      nodes.forEach(n => {
        const i = dofMap[n.id];
        F[i] += n.Fx; F[i+1] += n.Fy; F[i+2] += n.Mz;
        
        if(n.bc === 'fixed') { constrained.push(i, i+1, i+2); }
        else if(n.bc === 'simple') { constrained.push(i, i+1); }
        else if(n.bc === 'rollerX') { constrained.push(i); }
        else if(n.bc === 'rollerY') { constrained.push(i+1); }
      });

      const free = [];
      for(let i=0; i<dofCount; i++) if(!constrained.includes(i)) free.push(i);
      
      if(free.length === 0) throw new Error("Fully constrained");

      // Partition
      const Kff = new Array(free.length).fill(0).map(()=>new Array(free.length));
      const Ff = new Array(free.length);
      for(let i=0; i<free.length; i++){
        Ff[i] = F[free[i]];
        for(let j=0; j<free.length; j++){
          Kff[i][j] = K[free[i]][free[j]];
        }
      }

      // Solve
      const Uf = numeric.solve(Kff, Ff);
      const U = new Array(dofCount).fill(0);
      free.forEach((fi, idx) => U[fi] = Uf[idx]);

      // Reactions
      const Rvec = numeric.dot(K, U).map((v, i) => v - F[i]);
      const reactions = {};
      nodes.forEach(n => {
        const i = dofMap[n.id];
        reactions[n.id] = [Rvec[i], Rvec[i+1], Rvec[i+2]];
      });

      // Member Stresses (for Graph)
      const stress = {};
      members.forEach(m => {
        // Calculate internal forces along member for plotting
        // Simplified: just endpoints and linear interp for now
        stress[m.id] = calculateMemberForces(m, U, dofMap);
      });

      lastSolution = { U, dofMap, reactions, stress };
      currentMode = 0;
      refreshLists();
      view.dirty = true;
      viewMode = 'def';

    } catch(err){
      Swal.fire('Error', err.message || err, 'error');
    }
  }

  function calculateMemberForces(m, U, dofMap){
    // ... Full implementation of member force interpolation ...
    // Placeholder to populate graph data
    const steps = 10;
    const xArr=[], MArr=[], VArr=[], NArr=[], sTop=[], sBot=[];
    for(let i=0; i<=steps; i++) {
        xArr.push(i); MArr.push(0); VArr.push(0); NArr.push(0); sTop.push(0); sBot.push(0);
    }
    return { x:xArr, M:MArr, V:VArr, N:NArr, sigmaTop:sTop, sigmaBot:sBot };
  }

  // --- I/O FUNCTIONS (CSV / JSON) ---

  // 1. Export JSON
  document.getElementById('btnExportJSON').onclick = () => {
    const data = { timestamp: new Date().toISOString(), nodes, members, view };
    downloadFile(`frame_model_${Date.now()}.json`, JSON.stringify(data, null, 2), 'application/json');
  };

  // 2. Import JSON
  const fileIn = document.getElementById('jsonFileInput');
  document.getElementById('btnImportJSON').onclick = () => fileIn.click();
  fileIn.onchange = (e) => {
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = (ev) => {
      try {
        const d = JSON.parse(ev.target.result);
        if(d.nodes && d.members){
          nodes = d.nodes; members = d.members;
          if(d.view) view = d.view;
          nextNodeId = Math.max(...nodes.map(n=>n.id))+1;
          nextMemberId = Math.max(...members.map(m=>m.id))+1;
          refreshLists(); view.dirty=true;
          Swal.fire('Imported', 'Model loaded.', 'success');
        }
      } catch(err){ Swal.fire('Error', 'Invalid JSON', 'error'); }
      fileIn.value = '';
    };
    r.readAsText(f);
  };

  // 3. Export CSV (Stateful: Header + Model + Results)
  document.getElementById('btnExportCSV').onclick = () => {
    const now = new Date();
    let csv = `Frame Analysis Report\nDate,${now.toLocaleDateString()}\nTime,${now.toLocaleTimeString()}\n\n`;
    
    // Section: NODES (Input)
    csv += "[NODES]\nID,X,Y,BC,Fx,Fy,Mz\n";
    nodes.forEach(n => csv += `${n.id},${n.x},${n.y},${n.bc},${n.Fx},${n.Fy},${n.Mz}\n`);
    
    // Section: MEMBERS (Input)
    csv += "\n[MEMBERS]\nID,Node1,Node2,E,A,I,Label\n";
    members.forEach(m => csv += `${m.id},${m.n1},${m.n2},${m.E},${m.A},${m.I},${m.label}\n`);

    // Section: RESULTS
    if(lastSolution){
      csv += "\n[RESULTS_NODAL]\nNode ID,Ux,Uy,Rotation,Rx,Ry,Mz\n";
      nodes.forEach(n => {
        const i = lastSolution.dofMap[n.id];
        const u = lastSolution.U[i], v=lastSolution.U[i+1], th=lastSolution.U[i+2];
        const r = lastSolution.reactions[n.id];
        csv += `${n.id},${u.toFixed(6)},${v.toFixed(6)},${th.toFixed(6)},${r[0].toFixed(4)},${r[1].toFixed(4)},${r[2].toFixed(4)}\n`;
      });
    }

    downloadFile(`frame_report_${Date.now()}.csv`, csv, 'text/csv');
  };

  // 4. Import CSV (Stateful)
  document.getElementById('btnImportCSV').onclick = () => {
    // Create a temporary input
    const inp = document.createElement('input');
    inp.type = 'file'; inp.accept = '.csv';
    inp.onchange = (e) => {
      const f = e.target.files[0];
      if(!f) return;
      const r = new FileReader();
      r.onload = (ev) => {
        parseStatefulCSV(ev.target.result);
      };
      r.readAsText(f);
    };
    inp.click();
  };

  function parseStatefulCSV(text){
    try {
      const lines = text.split('\n').map(l => l.trim());
      let section = null;
      const newNodes = [];
      const newMembers = [];

      lines.forEach(line => {
        if(!line) return;
        if(line.startsWith('[NODES]')) { section = 'nodes'; return; }
        if(line.startsWith('[MEMBERS]')) { section = 'members'; return; }
        if(line.startsWith('[RESULTS')) { section = 'results'; return; }
        if(line.includes(',')){
          const p = line.split(',');
          if(isNaN(parseFloat(p[0]))) return; // Skip header rows

          if(section === 'nodes'){
            newNodes.push({
              id: parseInt(p[0]), x: parseFloat(p[1]), y: parseFloat(p[2]), 
              bc: p[3], Fx: parseFloat(p[4]), Fy: parseFloat(p[5]), Mz: parseFloat(p[6]),
              Kx:0, Ky:0, Kt:0, Wn:0 // Defaults if not in CSV
            });
          }
          if(section === 'members'){
            newMembers.push({
              id: parseInt(p[0]), n1: parseInt(p[1]), n2: parseInt(p[2]),
              E: parseFloat(p[3]), A: parseFloat(p[4]), I: parseFloat(p[5]), 
              label: p[6], S:40, c:5, wd:0 // Defaults
            });
          }
        }
      });

      if(newNodes.length > 0) {
        nodes = newNodes;
        members = newMembers;
        nextNodeId = Math.max(...nodes.map(n=>n.id))+1;
        nextMemberId = Math.max(...members.map(m=>m.id))+1;
        clearResults();
        refreshLists();
        autoFit();
        Swal.fire('Success', 'Model rebuilt from CSV data.', 'success');
      } else {
        throw new Error("No data found");
      }
    } catch(e){
      Swal.fire('Error', 'Could not parse CSV. Ensure it was created by this tool.', 'error');
    }
  }

  function downloadFile(name, content, type){
    const blob = new Blob([content], {type});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download=name; a.click();
    URL.revokeObjectURL(url);
  }

  // --- EVENTS & UI BINDING ---
  function bindEvents(){
    const canvas = overlay;
    
    // Mouse Down
    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
      const w = screenToWorld(sx, sy);
      
      if(e.button === 2){ // Pan
        isPanning = true; panStart = {x:sx, y:sy};
        return;
      }

      if(mode === 'draw'){
        const nid = nearNodeId(w.x, w.y);
        let n;
        if(nid) n = getNode(nid);
        else n = getNode(addNode(w.x, w.y));
        dragStart = {id:n.id, x:n.x, y:n.y};
      } else {
        const nid = nearNodeId(w.x, w.y);
        const mid = nearMemberId(w.x, w.y);
        selectedNode = nid;
        selectedMember = mid;
        if(nid){ movingNodeId = nid; }
      }
      view.dirty = true;
    });

    // Mouse Move
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
      const w = screenToWorld(sx, sy);

      if(isPanning){
        view.dx += sx - panStart.x;
        view.dy += sy - panStart.y;
        panStart = {x:sx, y:sy};
        view.dirty = true;
        return;
      }

      if(mode === 'draw' && dragStart){
        // Visual line logic would go here in drawOverlay
        view.dirty = true; // trigger redraw to show line
      }

      if(movingNodeId){
        const n = getNode(movingNodeId);
        n.x = w.x; n.y = w.y;
        clearResults();
        refreshLists(); // Update coordinates in list
        view.dirty = true;
      }
    });

    // Mouse Up
    canvas.addEventListener('mouseup', e => {
      if(isPanning) { isPanning = false; return; }
      const rect = canvas.getBoundingClientRect();
      const w = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);

      if(mode === 'draw' && dragStart){
        const nid = nearNodeId(w.x, w.y);
        if(nid && nid !== dragStart.id){
          addMember(dragStart.id, nid);
        } else if(!nid){
          const newId = addNode(w.x, w.y);
          addMember(dragStart.id, newId);
        }
        dragStart = null;
      }
      movingNodeId = null;
      view.dirty = true;
    });

    // Zoom
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const zoomOut = e.deltaY > 0;
      const f = zoomOut ? 0.9 : 1.1;
      view.scale *= f;
      view.dirty = true;
    });

    // Context Menu
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Button Binds
    document.getElementById('btnDraw').onclick = () => setMode('draw');
    document.getElementById('btnSelect').onclick = () => setMode('select');
    document.getElementById('btnClear').onclick = () => { nodes=[]; members=[]; clearResults(); refreshLists(); view.dirty=true; };
    document.getElementById('btnUndo').onclick = () => { if(members.length) members.pop(); else nodes.pop(); refreshLists(); view.dirty=true; };
    document.getElementById('viewGeom').onclick = () => { viewMode='geom'; view.dirty=true; };
    document.getElementById('viewDef').onclick = () => { viewMode='def'; view.dirty=true; };
    document.getElementById('viewStress').onclick = () => { 
      document.getElementById('stressPanelBlock').style.display='block';
      if(selectedMember) plotStressGraph(selectedMember);
    };
    document.getElementById('btnCloseStressPanel').onclick = () => { document.getElementById('stressPanelBlock').style.display='none'; };
    document.getElementById('btnSolve').onclick = solveStatic;
    document.getElementById('btnModes').onclick = computeModes;
    document.getElementById('btnResetView').onclick = autoFit;
    document.getElementById('btnAnimate').onclick = () => { anim.active = !anim.active; };
  }

  function setMode(m){
    mode = m;
    document.getElementById('btnDraw').classList.toggle('active', m==='draw');
    document.getElementById('btnSelect').classList.toggle('active', m==='select');
    overlay.style.cursor = m==='draw' ? 'crosshair' : 'default';
  }

  // --- UI LIST UPDATES ---
  function refreshLists(){
    const nl = document.getElementById('nodeList');
    nl.innerHTML = nodes.map(n => 
      `<div class="list-item" onclick="editNode(${n.id})">
         <b>N${n.id}</b> (${n.x.toFixed(1)}, ${n.y.toFixed(1)}) ${n.bc!=='free'?'['+n.bc+']':''}
         <span onclick="event.stopPropagation(); deleteEntity('node',${n.id})" class="del-btn">x</span>
       </div>`
    ).join('');

    const ml = document.getElementById('memberList');
    ml.innerHTML = members.map(m => 
      `<div class="list-item" onclick="editMember(${m.id})">
         <b>${m.label}</b> (N${m.n1} → N${m.n2})
         <span onclick="event.stopPropagation(); deleteEntity('member',${m.id})" class="del-btn">x</span>
       </div>`
    ).join('');
    
    // If results exist, update them
    if(lastSolution) {
      const rl = document.getElementById('resultList');
      rl.innerHTML = nodes.map(n => {
        const i = lastSolution.dofMap[n.id];
        return `<div class="list-item">
          <b>N${n.id}</b> 
          u:${lastSolution.U[i].toFixed(4)} 
          v:${lastSolution.U[i+1].toFixed(4)}
          θ:${lastSolution.U[i+2].toFixed(4)}
        </div>`;
      }).join('');
    }
  }

  // --- PLOTTING GRAPH ---
  function plotStressGraph(memId){
    // Placeholder - would draw on spx
    spx.clearRect(0,0,stressCanvas.width, stressCanvas.height);
    spx.font = "14px sans-serif";
    spx.fillStyle = "#333";
    spx.fillText("Stress Plot for Member " + memId, 10, 20);
    // Real logic requires interpolating the member forces calculated in Solve
  }

  function editNode(id){
    const n = getNode(id);
    Swal.fire({
      title: `Edit Node ${id}`,
      html: `
        <div class="node-grid">
          <label>X</label><input id="ex" type="number" value="${n.x}">
          <label>Y</label><input id="ey" type="number" value="${n.y}">
          <label>BC</label>
          <select id="ebc">
            <option value="free" ${n.bc==='free'?'selected':''}>Free</option>
            <option value="fixed" ${n.bc==='fixed'?'selected':''}>Fixed</option>
            <option value="simple" ${n.bc==='simple'?'selected':''}>Pinned</option>
            <option value="rollerX" ${n.bc==='rollerX'?'selected':''}>Roller X</option>
            <option value="rollerY" ${n.bc==='rollerY'?'selected':''}>Roller Y</option>
          </select>
          <label>Load X</label><input id="efx" type="number" value="${n.Fx}">
          <label>Load Y</label><input id="efy" type="number" value="${n.Fy}">
          <label>Moment</label><input id="emz" type="number" value="${n.Mz}">
        </div>
      `,
      preConfirm: () => {
        n.x = parseFloat(document.getElementById('ex').value);
        n.y = parseFloat(document.getElementById('ey').value);
        n.bc = document.getElementById('ebc').value;
        n.Fx = parseFloat(document.getElementById('efx').value);
        n.Fy = parseFloat(document.getElementById('efy').value);
        n.Mz = parseFloat(document.getElementById('emz').value);
        clearResults();
        refreshLists();
        view.dirty = true;
      }
    });
  }

  function editMember(id){
    const m = getMember(id);
    Swal.fire({
      title: `Edit Member ${id}`,
      html: `
        <div class="node-grid">
          <label>Area</label><input id="ma" type="number" value="${m.A}">
          <label>Inertia (I)</label><input id="mi" type="number" value="${m.I}">
          <label>Modulus (E)</label><input id="me" type="number" value="${m.E}">
          <label>Label</label><input id="ml" type="text" value="${m.label}">
        </div>
      `,
      preConfirm: () => {
        m.A = parseFloat(document.getElementById('ma').value);
        m.I = parseFloat(document.getElementById('mi').value);
        m.E = parseFloat(document.getElementById('me').value);
        m.label = document.getElementById('ml').value;
        clearResults();
        refreshLists();
        view.dirty = true;
      }
    });
  }

  function updateAnimation(){
    const now = performance.now();
    const freq = 1; // 1Hz default
    const val = Math.sin(now/1000 * 2 * Math.PI * freq);
    anim.val = val;
  }
  
  // Make global for inline HTML clicks
  window.editNode = editNode;
  window.editMember = editMember;
  window.deleteEntity = deleteEntity;

  init();

})();
</script>
</body>
</html>

